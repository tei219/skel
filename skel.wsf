<?xml version="1.0" encoding="Shift_JIS" standalone="yes" ?>
<package>
<job error="true" debug="false">
<script language="VBScript">
<![CDATA[
option explicit
'<!-- this line works as delimitre -->

'/* POLICIES
'    * all of messages of function write out to stdout or stderr.
'    * arguments are not be changed.
'    
'    # design
'    "FUNCTIONS_" affix applied to all of functions.
'    "FUNCTION_" affix applied to own function. 
'    cerr() has FUNCTION_CERR_ERRORLEVEL := (0,1,2) = (noerr, standard, debug)
'    f*() file utility always allow path-string/file.path argument
'    
'    # function returns
'      return void
'    + return value (string, array, etc.)
'    * return pointer (object)
'    - return value or pointer
'    ? return boolean 
'
'    function has sticky comment := RETURN_TYPE FUNCTION_NAME(ARG_TYPE, ...) :: depend_FUNCTION_NAME, ... \COMMENT,...\
'    
'    # typename
'    string, boolean, variable, variant() as array, dictionary, OBJECTNAME(*) as object, * as anything
'
'    skel option
'    /debug      : display checked function by valid_arguments()
'    /config     : set configname, default name defined skelconfname()
'    /configid   : set config id for read, default is unset
'    /notypecast : set uncast(string) value to config while read config
'    
'*/

'global definitions ====================================
CONST MATH_PI = 3.14159265358979
CONST NEGATIVE_INFINITY = &H80000000
CONST POSITIVE_INFINITY = &H7FFFFFFF
'INTMAX cint(2^15-1), 
'INTMIN cint(-2^15), 
'LONGMAX clng(2^31-1), 
'LONGMIN clng(-2^32), hex(-2^31)
'for Errors --------------------------------------------
CONST ERR_FUNCTIONARG                        = 1
CONST ERR_FUNCTIONARG_NOTMATCHED             = 2
CONST ERR_FUNCTION_PADDING                   = 10
CONST ERR_FUNCTION_S2A                       = 11
CONST ERR_FUNCTION_FXML                      = 12
CONST ERR_FUNCTION_F2A                       = 13
CONST ERR_FUNCTION_F2V                       = 14
CONST ERR_FUNCTION_F2D                       = 15
CONST ERR_FUNCTION_ARRAY_GRAB                = 16
CONST ERR_FUNCTION_CNUM                      = 17
CONST ERR_FUNCTION_SL                        = 18
CONST ERR_FUNCTION_EVENTLOG                  = 19
CONST ERR_FUNCTION_SELECTFOLDER              = 20
CONST ERR_FUNCTION_FHEADN                    = 30
CONST ERR_FUNCTION_FTAILN                    = 31
CONST ERR_FUNCTION_FCAT                      = 32
CONST ERR_FUNCTION_FCUT                      = 33
CONST ERR_FUNCTION_FCLEANUP                  = 34
CONST ERR_FUNCTION_FGREP                     = 35
CONST ERR_FUNCTION_SKELCONFIGNAME            = 50
CONST ERR_FUNCTION_SETCONFIG                 = 51
'for Functions -----------------------------------------
CONST FUNCTIONS_ARGUMENTSTYPE_CHECK          = true
CONST FUNCTIONS_UNIXTIME_BASIS               = #1970/01/01 00:00:00#

CONST FUNCTION_EVENTLOG_SUCCESS              = 0
CONST FUNCTION_EVENTLOG_ERROR                = 1
CONST FUNCTION_EVENTLOG_WARNING              = 2
CONST FUNCTION_EVENTLOG_INFORMATION          = 4
CONST FUNCTION_EVENTLOG_AUDIT_SUCCESS        = 8
CONST FUNCTION_EVENTLOG_AUDIT_FAILURE        = 16
CONST FUNCTION_NEWCMD_WAITTIME               = 1000
CONST FUNCTION_CMDKEY_WAITTIME               = 100
CONST FUNCTION_DICTIONARY_FORMAT             = "^{\s*([^,][^,]*)\s*=>\s*([^,][^,]*)\s*(,\s*([^,][^,]*)\s*=>\s*([^,][^,]*)\s*){0,}}$"
CONST FUNCTION_PMAILER_SCHEMA                = "http://schemas.microsoft.com/cdo/configuration"
'suspending --------------------------------------------
CONST CLASS_WM_TERMINATE_WAITTIME            = 1000
CONST FUNCTION_CONFIGURE_SET_EMPTY           = false
'suspending --------------------------------------------


'global variables ======================================
'for skel ----------------------------------------------
dim CSCRIPTLAUNCH                            'if launched by 'cscript', set value.
'for Functions -----------------------------------------
'(flog) ------------------------------------------------
dim FUNCTION_FLOG_TYPENAME                   'flog0 -> logged to console (and echo(), echon() function will be set to disable)
                                             'flog1 -> logged to `FUNCTION_FLOG_FILENAME`.log (no log-rotate)
                                             'flog2 -> logged to "./yyyymmdd.log"
                                             'flog3 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated at each execution
                                             'flog4 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated at each day
                                             'flog5 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated at each size
                                             'flog6 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated pattern by FUNCTION_FLOG_ROTATEPATTERN
                                             'if set /logbase option, adopt aan("logbase").log for log-filename on flog[1345]
    FUNCTION_FLOG_TYPENAME                   = "flog0"
dim FUNCTOIN_FLOG_LOGDIR                     'default log directory is created on same path of script.
    FUNCTOIN_FLOG_LOGDIR                     = wscript.createobject("scripting.filesystemobject").buildpath(wscript.createobject("scripting.filesystemobject").getparentfoldername(wscript.scriptfullname), "log")
dim FUNCTION_FLOG_FILENAME                   'default log filename is `FUNCTOIN_FLOG_LOGDIR`\`scriptname`.log set by flogname() function
    FUNCTION_FLOG_FILENAME                   = empty
dim FUNCTION_FLOG_EPID                       'emulated pid
dim FUNCTION_FLOG_ROTATE_MAXCOUNT
		FUNCTION_FLOG_ROTATE_MAXCOUNT            = 10
dim FUNCTION_FLOG_ROTATE_MAXSIZE
		FUNCTION_FLOG_ROTATE_MAXSIZE             = 1048576
dim FUNCTION_FLOG_ROTATE_PATTERN 
		FUNCTION_FLOG_ROTATE_PATTERN             = "yyyynnddHH"
'(datetime) --------------------------------------------
dim FUNCTION_DATETIME_TYPENAME               'datetime0 -> 100114165801
                                             'datetime1 -> 2010/11/41 16:58:01.12
                                             'datetime2 -> 2010/11/41 16:58:01
                                             'datetime3 -> 20101141165801
    FUNCTION_DATETIME_TYPENAME               = "datetime1"
'(skelconf) --------------------------------------------
dim FUNCTOIN_SKELCONFIGNAME_CONFDIR          'default log directory is created on same path of script.
    FUNCTOIN_SKELCONFIGNAME_CONFDIR          = wscript.createobject("scripting.filesystemobject").buildpath(wscript.createobject("scripting.filesystemobject").getparentfoldername(wscript.scriptfullname), "conf")
'(else) ------------------------------------------------
dim FUNCTION_ECMD_EXT
		FUNCTION_ECMD_EXT                        = array("",".com",".exe",".bat",".cmd",".vbs",".js",".jar",".wsf")
dim FUNCTION_CERR_ERRORLEVEL
		FUNCTION_CERR_ERRORLEVEL                 = 1
dim FUNCTION_DUMPER_LABEL
		FUNCTION_DUMPER_LABEL                    = "(dumper) "
dim FUNCTION_DUMPER_LEVEL
		FUNCTION_DUMPER_LEVEL                    = 0
dim FUNCTION_FLOG_INIT                       'if called 'flog()', set value.
dim FUNCTION_FCLEANUP_BLOCK_REMOVE
    FUNCTION_FCLEANUP_BLOCK_REMOVE           = array(array("/\*","\*/")) 'array( pattern1(start, end), pattern2()... )
dim FUNCTION_FCLEANUP_LINE_REMOVE
    FUNCTION_FCLEANUP_LINE_REMOVE            = array("(#|'|//|--|/\*)") 'array( pattern1, pattern2... )
dim FUNCTION_FCLEANUP_LINE_REMOVE2
    FUNCTION_FCLEANUP_LINE_REMOVE2           = array("(//|--)") 'array( pattern1, pattern2... )
dim FUNCTION_FCLEANUP_LINE_REMOVE3
    FUNCTION_FCLEANUP_LINE_REMOVE3           = array("'","#") 'array( pattern1, pattern2... )
dim FUNCTION_FCLEANUP_STRING_BRACE
    FUNCTION_FCLEANUP_STRING_BRACE           = """"
dim FUNCTION_TH_LIMITCHECK_CPUCOUNT          'if you want to change value, replace value to number or 'iif(env("%NUMBER_OF_PROCESSORS%")="%NUMBER_OF_PROCESSORS%", 2, cint(env("%NUMBER_OF_PROCESSORS%")))' 
    FUNCTION_TH_LIMITCHECK_CPUCOUNT          = cint(2)

'= functions ='=========================================
'# checker #
'?valid_arguments(string, array, array) :: FUNCTIONS_ARGUMENTSTYPE_CHECK, cerr, ERR_FUNCTIONARG_  \this function is primitive so do not use userfunctions (exclude cout,cerr) in this.\
function valid_arguments(f, a, b) : dim i,c : valid_arguments = true : dim af,at : af = "" : at = "" : if not FUNCTIONS_ARGUMENTSTYPE_CHECK then : exit function : end if : for each c in a : af = af&typename(c)&", " : next : for each c in b : at = at&c&", " : next : af = left(af,len(af)-2) : at = left(at,len(at)-2) : if wscript.arguments.named.exists("debug") then : cout( f ) : end if : if ubound(a) = ubound(b) then : for i=0 to ubound(a) : if not instr(replace(replace(replace(replace(b(i),"mail","imessage"),"numeric","integer/long/single/float/double"),"array","variant()"),"value","integer/long/float/double/string/boolean/single/currency/byte"), lcase(typename(a(i))))>0 and not b(i) = "*" then : cerr("(valid_arguments) function '"&f&"()' required ("&at&"), not matched ("&af&")") : err.raise ERR_FUNCTIONARG_NOTMATCHED, f&"()","ERR_FUNCTIONARG_NOTMATCHED"  : end if : next : else : cerr("(valid_arguments) function '"&f&"()' required ("&at&")") : err.raise ERR_FUNCTIONARG, f&"()","ERR_FUNCTIONARG"  : end if : end function : 

'# evaluation #
'?e(string/empty) :: valid_arguments, afso \(file_path)\
function e(s) : call valid_arguments("e", array(s), array("string/empty/file")) : e = afso.fileexists(s) : end function
'?ef(string/empty) :: valid_arguments, afso \(folder_path)\
function ef(s) : call valid_arguments("ef", array(s), array("string/empty/folder")) : ef = afso.folderexists(s) : end function
'?ea(string/empty) :: valid_arguments, ea \(named_argument)\
function ea(s) : call valid_arguments("ea", array(s), array("string/empty")) : ea = aarg.named.exists(s) : end function
'?eau(string/empty) :: valid_arguments, ea, aan \(named_argument) is exists and have length\
function eau(s) : call valid_arguments("eau",array(s),array("string/empty")) : eau = (ea(s) and len(aan(s))>0) : end function
'?ed(dictionary, string) :: valid_arguments \(dictionary, key_string)\
function ed(d, s) : call valid_arguments("ed",array(d,s),array("dictionary","value")) : ed = d.exists(s) : end function
'+ecmd(string) :: valid_arguments, FUNCTION_ECMD_EXT, buildpath \(command_string), search command and if found, returns command file path\
function ecmd(s) : dim p, c : call valid_arguments("ecmd",array(s),array("string")) : for each p in split(env("%path%")&";.\",";") : for each c in FUNCTION_ECMD_EXT : if e(buildpath(p,s&c)) then : ecmd = buildpath(p,s&c) : exit function : end if : next : next : end function
'--
'?iscscript() :: filename \launched by cscript?\
function iscscript() : iscscript = (instr(lcase(filename(wscript.fullname)),"cscript.exe")>0) : end function
'?iscmd(string) :: valid_arguments, iif, ecmd \(command_string), search command for each %path% and current directory.\
function iscmd(s) : call valid_arguments("iscmd",array(s),array("string")) : iscmd = iif(len(ecmd(s))>0,true,false) : end function
'-iif(boolean, *, *) :: valid_arguments, bind \immediate if\
function iif(c,t,f) : call valid_arguments("iif",array(c,t,f),array("boolean","*","*")) : if (c) then : call bind(iif,t) : else : call bind(iif,f) : end if : end function
'?isinteger(*) :: \\
function isinteger(v) : isinteger = cbool(vartype(v) = vbInteger) : end function
'?isint(*) :: isinteger \alias to isinteger()\
function isint(v) : isint = isinteger(v) : end function
'?islong(*) :: \\
function islong(v) : islong = cbool(vartype(v) = vbLong) : end function
'?issingle(*) :: \\
function issingle(v) : issingle = cbool(vartype(v) = vbSingle) : end function
'?isdouble(*) :: \\
function isdouble(v) : isdouble = cbool(vartype(v) = vbDouble) : end function
'?iscurrency(*) :: \\
function iscurrency(v) : iscurrency = cbool(vartype(v) = vbCurrency) : end function
'?isstring(*) :: \\
function isstring(v) : isstring = cbool(vartype(v) = vbString) : end function
'?iserror(*) :: \\
function iserror(v) : iserror = cbool(vartype(v) = vbError) : end function
'?isboolean(*) :: \\
function isboolean(v) : isboolean = cbool(vartype(v) = vbBoolean) : end function
'?isvariant(*) :: \\
function isvariant(v) : isvariant = cbool(vartype(v) = vbVariant) : end function
'?isdataobject(*) :: \\
function isdataobject(v) : isdataobject = cbool(vartype(v) = vbDataObject) : end function
'?isbyte(*) :: \\
function isbyte(v) : isbyte = cbool(vartype(v) = vbByte) : end function
'isvalue(*) :: isnothing \value is not array, object, empty, nothing or null\
function isvalue(v) : isvalue = not (isarray(v) or isobject(v) or isempty(v) or isnothing(v) or isnull(v)) : end function
'?isdictionary(*) :: adic \\
function isdictionary(v) : isdictionary = (typename(v) = typename(adic())) : end function
'?ismatch(*) :: getmatch \\
function ismatch(v) : ismatch = (typename(v) = typename(getmatch("",""))) : end function
'?isnothing(*) :: \\
function isnothing(v) : isnothing = (typename(v) = typename(nothing)) : end function
'?iswshexec(*) :: ashell \\
function iswshexec(v) : iswshexec = (typename(v) = typename(ashell.exec("cmd.exe /c rem"))) : end function
'?isdb(*) :: adb \\
function isdb(v) : isdb = (typename(v) = typename(adb())) : end function
'?isrgp(*) :: rgp \\
function isrgp(o) : isrgp = (typename(o) = typename(rgp(""))) : end function
'?issubmatch(*) :: getmatch \\
function issubmatch(o) : issubmatch = (typename(o) = typename(getmatch("t","(t)")(0).submatches)) : end function
'?isfile(*) :: afso \\
function isfile(o) : isfile = (typename(o) = typename(afso.getfile(wscript.scriptfullname))) : end function
'?isfolder(*) :: afso \\
function isfolder(o): isfolder = (typename(o) = typename(afso.getfolder(afso.getparentfoldername(wscript.scriptfullname)))) : end function
'?istextstream(*) :: ftsread \\
function istextstream(o) : istextstream = (typename(o) = typename(ftsread(wscript.scriptfullname))) : end function
'?isstream(*) :: fsread \\
function isstream(o) : isstream = (typename(o) = typename(fsread(wscript.scriptfullname))) : end function
'?isxml(*) :: strcmp, axml \\
function isxml(o) : isxml = (typename(o) = typename(axml())) : end function
'?isxmlchild(*) :: xml \\
function isxmlchild(o) : isxmlchild = (typename(o) = typename(xml("<a/>").childnodes)) : end function
'?ismail(*) :: amail \\
function ismail(m) : dim a : set a = amail() : ismail = false : if isnothing(a) then : exit function : else : ismail = (typename(m) = typename(a)) : end if : end function

'--
'?isprintable(*) :: isvalue \\
function isprintable(v) : isprintable = isvalue(v) : end function
'?isdirectory(string) :: ef \alias of ef()\
function isdirectory(s) : isdirectory = ef(s) : end function
'?isinarray(array,value) :: valid_arguments, isvalue, cerr \search value in array\
function isinarray(a,v) : dim b : call valid_arguments("isinarray",array(a,v),array("array","value")) : isinarray = false : for each b in a : if isvalue(b) then : if b = v then : isinarray = true : exit function : end if : else : cerr("(isinarray) found not value in array, skipped.") : end if : next : end function
'?isinarray_obj(array, *) :: valid_arguments \search obj by typename in array\
function isinarray_obj(a,o) : dim b : call valid_arguments("isinarray_obj", array(a,o), array("array","*")) : isinarray_obj = false : for each b in a : if typename(b) = typename(o) then : isinarray_obj = true : exit function : end if : next : end function
'?isinarray_string(array, string/numeric) :: valid_arguments, isstring, rmatch, cerr \(array, regexp_string)search string in array\
function isinarray_string(a,s) : dim b : isinarray_string = false : call valid_arguments("isinarray_string",array(a,s),array("array","string")) : for each b in a : if isstring(b) then : if rmatch(b,s) then : isinarray_string = true : exit function : end if : else : cerr("(isinarray_string) found '"&typename(b)&"' in array, skipped.") : end if : next : end function
'?isindictionary(dictionary, value) :: valid_argumens, isvalue, cerr \search value in dictionary\
function isindictionary(d,v) : dim b : call valid_arguments("isindictionary",array(d,v),array("dictionary","value")) : isindictionary = false : for each b in d : if isvalue(b) then : if d(b) = v then : isindictionary = true : exit function : end if : else : cerr("(isindictionary) found not value in dictionary, skipped.") : end if : next : end function
'?isindictionary_obj(dictionary, *) :: valid_arguments \search obj by typename in dictionary\
function isindictionary_obj(d,o) : dim b : isindictionary_obj = false : call valid_arguments("isindictionay_obj",array(d,o),array("dictionary","*")) : for each b in d : if typename(d(b)) = typename(o) then : isindictionary_obj = true : exit function : end if : next : end function
'?isindictionary_string(dictionary, string/numeric) :: valid_arguments, isstring, rmatch, cerr \(dictionary, regexp_string) search string in dictionary\
function isindictionary_string(d,s) : dim b : isindictionary_string = false : call valid_arguments("isindictionary_string",array(d,s),array("dictionary","string")) : for each b in d : if isstring(d(b)) then : if rmatch(d(b), s) then : isindictionary_string = true : exit function : end if : else : cerr("(isindictionary_string) found '"&typename(d(b))&"' in dictionary, skipped.") : end if : next : end function
'--
'?isroot(*) :: valid_arguments, isfolder, ef, afso \isrootfolder? \
function isroot(so) : call valid_arguments("isroot",array(so),array("folder/string")) : if isfolder(so) then : isroot = so.isrootfolder : else : if ef(so) then : isroot = afso.getfolder(so).isrootfolder : else : cerr("(isroot) not exists folder '"&so&"'.") : isroot = false : end if : end if : end function
'?isping(string) :: valid_arguments, texec \is ping responce?\
function isping(s) : call valid_arguments("isping",array(s),array("string")) : isping = false : if wexec("cmd /c ping.exe -w 1 -n 1 -4 "&s&" >nul ").exitcode = 0 then : isping = true : end if : end function
'?isusewmi() :: \can use wmi?\
function isusewmi() : on error resume next : call getobject("winmgmts:\\.\root\cimv2") : if err.number <> 0 then : isusewmi = false : err.clear : else : isusewmi = true : end if : end function
'--
'?iswshexec_array(array) :: valid_arguments, iswshexec \for th_* functions, check all values are wshexec object\
function iswshexec_array(a) : dim o : call valid_arguments("iswshexec_array",array(a),array("array")) : for each o in a : if not iswshexec(o) then : iswshexec_array = false : exit function : end if : next : iswshexec_array = true : end function

'# bind #
'bind(variable,*) :: \\
function bind( k,byval v) : if(isobject(v)) then : set k = v : else k = v : end if : end function
'?swap(*, *) :: valid_arguments, bind \swap variable, returns true\
function swap(a,b) : dim t : call valid_arguments("swap",array(a,b),array("*","*")) : call bind(t,a) : call bind(a,b) : call bind(b,t) : swap = true : end function : 


'# regular expression #
'*rgo(string, string) :: valid_arguments \(pattern, options[igo])\
function rgo(p,o) : call valid_arguments("rgo",array(p,o),array("string","string")) : set rgo = new regexp : rgo.pattern = p : rgo.ignorecase = (instr(o,"i")>0) : rgo.global = (instr(o,"g")>0) : rgo.multiline = (instr(o,"o")>0) : end function
'*rgp(string) :: valid_arguments \(pattern)\
function rgp(p) : call valid_arguments("rgp",array(p),array("string")) : set rgp = new regexp : rgp.pattern = p : end function
'?rmatch(string, string) :: valid_arguments, rgp \(target, pattern)\
function rmatch(s,p) : call valid_arguments("rmatch",array(s,p),array("string","string")) : rmatch = rgp(p).test(s) : end function
'?rmatchi(string, string) :: valid_arguments, rgo \(target, pattern)\
function rmatchi(s,p) : call valid_arguments("rmatchi",array(s,p),array("string","string")) : rmatchi = rgo(p,"i").test(s) : end function
'*getmatch(string, string) :: valid_arguments, rgo \(target, pattern)\
function getmatch(s,p) : call valid_arguments("getmatch",array(s,p),array("string","string")) : set getmatch = rgo(p,"g").execute(s) : end function
'*getsubmatch(string, string) :: valid_arguments, getmatch, \(target, pattern), pattern must inlcude ()\
function getsubmatch(s,p) : dim i,g : call valid_arguments("getsubmatch",array(s,p),array("string","string")) : set g = getmatch(s,p) : if (g.count>0) then : for i=0 to g.count-1 : if (g(i).submatches.count>0) then : set getsubmatch = g(i).submatches : end if : next : end if : end function
'+rreplace(string, string, string) :: valid_arguments, rgo \(target, pattern, replacement)\
function rreplace(s,p,r) : call valid_arguments("rreplace",array(s,p,r),array("string","string","string")) : rreplace = rgo(p,"g").replace(s,r) : end function
'+rremove(string, string) :: valid_arguments, rreplace \(target, removement)\
function rremove(s,p) : call valid_arguments("rreplace",array(s,p),array("string","string")) : rremove = rreplace(s,p,"") : end function

'# strings #
'?strcmp(string, string) :: valid_arguments \strcmp returns loose match result, strcmp("Test","test") => true\
function strcmp(s,t) : strcmp = false : call valid_arguments("strcmp",array(s,t),array("string","string")) : strcmp = (lcase(s) = lcase(t)) : end function
'?strcmpr(string, string) :: valid_arguments \rstrcmp returns strict match result, rstrcmp("Test","test") => false\
function strcmpr(s,t) : strcmpr = false : call valid_arguments("strcmpr",array(s,t),array("string","string")) : strcmpr = (s = t) : end function
'--
'+dleft(string, integer/long/single) :: valid_arguments \(target, delete_position) delete from left\
function dleft(s,n) : call valid_arguments("dleft",array(s,n),array("string","integer/long/single")) : if len(s)>n then : dleft = right(s, len(s)-n) : else dleft = "" : end if : end function
'+dright(string, integer/long/single) :: valid_arguments \(target, delete_position) delete from right, equal left()\
function dright(s,n) : call valid_arguments("dright",array(s,n),array("string","integer/long/single")) : if len(s)>n then : dright = left(s, len(s)-n) : else dright = "" : end if : end function
'replicate(string, integer) :: valid_arguments \repeat n times string\
function replicate(s,n) : dim i,b : b = "" : call valid_arguments("replicate",array(s,n),array("string","integer")) : for i=1 to n : b = b&s : next : replicate = b : end function
'+revstr(string) :: reverse \\
function revstr(s) : revstr = reverse(s) : end function
'+reverse(string) :: valid_arguments \\
function reverse(s) : call valid_arguments("reverse",array(s),array("value")) : reverse = strreverse(s) : end function
'--
'primitive padding
'+ppadding(value, string, integer, boolean) :: valid_arguments, cerr \(target, padding_char, length, direction) returns string.\
function ppadding(s,c,n,f) : call valid_arguments("ppadding",array(s,c,n,f),array("value","string","integer","boolean")) : if len(cstr(s))>=n then : ppadding = cstr(s) : else : if len(c)>1 then : cerr("(ppadding) padding string has length("&len(c)&"), use first char.") : end if : if len(c)>0 and n>len(cstr(s)) then : if f then : ppadding = string(n-len(cstr(s)),c)&s : else : ppadding = s&string(n-len(cstr(s)),c) : end if : else : cerr("(ppadding) invalid padding string") : err.raise ERR_FUNCTION_PADDING, "use empty string for padding","ERR_FUNCTION_PADDING"  : end if : end if : end function
'+padding(value, integer) :: ppadding \padding by " "\
function padding(s,n) : padding = ppadding(s," ",n,true) : end function
'+padding_right(value, string, integer) :: ppadding \padding from right, alias\
function padding_right(s,c,n) : padding_right = ppadding(s,c,n,false) : end function
'+padding_left(value, string, integer) :: ppadding \padding from left, alias\
function padding_left(s,c,n) : padding_left = ppadding(s,c,n,true) : end function
'--
'+divide(string, string) :: valid_arguments \(target, divide_string) divide target by first found position. returns array()\
function divide(s,c) : call valid_arguments("divide",array(s,c),array("string","string")) : if instr(s,c)>0 then : divide = array(split(s,c)(0), dleft(s,len(split(s,c)(0)&c))) : else : divide = array(s,"") : end if : end function
'e.g. String( "test string" ) => String(test string), String( "te st" .) => String("te st" .)
'+btrim(string) :: valid_arguments, rmatch, getsubmatch \brackets trim\
function btrim(s) : dim b : call valid_arguments("btrim",array(s),array("string")) : b = trim(s) : if rmatch(b,"^""(.*)""$") then : b = getsubmatch(b,"^""(.*)""$")(0) : end if : btrim = b : end function
'--
'+chop(string) :: valid_arguments, dright \returns removed string, alias to dright()\
function chop(s) : call valid_arguments("chop",array(s),array("string")) : chop = dright(s,1) : end function
'+chomp(string) :: valid_arguments, dright \returns removed string\
function chomp(s) : call valid_arguments("chomp",array(s),array("string")) : if right(s,2) = vbnewline then : chomp = dright(s,2) : else : chomp = s : end if : end function
'*byref_chop(string) :: valid_arguments, dright \returns string, perl like. string is modified.\
function byref_chop(byref s) : call valid_arguments("byref_chop",array(s),array("string")) : byref_chop = right(s,1) : s = dright(s,1) : end function
'+byref_chomp(string) :: valid_arguments, dright \returns numeric, perl like. string is modified.\
function byref_chomp(byref s) : call valid_arguments("byref_chomp",array(s),array("string")) : if right(s,2) = vbnewline then : byref_chomp = len(right(s,2)) : s = dright(s,2) : else : byref_chomp = "" : end if : end function

'# transform #
'e.g. s2a("test, test1, test21",",") => array("test"," test1"," test21")
'e.g. s2a("test, test1, test21",3) => ("tes","t, ","tes","t1," ... "1  ")
'+s2a(string, string/integer) :: valid_arguments, isstring, push, dleft, ERR_FUNCTION_S2A \(target, delimiter_string/point) string to array\
function s2a(s, d) : dim b,a : a = array() : call valid_arguments("s2a",array(s,d),array("string","string/integer")) : if isstring(d) then : s2a = split(s,d) : else : b = s : if d>0 then : do until len(b)<=d : call push(a,left(b,d)) : b = dleft(b,d) : loop : if len(b)>0 then : call push(a,b&string(d-len(b)," ")) : end if : s2a = a : else : cerr("(s2a) invalid split length.") : err.raise ERR_FUNCTION_S2A, "invalid split length","ERR_FUNCTION_S2A" : end if : end if : end function
'+f2a(file/string) :: valid_arguments, isfile, e, cerr, ERR_FUNCTION_F2A, ftsread, push \(file/path_string) file to array\
function f2a(fn) : dim f, o, a : a = array() : call valid_arguments("f2a",array(fn),array("file/string")) : if isfile(fn) then : f = fn.path : else : f = fn : end if : if not e(f) then : cerr("(f2a) '"&f&"' is missing ") : err.raise ERR_FUNCTION_F2A, "'"&f&"' is missing ", "ERR_FUNCTION_F2A" : end if : set o = ftsread(f) : do until o.atendofstream : call push(a,o.readline) : loop : f2a = a : end function
'+f2v(file/string) :: valid_arguments, isfile, e, ftsread, cerr, ERR_FUNCTION_F2V \(file/path_string) file to variable\
function f2v(fn) : dim f, o, b : b = "" : call valid_arguments("f2v",array(fn),array("file/string")) : if isfile(fn) then : f = fn.path : else : f = fn : end if : if e(f) then : set o = ftsread(f) : do until o.atendofstream : b = b&o.readline&vbnewline : loop : f2v = b : else : cerr("(f2v) '"&f&"' is missing. ") : err.raise ERR_FUNCTION_F2V, "'"&f&"' is missing ", "ERR_FUNCTION_F2V" : end if : end function
'+f2s(file/string) :: a2s, f2a \(file/path_string) file to 1 line string\
function f2s(fn) : f2s = a2s(f2a(fn)," ") : end function
'e.g. au2a() := skel.wsf a b c / /: /:1 => array("a","b","c")
'+au2a() :: aarg, push \unnamed argument to array\
function au2a() : dim b,a : a = array() : for each b in aarg.unnamed : call push(a, b) : next : au2a = a : end function
'e.g. an2a() := skel.wsf a b c / /a /a: /a:1 => array("",empty,"a",empty,"a","","a","1")
'+an2a() :: aarg, push \named argument to array such as (key1, value1, key2, value2 ...)\
function an2a() : dim b,a : a = array() : for each b in aarg.named : call push(a,b) : call push(a,aarg.named(b)) : next : an2a = a : end function

'*f2drs(file/string, string, integer, integer) :: f2d \(filename, array(regexp_pattern, keyno, value_no))\
function f2drs(fn, regexp_pattern, keyno, valno) : call valid_arguments("f2drs",array(fn, regexp_pattern, keyno, valno),array("file/string", "string", "integer", "integer")) : set f2drs = f2d(fn, array(regexp_pattern, keyno, valno)) : end function
'*f2dr(file/string, string, string) :: f2d \(filename, array(regexp_pattern, delim_string))\
function f2dr(fn, regexp_pattern, delim_string) : call valid_arguments("f2dr",array(fn, regexp_pattern, delim_string), array("file/string","string","string")) : set f2dr = f2d(fn, array(regexp_pattern, delim_string)) : end function
'e.g. f2d("test.txt", ",") simple separate with trim
'e.g. f2d("test.txt", array("^.*=.*$","=")) separate with pattarn check and trim
'e.g. f2d("test.txt", array("^(.*)=(.*)$",0,1)) separate with regular expression
'*f2d(file/string, string/array) :: valid_arguments, adic, isfile, e, cerr, ERR_FUNCTION_F2D, ftsread, isstring, divide, dic, rmatch, getmatch, max \(file/path_string, pattern/array("pattern","separator") or array("pattern",key_indicator, value_indicator)))\
function f2d(fn, a) : dim b, f, o, d : call valid_arguments("f2d",array(fn,a),array("file/string","string/array")) : set d = adic() : if isfile(fn) then : f = fn.apth : else : f = fn : end if : if not e(f) then : cerr("(f2d) '"&f&"' is missing.") : err.raise ERR_FUNCTION_F2D, "'"&f&"' is missing.", "ERR_FUNCTION_F2D" : end if : set o = ftsread(f) : do until o.atendofstream : b = o.readline : select case isstring(a) : case true : if instr(b,a)>0 then : b = divide(b, a) : call dic(d, btrim(b(0)), btrim(b(1))) : end if : case else : if rmatch(b, a(0)) then : set b = getmatch(b,a(0)) : if ubound(a)>1 then : if b(0).submatches.count > max(cint(a(1)),cint(a(2))) then : call dic(d, btrim(b(0).submatches(cint(a(1)))), btrim(b(0).submatches(cint(a(2))))) : else : cerr("(f2d) '"&b(0)&"' has unmatched submatch section, can't allocate key/value.") : err.raise ERR_FUNCTION_F2D, "'"&b(0)&"' has unmatched submatch section, can't allocate key/value.", "ERR_FUNCTION_F2D" : end if : else : b = divide(b(0).value, a(1)) : call dic(d, btrim(b(0)), btrim(b(1))) : end if : end if : end select : loop : set f2d = d : end function

'primitive a2s
'+pa2s(array, string) :: valid_arguments \\
function pa2s(a,c) : dim i, s : s = "" : call valid_arguments("pa2s",array(a,c),array("array","string")) : for i=0 to ubound(a)-1 : s = s&a(i)&c : next : s = s&a(i) : pa2s = s : end function
'+a2s(array) :: pa2s \always returns string\
function a2s(a) : a2s = pa2s(a," ") : end function : 
'*a2d(array) :: dictionary \each element's format must meet FUNCTION_DICTIONARY_FORMAT condition.\
function a2d(a) : set a2d = dictionary(a) : end function
'*s2d(string) :: dictionary \string format must meet FUNCTION_DICTIONARY_FORMAT condition.\
function s2d(s) : set s2d = dictionary(s) : end function
'+d2s(dictionary) :: valid_arguments \according to the format FUNCTION_DICTIONARY_FORMAT\
function d2s(d) : dim b, s : s = "{ " : call valid_arguments("d2s",array(d),array("dictionary")) : for each b in d : s = s&""""&b&""" => """&d(b)&""", " : next : s = s&" }" : d2s = s : end function
'+d2a(dictionary) :: valid_arguments, push \according to the format FUNCTION_DICTIONARY_FORMAT\
function d2a(d) : dim b,a : a = array() : call valid_arguments("d2a",array(d),array("dictionary")) : for each b in d : call push(a,""""&b&""" => """&d(b)&"""") : next : d2a = a : end function

'+cast(value, string) :: valid_arguments, cerr \if cannot cast value to type, display error message.\
function cast(v,s) : dim b : call valid_arguments("cast",array(v,s),array("*","string")) : b = lcase(s) : on error resume next : select case b : case "int" : cast = cint(v) : case "integer" : cast = cint(v) : case "str" : cast = cstr(v) : case "string" : cast = cstr(v) : case "date" : cast = cdate(v) : case "time" : cast = cdate(v) : case "datetime" : cast = cdate(v) : case "lng" : cast = clng(v) : case "long" : cast = clng(v) : case "sng" : cast = csng(v) : case "single" : cast = csng(v) : case "dbl" : cast = cdbl(v) : case "double" : cast = cdbl(v) : case "bool" : cast = cbool(v) : case "boolean" : cast = cbool(v) : case "byte" : cast = cbyte(v) : case "cur" : cast = ccur(v) : case "currency" : cast = ccur(v) : case "money" : cast = ccur(v) : case "null" : cast = null : case "empty" : cast = empty : case else : cast = empty : end select : if err.number <> 0 then : cerr("(cast) can't cast to '"&s&"'.") : err.clear : end if : end function
'cnum(value) :: valid_arguments, rmatch, cerr, ERR_FUNCTION_CNUM \cast NUMER-STRING "^\s*-*\d*(\.\d*)*\s*$" to number.\
function cnum(o) : call valid_arguments("cnum",array(o),array("value")) : if rmatch(o, "^\s*-*\d*(\.\d*)*\s*$") then : if rmatch(o,"\.") then : cnum = cdbl(o) : else : on error resume next : cnum = cint(o) : if err.number <> 0 then : err.clear : cnum = clng(o) : if err.number <> 0 then : err.clear : cnum = 0 : end if : end if : end if : else : cerr("(cnum) argument is not number string") : err.raise ERR_FUNCTION_CNUM, "argument is not number string", "ERR_FUNCTION_CNUM" : end if : end function

'# calculation #
'+pfloor(numeric, numeric) :: valid_arguments, iif \\
function pfloor(n,d) : call valid_arguments("pfloor",array(n,d), array("numeric", "numeric")) : pfloor = iif(n<fix(n),(fix(n/d)-1)*d,fix(n/d)*d) : end function
'+floor(numeric) :: pfloor \\
function floor(n) : floor = pfloor(n,1) : end function
'primitive ceil
'+pceil(numeric, numeric) :: valid_arguments, iif \\
function pceil(n,d) : call valid_arguments("pceil",array(n,d), array("numeric", "numeric")) : pceil = iif(n<fix(n),fix(n/d)*d,(fix(n/d)+1)*d) : end function : 
'+ceil(numeric) :: pceil \\
function ceil(n) : ceil = pceil(n,1) : end function
'+sstep(numeric) :: hcstep \simple step function, sstep(0) = 1.0 \
function sstep(n) : sstep = hcstep(1.0,n) : end function
'+ustep(numeric) :: hcstep \unit step function, ustep(0) = 0.0 \
function ustep(n) : ustep = hcstep(0.0,n) : end function
'+hstep(numeric) :: hcstep \Heaviside step function, hstep(0) = 0.5 \
function hstep(n) : hstep = hcstep(0.5,n) : end function
'+hcstep(numeric) :: sustep \Heaviside(0) step function\
function hcstep(z,n) : hcstep = sustep(0.0,z,n) : end function
'primitive *step
'+sustep(numeric, numeric, numeric) :: valid_arguments \shift unit step function\
function sustep(t, z, n) : call valid_arguments("sustep",array(t,z,n),array("numeric","numeric","numeric")) : if n>t then : sustep = 1.0 : else : if n<t then : sustep = 0.0 : else : sustep = z : end if : end if : end function
'+tarai(numeric, numeric, numeric) :: \Takenaka function, do arguments check before use\
function tarai(x,y,z) : if (x<=y) then : tarai = y : else : tarai = tarai(tarai(x-1,y,z),tarai(y-1,z,x),tarai(z-1,x,y)) : end if : end function
'+tak(numeric, numeric, numeric) :: \John McCarthy function, do arguments check before use\
function tak(x,y,z) : if (x<=y) then : tak = z : else : tak = tak(tak(x-1,y,z),tak(y-1,z,x),tak(z-1,x,y)) : end if : end function
'--
'+max(numeric, numeric) :: valid_arguments, iif \\
function max(v,r) : call valid_arguments("max",array(v,r),array("numeric","numeric")) : max = iif(v > r, v ,r) : end function
'+min(numeric, numeric) :: valid_arguments, iif \\
function min(v,r) : call valid_arguments("min",array(v,r),array("numeric","numeric")) : min = iif(v < r, v ,r) : end function
'+max_array(array) :: NEGATIVE_INFINITY, valid_arguments, max \search max number in array, not allowed string\
function max_inarray(a) : dim b,r : r = NEGATIVE_INFINITY : call valid_arguments("max_inarray",array(a),array("array")) : for each b in a : if isnumeric(b) then : r = max(r,b) : end if : next : max_inarray = r : end function
'+min_inarray(array) :: POSITIVE_INFINITY, valid_arguments, min \search min number in array, not allowed string\
function min_inarray(a) : dim b,r : r = POSITIVE_INFINITY : call valid_arguments("min_inarray",array(a),array("array")) : for each b in a : if isnumeric(b) then : r = min(r,b) : end if : next : min_inarray = r : end function
'+roundup(numeric,numeric) :: valid_arguments \\
function roundup(n,d) : call valid_arguments("roundup",array(n,d),array("numeric","numeric")) : roundup = round(n + 0.1^(d+1)*5, d) : end function
'+rounddown(numeric,numeric) :: valid_arguments \\
function rounddown(n,d) : call valid_arguments("rounddwon",array(n,d),array("numeric","numeric")) : rounddown = round(n - 0.1^(d+1)*5, d) : end function
'--
'sec(numeric) :: \secont\
function sec(x) : sec = 1/cos(x) : end function
'csc(numeric) :: \cosecont\
function csc(x) : csc = 1/sin(x) : end function
'cot(numeric) :: \cotangent\
function cot(x) : cot = 1/tan(x) : end function
'asin(numeric) :: MATH_PI \arc sine -1<=x<=1 \
function asin(x) : if abs(x)=1 then : asin = sgn(x)*MATH_PI/2.0 : else : asin = atn(x/sqr(-x*x+1)) : end if : end function
'acos(numeric) :: MATH_PI \arc cosine -1<=x<=1 \
function acos(x) : if abs(x)=1 then : acos = sgn(x)*MATH_PI/2.0+MATH_PI/2.0 : else : acos = atn(-x/sqr(-x*x+1))+2*atn(1) : end if : end function
'atan(numeric) :: \arc tangent\
function atan(x) : atan = atn(x) : end function
'asec(numeric) :: \arc secont\
function asec(x) : asec = 2*atn(1)-atn(sgn(x)/sqr(x*x-1)) : end function
'acsc(numeric) :: \arc cosecont\
function acsc(x) : acsc = atn(sgn(x)/sqr(x*x-1)) : end function
'acot(numeric) :: \arc cotangent\
function acot(x) : acot = 2*atn(1)-atn(x): end function
'sinh(numeric) :: \hyperbolic sine\
function sinh(x) : sinh = (exp(x)-exp(-x))/2 : end function
'cosh(numeric) :: \hyperbolic cosine\
function cosh(x) : conh = (exp(x)+exp(-x))/2 : end function
'tanh(numeric) :: sinh, conh \hyperbolic tangent\
function tanh(x) : tanh = sinh(x)/conh(x) : end function
'coth(numeric) :: tanh \hyperboric cotangent\
function coth(x) : coth = 1/tanh(x) : end function
'sech(numeric) :: cosh \hyperbolic secont\
function sech(x) : sech = 1/cosh(x) : end function
'csch(numeric) :: sinh \hyerbolic cosecont\
function csch(x) : csch = 1/sinh(x) : end function
'--
'logn(numeric, numeric) :: valid_arguments \ n=x=1 => undefined. \
function logn(n,x) : call valid_arguments("logn",array(n,x),array("numeric","numeric")) : logn = log(x)/log(n) : end function
'log2(x) :: logn \\
function log2(x) : log2 = logn(2,x) : end function
'log10(x) :: logn \\
function log10(x) : log10 = logn(10,x) : end function

'# bit calculation #
'?nor(boolean, boolean) :: isboolean \\
function nor(a,b) : nor = false : if isboolean(a) and isboolean(b) then : nor = not(a or b) : end if : end function
'?b_nor(boolean, boolean) :: nor \\
function b_nor(a,b) : b_nor = nor(a,b) : end function
'?b_not(boolean) :: nor \\
function b_not(a) : b_not = b_nor(a,a) : end function
'?b_and(boolean, boolean) :: nor \\
function b_and(a,b) : b_and = b_nor(b_not(a),b_not(b)) : end function
'?b_or(boolean, boolean) :: nor \\
function b_or(a,b) : b_or = b_not(b_nor(a,b)) : end function
'?b_nand(boolean, boolean) :: nor \\
function b_nand(a,b) : b_nand = b_not(b_and(a,b)) : end function
'?b_xor(boolean, boolean) :: nor \\
function b_xor(a,b) : b_xor = b_or(b_and(b_not(a),b),b_and(a,b_not(b))) : end function
'?b_xnor(boolean, boolean) :: nor \\
function b_xnor(a,b) : b_xnor = b_or(b_and(a,b),b_and(b_not(a),b_not(b))) : end function
'?b_tf(numeric) :: iif \1 returns true else false\
function b_tf(n) : call valid_arguments("b_tf",array(n),array("numeric")) : b_tf = iif(n=1, true, false) : end function
'+b_sl(numeric, integer) :: \arithmetic shift left\
function b_sl(n,k) : call valid_arguments("b_sl",array(n,k),array("numeric","integer")) : b_sl = n*2^k : end function
'+b_sr(numeric, integer) :: \arithmetic shift right\
function b_sr(n,k) : call valid_arguments("b_sr",array(n,k),array("numeric","integer")) : b_sr = n/2^k : end function
'+b_lsl(numeric, integer) :: b_b2n, b_n2b \logical shift left\
function b_lsl(n,k) : call valid_arguments("b_lsl",array(n,k),array("numeric","integer")) : b_lsl = b_b2n(right(b_n2b(n)&string(k,"0"),32)) : end function
'+b_lsr(numeric, integer) :: b_b2n, b_n2b \logical shift right\
function b_lsr(n,k) : call valid_arguments("b_lsl",array(n,k),array("numeric","integer")) : b_lsr = b_b2n(left(string(k,"0")&b_n2b(n),32)) : end function
'--
'+b_n2b(numeric) :: valid_arguments, iif, \number to binary string, no operation with over long range.\
function b_n2b(n) : dim i,s,b : s = "" : call valid_arguments("b_n2b",array(n),array("numeric")) : b = sgn(n)*n : s = iif((sgn(n) = 1),"0","1") : for i=30 to 0 step -1 : if fix(b / 2^i) > 0 then : s = s & "1" : b = b - 2^i : else : s = s & "0" : end if : next : b_n2b = s : end function
'+b_b2n(string) :: valid_arguments, iif, dleft, rmatch \binary string to number, no operation with not binary string.\
function b_b2n(b) : dim c,a,s,i : a = 0 : call valid_arguments("b_b2n",array(b),array("string")) : c = right(string(32,"0")&b,32) : s = iif(left(c,1)=0,1,-1) : c = dleft(c,1) : if rmatch(b,"^[01][01]*$") then : for i=30 to 0 step -1 : a = a+2^i*left(c,1) : c = dleft(c,1) : next : end if : b_b2n = s*a : end function
'+b_print(string) :: valid_arguments, dright \string has always has 32 digit\
function b_print(b) : dim i,c,s : i=1 : s = "" : call valid_arguments("b_print", array(b), array("string")) : for each c in s2a(b,1) : s=s&c : if i mod 4 = 0 then : s=s&" " : end if : i = i+1 : next : b_print = dright(s,1) : end function

'# utilities #
'# system #
'quit(numeric) :: valid_arguments \\
function quit(n) : call valid_arguments("quit",array(n),array("numeric")) : flog("(quit) "&n&"") : wscript.quit(n) : end function
'halt() :: flog, errmsg \\
function halt() : flog("(halt) halted ["&errmsg(err)&"]") : end function
'--
'+eventlog(integer, string) :: valid_arguments, isinarray, FUNCTION_EVENTLOG_, cerr, ashell, ERR_FUNCTION_EVENTLOG \returns write string length, (eventid, string) write to application event log. source by 'WSH'. this function is sub-procedure.\
function eventlog(t,s) : call valid_arguments("eventlog",array(t,s),array("integer","string")) : if not isinarray(array(FUNCTION_EVENTLOG_SUCCESS,FUNCTION_EVENTLOG_ERROR,FUNCTION_EVENTLOG_WARNING,FUNCTION_EVENTLOG_INFORMATION,FUNCTION_EVENTLOG_AUDIT_SUCCESS,FUNCTION_EVENTLOG_AUDIT_FAILURE),t) then : cerr("(eventlog) invalid type '"&t&"', can't allocate eventid.") : err.raise ERR_FUNCTION_EVENTLOG, "invalid type '"&t&"', can't allocate eventid.", "ERR_FUNCTION_EVENTLOG" : else : ashell.logevent t, s : eventlog = flog("(eventlog) write to application eventlog. ['"&t&"', "&s&"]") : end if : end function
'+e_error(string) :: eecho, eventlog \write eventlog with echo\
function e_error(s) : eecho(s) : e_error = eventlog(FUNCTION_EVENTLOG_ERROR, s) : end function
'+e_warn(string) :: wecho, eventlog \write eventlog with echo\
function e_warn(s) : wecho(s) : e_warn = eventlog(FUNCTION_EVENTLOG_WARNING, s) : end function
'+e_info(string) :: iecho, eventlog \write eventlog with echo\
function e_info(s) : iecho(s) : e_info = eventlog(FUNCTION_EVENTLOG_INFORMATION, s) : end function
'+errmsg() :: \use in detected error directive.\
function errmsg() : errmsg = "[ "&err.number&", "&err.description&", "&err.source&" ]" : end function

'# path #
'?isvalidpath(string) :: valid_arguments, dleft, absolutepath, iif, rmatch \is valid path string\
function isvalidpath(s) : dim b : call valid_arguments("isvalidpath",array(s),array("string")) : b = dleft(absolutepath(s),3) : isvalidpath = iif(rmatch(b,"[:/\*\|\?<>""]"),false,true) : end function
'?mkdir(string) :: valid_arguments, absolutepath, isvalidpath, cerr, ef, parentfolder, afso \(path_string), absolutepath marumeru \
function mkdir(s) : dim b : call valid_arguments("mkdir",array(s),array("string")) : b = absolutepath(s) : if not isvalidpath(s) then : cerr("(mkdir) found invalid string in '"&b&"', can't create folder.") : mkdir = false : exit function : end if : if not ef(parentfolder(b)) then : call mkdir(parentfolder(b)) : end if : if not ef(b) then : afso.createfolder(b) : end if : mkdir = ef(absolutepath(s)) : end function
'+basename(value/file/folder) :: valid_arguments, afso \\
function basename(s) : call valid_arguments("basename",array(s),array("value/file/folder")) : basename = afso.getbasename(s) : end function
'+filename(value/file/folder) :: valid_arguments, afso \\
function filename(v) : call valid_arguments("filename",array(v),array("value/file/folder")) : filename = afso.getfilename(v) : end function
'+absolutepath(value/file/folder) :: valid_arguments, afso \\
function absolutepath(v) : call valid_arguments("absolutepath",array(v),array("value/file/folder")) : absolutepath = afso.getabsolutepathname(v) : end function
'+extension(value/file/folder) :: valid_arguments, afso \\
function extension(v) : call valid_arguments("extension",array(v),array("value/file/folder")) : extension = afso.getextensionname(v) : end function
'+parentfolder(value/file/folder) :: valid_arguments, afso \\
function parentfolder(v) : call valid_arguments("parentfolder",array(v),array("value/file/folder")) : parentfolder = afso.getparentfoldername(v) : end function
'+drivename(value/file/folder) :: valid_arguments, afso \\
function drivename(v) : call valid_arguments("drivename",array(v),array("value/file/folder")) : drivename = afso.getdrivename(v) : end function
'+buildpath(value/file/folder,value/file/folder) :: valid_arguments, afso \\
function buildpath(v,s) : call valid_arguments("buildpath",array(v,s),array("value/file/folder","value/file/folder")) : buildpath = afso.buildpath(v,s) : end function
'+scriptname() :: \\
function scriptname() : scriptname = replace(wscript.scriptname,"."&extension(wscript.scriptname),"") : end function

'# random #
'+rndstr(integer) :: valid_arguments, rand \returns random string using char(48-56, 65-90, 97-122)\
function rndstr(n) : dim b,i : b = "" : call valid_arguments("rndstr",array(n),array("integer")) : i = n : randomize(timer) : do while i>0 : select case rand(1,3) : case 1 : b = b&chr(rand(48,56)) : case 2 : b = b&chr(rand(65,90)) : case else : b = b&chr(rand(97,122)) : end select : i=i-1 : loop : rndstr = b : end function
'+rndstrn(integer) :: valid_arguments, rand \returns random string using char(32-126)\
function rndstrn(n) : dim b,i : b = "" : call valid_arguments("rndstrn",array(n),array("integer")) : i = n : randomize(timer) : do while i>0 : b = b&chr(rand(32,126)) : i = i-1 : loop : rndstrn = b : end function
'+rndstrm(integer) :: valid_arguments, rand \returns random string using 2nd argument\
function rndstrm(n,s) : dim b,i,j : b = "" : call valid_arguments("rndstrm",array(n,s),array("integer","string")) : i = n : j = cint(len(s)) : randomize(timer) : do while i>0 : b = b&mid(rand(1,j),1) : i=i-1 : loop : rndstrm = b : end function
'+rand(integer,integer) :: valid_arguments \ (n <= m) \
function rand(n,m) : call valid_arguments("rand",array(n,m),array("integer","integer")) : randomize(timer) : rand = int((m-n+1)*rnd()+n) : end function

'# foreach #
'+foreach_rreplace(array, string, string) :: valid_arguments, push, rreplace \(targets, target, replacement)\
function foreach_rreplace(a, s, t) : dim b, r : r = array() : call valid_arguments("foreach_rreplace",array(a,s,t),array("array","string","string")) : for each b in a : call push(r, rreplace(b, s, t)) : next : foreach_rreplace = r : end function : 
'+foreach_rremove(array, string) : valid_arguments, halt, push, rremove\(targets, removement)\
function foreach_rremove(a, s) : dim b, r : r = array() : call valid_arguments("foreach_rremove",array(a,s),array("array","string")) : for each b in a : call push(r, rremove(b, s)) : next : foreach_rremove = r : end function
'+foreach_typename(array) :: valid_arguments, push, a2s \\
function foreach_typename(a) : dim b,r : r = array : call valid_arguments("foreach_typename", array(a), array("array")) : for each b in a : call push(r, typename(b)) : next : foreach_typename = a2s(r, ", ") : end function

'# skelmisc #
'+skelconfigname() :: eau, aan, ef, buildpath, FUNCTION_SKELCONFIGNAME_CONFDIR, cerr, ERR_FUNCTION_SKELCONFIGNAME, afso \return default configname. if you want another config, use /config option.\
function skelconfigname() : dim b : if eau("config") then : b = aan("config") : else : if ef(FUNCTOIN_FLOG_LOGDIR) then : b = buildpath(FUNCTOIN_SKELCONFIGNAME_CONFDIR,scriptname&".conf") : else : b = scriptname&".conf" : end if : end if : if not e(b) then : cerr("(skelconfigname) '"&b&"' is missing.") : err.raise ERR_FUNCTION_SKELCONFIGNAME, "'"&b&"' is missing.", "ERR_FUNCTION_SKELCONFIGNAME" : end if : set skelconfigname = afso.getfile(b) : end function
'*setconfig(file/string) :: valid_arguments, e, cerr, ERR_FUNCTION_SETCONFIG, adic, iif, ea, aan, fcleanup, rmatch, getsubmatch, dic, skeltypecast, ed, dic, push \read config. see example(conf\skel.configure)\
function setconfig(c) : dim b,d,v,flg : flg = 0 : dim tag_start, tag_end : call valid_arguments("setconfig",array(c),array("file/string")) : if not e(c) then : cerr("(setconfig) '"&c&"' is missing") : err.raise ERR_FUNCTION_SETCONFIG, "'"&c&"' is missing", "ERR_FUNCTION_SETCONFIG" : end if : set d = adic() : tag_start = "^<conf(igure)*"&iif(ea("configid"),"\s\s*id\s*=\s*""*"&aan("configid")&"""*\s*","")&">" : tag_end = "^</conf(igure)*"&iif(ea("configid"),"\s\s*id\s*=\s*""*"&aan("configid")&"""*\s*","")&">" : for each b in fcleanup(c) : if rmatch(b,tag_start) then : flg=flg+1 : end if : if rmatch(b,tag_end) then : flg=flg+1 : end if : if flg=1 and rmatch(b,"^\s*(""*[a-zA-Z][a-zA-Z0-9\._]*""*)\s*=\s*(.*)\s*$") then : set v = getsubmatch(b,"^\s*(""*[a-zA-Z][a-zA-Z0-9\._]*""*)\s*=\s*(.*)\s*$") : if len(v(0))>0 and len(v(1))>0 then : call dic(d,v(0), iif(ea("notypecast"), v(1), skeltypecast(v(1))) ) : end if : end if : next : if not ed(d,"_readconfigs") then : call dic(d,"_readconfigs",array()) : end if : d("_readconfigs") = push(d("_readconfigs"),c) : set setconfig = d : end function
'-skeltypecast(string) :: valid_arguments, rmatch, rremove, rmatchi, dictionary \use in setconfig()\
function skeltypecast(s) : call valid_arguments("skeltypecast",array(s),array("string")) : if rmatch(s,"^"".*""$") then : skeltypecast = rremove(s,"(^"")|(""$)") : else : if rmatchi(s,"true|false") then : skeltypecast = cbool(s) : exit function : end if : if rmatch(s,"^%arr(ay)*%") then : skeltypecast = split(rremove(s,"^%arr(ay)*%\(|\)$"),",") : exit function : end if : if rmatch(s,"^%dic(tionary)*%") then : set skeltypecast = dictionary(rremove(s,"^%dic(tionary)*%")) : exit function : end if : if rmatch(s,"^#[0-9/:][0-9/:]*#$") then : skeltypecast = cdate(rremove(s,"(^#)|(#$)")) : exit function : end if : if isnumeric(s) then : skeltypecast = eval(s) : else : skeltypecast = s : end if : end if : end function : 
'*skelconfig() :: setconfig, skelconfigname, dic, skelversion, datetime1, flogname, FUNCTION_FLOG_TYPENAME, FUNCTION_DATETIME_TYPENAME \\
function skelconfig() : dim b : set b = setconfig(skelconfigname()) : call dic(b,"_skelverion",skelversion()) : call dic(b,"_startdate",datetime1()) : call dic(b,"_logname",flogname()) : call dic(b,"_logtype",FUNCTION_FLOG_TYPENAME) : call dic(b,"_datetimetype",FUNCTION_DATETIME_TYPENAME) : set skelconfig = b : end function
'+skelversion() :: 
function skelversion() : on error resume next : skelversion = skelv : if err.number <> 0 then : skelversion = "undefined" : err.clear : end if : end function
'--
'+configure_xml() :: adic, iif, eau, aan, basename, e, ef, buildpath, xml, echo,cerr, FUNCTION_CONFIGURE_SET_EMPTY, rmatch, dic, cast, push, skelversion, datetime1, flogname, FUNCTION_FLOG_TYPENAME, FUNCTION_DATETIME_TYPENAME
function configure_xml() : dim d, fn,oxml,param,i,a,name, elem, num : num = 0 : set d = adic() : fn = iif(eau("config"),aan("config"),basename(wscript.scriptname)&".config.xml") : if not e(fn) and ef("conf") then : fn = iif(e(buildpath("conf",basename(wscript.scriptname)&".config.xml")),buildpath("conf",basename(wscript.scriptname)&".config.xml"),fn) : end if : set oxml = fxml(fn) : echo("(configure_xml) detect "&oxml.documentElement.getElementsByTagName("param").length&" parameters.") : for each param in oxml.documentElement.selectNodes("/configure/param") : set name = param.getElementsByTagName("name") : set elem = param.getElementsByTagName("element") : if name.length<1 then : cerr("(configure_xml) invalid 'param' ("&num&": undefined 'name'), skipped.") : else : if elem.length<1 then : cerr("(configure_xml) invalid 'param' ("&num&": undefined 'element'), skipped.") : else : if not elem(0).haschildnodes then : if isnull(elem(0).getattribute("type")) then : if FUNCTION_CONFIGURE_SET_EMPTY then : call dic(d, name(0).text, empty) : else : cerr("(configure_xml) detect empty 'element' ("&num&": has no 'value'), skipped.") : end if : else : if FUNCTION_CONFIGURE_SET_EMPTY then : if rmatch(elem(0).getattribute("type"),"(dic|dictionary)") then : call dic(d, name(0).text, adic()) : end if : if rmatch(elem(0).getattribute("type"),"(arr|array)") then : call dic(d, name(0).text, array()) : end if : else : cerr("(configure_xml) detect empty 'element' ("&num&": has no 'value'), skipped.") : end if : end if : else : if isnull(elem(0).getattribute("type")) then : if elem(0).childnodes.length>1 then : cerr("(configure_xml) invalid 'value' ("&num&": has multiple 'value', only allowed in 'type': array/dictionary), skipped.") : else : call dic(d, name(0).text, cast(elem(0).childnodes(0).text, elem(0).childnodes(0).getattribute("type"))) : end if : else : if rmatch(elem(0).getattribute("type"),"(arr|array)") then : a = array() : for i=0 to elem(0).childnodes.length-1 : if rmatch(elem(0).childnodes(i).getattribute("type"),"(arr|array|dic|dictionary)") then : cerr("(configure_xml) invalid 'value,type' ("&num&","&i&": not allowed '"&elem(0).childnodes(i).getattribute("type")&"' yet), skipped.") : else : call push(a, cast(elem(0).childnodes(i).text, elem(0).childnodes(i).getattribute("type"))) : end if : next : call dic(d, name(0).text, a) : end if : if rmatch(elem(0).getattribute("type"),"(dic|dictionary)") then : set a = adic() : for i=0 to elem(0).childnodes.length-1 : if rmatch(elem(0).childnodes(i).getattribute("type"),"(arr|array|dic|dictionary)") then : cerr("(configure_xml) invalid 'value,type' ("&num&","&i&": not allowed '"&elem(0).childnodes(i).getattribute("type")&"' yet), skipped.") : else : if isnull(elem(0).childnodes(i).getattribute("key")) then : cerr("(configure_xml) invalid value ("&num&","&i&": not allowed null 'key'), skipped.") : else : call dic(a, elem(0).childnodes(i).getattribute("key"), cast(elem(0).childnodes(i).text, elem(0).childnodes(i).getattribute("type"))) : end if : end if : next : call dic(d, name(0).text, a) : end if : if not rmatch(elem(0).getattribute("type"),"(dic|dictionary|arr|array)") then : cerr("(configure_xml) not support '"&elem(0).getattribute("type")&"' has multiple 'value', skipped.") : end if : end if : end if : end if : end if : num = num+1 : next : call dic(d,"_skelverion",skelversion()) : call dic(d,"_configure",fn) : call dic(d,"_startdate",datetime1()) : call dic(d,"_logname",flogname()) : call dic(d,"_logtype",FUNCTION_FLOG_TYPENAME) : call dic(d,"_datetimetype",FUNCTION_DATETIME_TYPENAME) : set configure_xml = d : end function : 

'e.g. property_dictionary has {from=>string, to=>array/string, cc=>array/string, bcc=>array/string,
'     subject=>string, htmlbody=>string, textbody=>string, bodypart.charset=>string, attachment=>array/file/string }
'*mkmail(dictionary) :: valid_arguments, amail, cerr, iif, env, ed, anet, e, absolutepath, bind \returns mail object with property\
function mkmail(p) : dim a,b : call valid_arguments("mkmail",array(p),array("dictionary")) : set mkmail = amail() : if isnothing(mkmail) then : cerr("(mkmail) can't create mail with property.") : exit function : end if : mkmail.from = iif(len(p("from"))>0,p("from"),lcase(env("%USERNAME%@%USERDNSDOMAIN%"))) : mkmail.subject = iif(ed(p,"subject"),p("subject"),"send from "&anet.computername&" <"&wscript.scriptfullname&">") : mkmail.htmlbody = p("htmlbody") : mkmail.htmlbody = p("textbody") : mkmail.htmlbody = p("bodypart.charset") : if isarray(p("to")) then : mkmail.to = join(p("to"),",") : else : mkmail.to = p("to") : end if : if isarray(p("cc")) then : mkmail.cc = join(p("cc"),",") : else : mkmail.cc = p("cc") : end if : if isarray(p("bcc")) then : mkmail.bcc = join(p("bcc"),",") : else : mkmail.bcc = p("bcc") : end if : if not isarray(p("attachment")) then : a = array(p("attachment")) : else : a = p("attachment") : end if : for each b in a : if not isempty(b) then : if e(absolutepath(b)) then : mkmail.addattachment(absolutepath(b)) : end if : end if : next : end function
'e.g. send_mail("from@mail.addr", "to@mail.addr", "cc@mail.addr", "subject", "mail body", null, "smtpserver", 25, 1000)
'*send_mail(string,string,string,string,string,string/file/null,string,numeric,numeric) :: valid_arguments, adic, dic, pmailer \for backward compatibility. do not use.\
function send_mail(addr_from, addr_to, addr_cc, subject, body, attachment, smtpsvr, smtpport, timeout) : dim d : call valid_arguments("send_mail",array(addr_from, addr_to, addr_cc, subject, body, attachment, smtpsvr, smtpport, timeout),array("string", "string", "string", "string", "string", "string/file/null", "string", "numeric", "numeric")) : set d = adic() : call dic(d,"from",""""&addr_from&"""") : call dic(d,"to",addr_to) : call dic(d,"cc",addr_cc) : call dic(d,"subject",subject) : call dic(d,"textbody",body) : if not isnull(attachment) then : if isempty(attachment) then : call dic(d,"attachment","") : else : call dic(d,"attachment",attachment) : end if : end if : set send_mail = pmailer(mkmail(d), 2, smtpsvr, smtpport, timeout, false, 1, "", "") : end function
'+sendmail(string,string,string,string,string,string/file/null,string,numeric,numeric) :: send_mail, errmsg \if you set FUNCTION_SEND_MAIL_ALWAYS_SEND to true, replace send_mail() to sendmail(), returns err.number as result. \
function sendmail(addr_from, addr_to, addr_cc, subject, body, attachment, smtpsvr, smtpport, timeout) : on error resume next : send_mail(addr_from, addr_to, addr_cc, subject, body, attachment, smtpsvr, smtpport, timeout).send() : if err.number <> 0 then : cerr("(sendmail) can't send mail. "&errmsg(err)) : end if : sendmail = err.number : end function
'*mailer(imessage_object, string, string) :: valid_arguments, pmailer \returns mail object, if you want to send a mail, use .send() method or use sendmail() \
function mailer(mail, svr, prt) : call valid_arguments("mailer",array(mail, svr, prt),array("mail","string","string")) : set mailer = pmailer(mail, 2, svr, prt, 1000, false, 1, "", "") : end function
'primitive mailer
'*pmailer(mail, string, string, numeric, numeric, string, string, string, string) :: valid_arguments, cerr, FUNCTION_PMAILER_SCHEMA \returns mail object\
function pmailer(mail, su, svr, prt, tmout, ssl, auth, name, pswd) : dim schema : call valid_arguments("pmailer",array(mail, su, svr, prt, tmout, ssl, auth, name, pswd),array("mail", "string", "string", "numeric", "numeric", "string", "string", "string", "string")) : schema = FUNCTION_PMAILER_SCHEMA : mail.configuration.fields.item(schema&"/sendusing") = su : mail.configuration.fields.item(schema&"/smtpserver") = svr : mail.configuration.fields.item(schema&"/smtpserverport") = prt : mail.configuration.fields.item(schema&"/smtpconnectiontimeout") = tmout : mail.configuration.fields.item(schema&"/smtpusessl") = ssl : mail.configuration.fields.item(schema&"/smtpauthenticate") = auth : mail.configuration.fields.item(schema&"/sendusername") = name : mail.configuration.fields.item(schema&"/sendpassword") = pswd : mail.configuration.fields.update() : if err.number <> 0 then : cerr("(pmailer) set configuration error.") : set pmailer = nothing : err.clear : exit function : end if : set pmailer = mail : end function
'--
'+sleep(n) :: \(second), returns empty. sec sleep.\
function sleep(n) : sleep = usleep(n*1000) : end function
'+usleep(n) :: \(milisecond), returns empty. ms sleep\
function usleep(n) : usleep = wscript.sleep(n) : end function
'+newcmd() :: rndstr, ashell, flog, usleep, FUNCTION_NEWCMD_WAITTIME \returns window-title string.\
function newcmd() : dim t : t = rndstr(10) : ashell.run "cmd /C start """&t&"""", 2, false : flog("(newcmd) new cmd, windowname("&t&")") : newcmd = t : usleep(FUNCTION_NEWCMD_WAITTIME) : end function
'?cmdkeys(string/integer/long, array) :: valid_arguments, cmdkey \(window_title/processid, command_array())\
function cmdkeys(t,a) : dim b : call valid_arguments("cmdkeys",array(t,a),array("string/integer/long","array")) : for each b in a : if not cmdkey(t,b) then : cmdkeys = false : exit function : end if : next : cmdkeys = true : end function
'?cmdkey(string/integer/long,string) :: valid_arguments, ashell, exec, cerr, flog, \\
function cmdkey(p,s) : dim a ,b : call valid_arguments("cmdkey",array(p,s),array("string/integer/long","string")) : set a = ashell() : if isnumeric(p) then : b = pexec("cmd /c tasklist /fo:csv /nh /fi ""pid eq "&p&" | findstr "&p).stdout.readall : else : b = pexec("cmd /c tasklist /fo:csv /nh /v | findstr "&p).stdout.readall : end if : if not len(b)>0 then : cerr("(cmdkey) can't found process/windows ["&p&"], command ["&s&"] is abort.") : cmdkey = false : exit function : end if : flog(b) : do until a.appactivate(p) : exit do : loop : a.sendkeys(s&"~") : usleep(FUNCTION_CMDKEY_WAITTIME) : cmdkey = true : end function
'+selectfolder() :: app, cerr, ERR_FUNCTION_SELECTFOLDER\if canceled selection, script abort.\
function selectfolder() : dim b : set b = aapp.browseforfolder(0,"select a folder", 0) : if isnothing(b) then : cerr("(selectfolder) canceled. abort.") : err.raise ERR_FUNCTION_SELECTFOLDER, "canceled. abort.", "ERR_FUNCTION_SELECTFOLDER" : else : selectfolder = b.items.item.path : end if : end function : 
'+tee(string) :: valid_arguments, cout, flog \output console and log.\
function tee(s) : call valid_arguments("tee",array(s),array("string")) : cout(s) : tee = flog(s) : end function
'+ftee(string/file) :: valid_arguments, cout, fwrite \output console and file.\
function ftee(f,s) : call valid_arguments("ftee",array(f,s),array("string/file","string")) : cout(s) : call fwrite(f).writeline(s) : ftee = len(s) : end function
'shellpopup(value,integer/long,string,integer) :: valid_arguments, ashell \(string, closetime, title, typeint)\
function shellpopup(str,tm,title,typ) : call valid_arguments("shellpopup",array(str,tm,title,typ),array("value","integer/long","string","integer")) : shellpopup = ashell.popup(str, tm, title, typ) : end function

'# datetime #
'+datetime() :: FUNCTION_DATETIME_TYPENAME \speed rank = datetime2 >> datetime1 > datetime0\
function datetime() :: datetime = getref(FUNCTION_DATETIME_TYPENAME) : end function
'+datetime0() :: yndHMS, datetime \2016/01/29 18:18:10.123 => 160129181810\
function datetime0() : datetime0 = right(yndHMS("yyyynnddHHMMSS"),12) : end function
'+datetime1() :: datetime \2016/01/29 18:18:10.123 => 2016/01/29 18:18:10.12\
function datetime1() : datetime1 = now()&"."&right(fix(timer*100.0),2) : end function
'+datetime2() :: datetime \2016/01/29 18:18:10.123 => 2016/01/29 18:18:10\
function datetime2() : datetime2 = now() : end function
'+datetime3() :: datetime, yndHMS \2016/01/29 18:18:10.123 => 20160129181810\
function datetime3() : datetime3 = yndHMS("yyyynnddHHMMSS") : end function

'unixtimenow() :: unixtime \\
function unixtimenow() : unixtimenow = unixtime(now) : end function
'unixtime(date) :: valid_arguments, FUNCTIONS_UNIXTIME_BASIS \returns unixtime\
function unixtime(d) : call valid_arguments("unixtime",array(d),array("date")) : unixtime = datediff("s",FUNCTIONS_UNIXTIME_BASIS,d) : end function : 
'unix2date(numeric) :: valid_arguments, FUNCTIONS_UNIXTIME_BASIS \\
function unix2date(d) : call valid_arguments("unix2date",array(d),array("numeric")) : unix2date = dateadd("s", d, FUNCTIONS_UNIXTIME_BASIS) : end function
'--
'e.g. "2 years later" => 2018/02/01 18:18:00
'+date_natural(s) :: pdate_natural \returns natural-selection date from now() \
function date_natural(s) : date_natural = pdate_natural(s,now()) : end function
'+pdate_natural(string, date) :: valid_arguments, rmatch, getsubmatch, date_unit, cerr \if not matched, return empty.\
function pdate_natural(s,d) : dim m, op : call valid_arguments("pdate_natural",array(s,d),array("string","date")) : if rmatch(s,"^\s*(-*\d\d*)\s*(years*|months*|days*|hours*|min(uite)*s*|sec(ond)*s*)\s*(later|before|after|ago)\s*$") then : set m = getsubmatch(s,"^\s*(-*\d\d*)\s*(years*|months*|days*|hours*|min(uite)*s*|sec(ond)*s*)\s*(later|after|ago|before)\s*$") : set op = date_unit() : pdate_natural = dateadd(op(m(1)),op(m(4)) * m(0),d) : else : cerr("(pdate_natural) '"&s&"' is not matched pattern. (e.g. ""2 years later"")") : end if : end function
'e.g. date_element("10 days after") = dictionary({unit=>, number=>, flg=>})
'*date_element(string) :: valid_arguments, adic, rmatch, getsubmatch, date_unit, dic \return dictionary, {unit=>, number=>, flg=>}\
function date_element(s) : dim d,m,op : call valid_arguments("date_element",array(s),array("string")) : set d = adic() : if rmatch(s,"^\s*(-*\d\d*)\s*(years*|months*|days*|hours*|min(uite)*s*|sec(ond)*s*)\s*(later|before|after|ago)\s*$") then : set m = getsubmatch(s,"^\s*(-*\d\d*)\s*(years*|months*|days*|hours*|min(uite)*s*|sec(ond)*s*)\s*(later|before|after|ago)\s*$") : set op = date_unit() : call dic(d,"unit",op(m(1))) : call dic(d,"number",m(0)) : call dic(d,"flag",op(m(4))) : end if : set date_element = d : end function : 
'*date_unit() :: dictionary \return date-unit dictionary. (for pdate_natural and date_natural)\
function date_unit() : set date_unit = dictionary("{y => yyyy, m => m, d => d, H => h, M => n, S => s, year => yyyy, years => yyyy, month => m, months => m, day => d, days => d, hour => h, hours => h, min => n, minute => n, mins => n, minutes => n, sec => s, second => s, secs => s, seconds => s, later => 1, ago => -1, after => 1, before => -1}") : end function
'e.g. "2 days ago" => (2016/02/02 11:11:11, 2016/02/01 11:11:11)
'+date_list(string) :: pdate_list \returns array of the date from now that specified in natural language\
function date_list(s) : date_list = pdate_list(s,now()) : end function 
'+pdate_list(string, date) :: valid_arguments, date_element, push \\
function pdate_list(s,d) : dim i,u,a : a = array() : call valid_arguments("pdate_list",array(s,d),array("string","date")) : set u = date_element(s) : for i=u("flag") to u("number")*u("flag") step u("flag") : call push(a,dateadd(u("unit"),i,d)) : next : pdate_list = a : end function
'--
'primitive ynd()
'+pynd(string, date) :: preplace, dictionary \pattern: yyyy/nn/dd \
function pynd(s,d) : call valid_arguments("pynd",array(s,d),array("string","date")) : pynd = preplace(s,dictionary("{yyyy=>"""&year(d)&""", nn=>"""&right("0"&month(d),2)&""", dd=>"""&right("0"&day(d),2)&"""}")) : end function
'+ynd(string) :: pynd \from now(), pattern: yyyy/nn/dd\
function ynd(s) : ynd = pynd(s,now()) : end function
'primitive yndHMS()
'+pyndHMS(string, date) :: valid_arguments, adic, dic, preplace \pattern: yyyy/nn/dd/HH/MM/SS \
function pyndHMS(s,d) : dim b,p : call valid_arguments("pyndHMS",array(s,d),array("string","date")) : b = s : set p = adic() : call dic(p,"yyyy",year(d)) : call dic(p,"yy",right(year(d),2)) : call dic(p,"nn",right("0"&month(d),2)) : call dic(p,"dd",right("0"&day(d),2)) : call dic(p,"HH",right("0"&hour(d),2)) : call dic(p,"MM",right("0"&minute(d),2)) : call dic(p,"SS",right("0"&second(d),2)) : pyndHMS = preplace(s,p) : end function
'+yndHMS(string) :: pyndHMS \from now(), pattern: yyyy/nn/dd/HH/MM/SS \
function yndHMS(s) : yndHMS = pyndHMS(s,now()) : end function
'+preplace(string, dictionary) :: valid_arguments, \(target, pattern_dictionary) \
function preplace(s,p) : dim b,k : call valid_arguments("preplace",array(s,p),array("string","dictionary")) : b = s : for each k in p : b = replace(b, k, p(k)) : next : preplace = b : end function

'# dictionary #
'?dic(dictionary, value, *) :: valid_arguments, ed \key allow value. but strongly recommend use string.\
function dic(byref d,k,v) : call valid_arguments("dic",array(d,k,v),array("dictionary","value","*")) : if ed(d,k) then : if isobject(v) then : set d(k) = v : else : d(k) = v : end if : else : d.add k, v : end if : dic = true : end function
'*byval_dic(dictionary, value, *) :: valid_arguments, ed, bind \byval_dic returns dictionary.\
function byval_dic(d,k,v) : dim b : call valid_arguments("byval_dic",array(d,k,v),array("dictionary","value","*")) : set b = d : if ed(b,k) then : call bind(b(k),v) : else : b.add k, v : end if : set byval_dic = b : end function
'primitive dicmerge()
'?pdicmerge(dictionary, dictionary, boolean) :: valid_arguments, ed, bind \(merged, source) dicmerge returns true. affect to original dictionary.\
function pdicmerge(byref d,m,f) : dim k : call valid_arguments("pdicmerge",array(d,m,f),array("dictionary","dictionary","boolean")) : for each k in m : if ed(d,k) then : if f then : call bind(d(k),m(k)) : d(k) = m(k) : end if : else : d.add k, m(k) : end if : next : pdicmerge = true : end function
'?dicmerge(dictionary, dictionary) :: pdicmerge \(merged, source) dicmerge returns true. affect to original dictionary. if found same key, overwrite value.\
function dicmerge(byref d,m) : dicmerge = pdicmerge(d, m, true) : end function
'*byval_dicmerge(dictionary, dictionary) :: valid_arguments, ed, bind \(sorce, source). byval_dicmerge resturns merged dictionary.\
function byval_dicmerge(d,m) : dim b,c,k : call valid_arguments("byval_dicmerge",array(d,m),array("dictionary","dictionary")) : set b = d : set c = m : for each k in c : if ed(d,k) then : call bind(b(k), c(k)) : else : b.add k, c(k) : end if : next : set byval_dicmerge = d : end function
'?dicunite(dictionary, dictionary) :: pdicmerge \(merged, source) dicmerge returns true. affect to original dictionary. if found same key, do nothing.\
function dicunite(byref d,m) : dicunite = pdicmerge(d,m,false) : end function
'e.g. dictionary("{1=>2, 2=>true, 3=>"str", }") => dictionary object
'*dictionary(string) :: valid_arguments, adic, rmatch, rremove, dic, btrim, skeltypecast, FUNCTION_DICTIONARY_FORMAT \\
function dictionary(s) : dim a,b,d : call valid_arguments("dictionary",array(s),array("string")) : set d = adic() : if rmatch(s,FUNCTION_DICTIONARY_FORMAT) then : a = split(rremove(s,"^{|}$"),",") : for each b in a : call dic(d,btrim(split(b,"=>")(0)),skeltypecast(trim(split(b,"=>")(1)))) : next : end if : set dictionary = d : end function

'# array #
'e.g. shift <-  array() -> pop
'e.g. unshift -> array() <- push
'+pop(array) :: valid_arguments, bind \(1,2,3) -> (1,2), 3 ,returns value and modified original.\
function pop(a) : call valid_arguments("pop",array(a),array("array")) : if ubound(a)>-1 then : call bind(pop, a(ubound(a))) : redim preserve a(ubound(a)-1) : end if : end function : 
'+byval_pop(array) :: valid_arguments, pop \(1,2,3) -> (1,2,3), 3 ,returns value and not modified original.\
function byval_pop(a) : dim b : call valid_arguments("byval_pop",array(a),array("array")) : b = a : byval_pop = pop(b) : end function
'+shift(array) :: valid_arguments, bind \(1,2,3) -> (2,3), 1 ,returns value and modified original\
function shift(a) : dim i : call valid_arguments("shift",array(a),array("array")) : if ubound(a)>-1 then : call bind(shift,a(0)) : for i=0 to ubound(a)-1 : call bind(a(i),a(i+1)) : next : redim preserve a(ubound(a)-1) : end if : end function
'+byval_shift(array) :: valid_arguments \(1,2,3) -> (1,2,3), 1 ,returns value and modified original\
function byval_shift(a) : call valid_arguments("byval_shift",array(a),array("array")) : if ubound(a)>-1 then : byval_shift = a(0) : end if : end function
'+push(array, *) :: valid_arguments, bind \(1,2) ,3 -> (1,2,3) ,returns array and modified original.\
function push(a,v) : call valid_arguments("push",array(a,v),array("array","*")) : redim preserve a(ubound(a)+1) : call bind(a(ubound(a)),v) : push = a : end function
'+byval_push(array, *) :: valid_arguments, push \(1,2) ,3 -> (1,2,3) ,returns array and not modified original.\
function byval_push(a,v) : dim b : call valid_arguments("byval_push",array(a,v),array("array","*")) : b = a : byval_push = push(b,v) : end function
'+unshift(array, *) :: valid_arguments, bind \(1,2) ,3 -> (3,1,2) ,returns array and modified original.\
function unshift(a,v) : dim i : call valid_arguments("unshift",array(a,v),array("array","*")) : redim preserve a(ubound(a)+1) : for i=ubound(a) to 1 step -1 : call bind(a(i), a(i-1)) : next : call bind(a(0), v) : unshift = a : end function
'+byval_unshift(array, *) :: valid_arguments, unshift \(1,2) ,3 -> (3,1,2) ,returns array and not modified original.\
function byval_unshift(a,v) : dim i,b : call valid_arguments("unshift",array(a,v),array("array","*")) : b = a : byval_unshift = unshift(b,v) : end function
'+popn(array,integer/long) :: valid_arguments, push, pop \modified original\
function popn(a,n) : dim b,i : b = array() : call valid_arguments("popn",array(a,n),array("array","integer/long")) : i = iif(n>0,n,0) : do while i>0 : call push(b,pop(a)) : i=i-1 : loop : popn = b : end function
'+shiftn(array,integer/long) :: valid_arguments, push, pop \modified original\
function shiftn(a,n) : dim b,i : b = array() : call valid_arguments("shiftn",array(a,n),array("array","integer/long")) : i = iif(n>0,n,0) : do while i>0 : call push(b,shift(a)) : i=i-1 : loop : shiftn = b : end function
'+byval_popn(array,integer/long) :: valid_arguments, popn \not modified original\ 
function byval_popn(a,n) : dim b : call valid_arguments("byval_popn",array(a,n),array("array","integer/long")) : b = a : byval_popn = popn(b,n) : end function
'+byval_shiftn(array,integer/long) :: valid_arguments, shiftn \not modified original\
function byval_shiftn(a,n) : dim b : call valid_arguments("byval_shiftn",array(a,n),array("array","integer/long")) : b = a : byval_shiftn = shiftn(b,n) : end function
'+pull(array,integer/long) :: valid_arguments, bind, swap \(target, indicator) indicator starts 0\
function pull(a,n) : dim i : call valid_arguments("pull",array(a,n),array("array","integer/long")) : if ubound(a)<0 then : pull = a : exit function : else : if n>ubound(a) then : pull = empty : exit function : end if : end if : call bind(pull,a(n)) : for i=n to ubound(a)-1 : call swap(a(i),a(i+1)) : next : redim preserve a(ubound(a)-1) : end function
'--
'+array_merge(array,array) :: valid_arguments, bind \(1,2), (3,4) -> (1,2,3,4), returns array, not modified original\
function array_merge(a,b) : dim i,c : c = array() : call valid_arguments("amerge",array(a,b),array("array","array")) : for i=0 to ubound(a) : redim preserve c(ubound(c)+1) : call bind(c(ubound(c)),a(i)) : next : for i=0 to ubound(b) : redim preserve c(ubound(c)+1) : call bind(c(ubound(c)),b(i)) : next : array_merge = c : end function : 
'+array_reverse(array) :: valid_arguments, swap \\
function array_reverse(a) : dim i,j : call valid_arguments("array_reverse",array(a),array("array")) : if ubound(a)<0 then : array_reverse = a : exit function : end if : i = 0 : j = ubound(a) : do while i<j : call swap(a(i),a(j)) : i=i+1 : j=j-1 : loop : array_reverse = a : end function
'e.g. array_grab(array(1,2,3,4,5),1,4) => array(2,3,4,5)
'+array_grab(array, integer/long, integer/long) :: valid_arguments, cerr, ERR_FUNCTION_ARRAY_GRAB, push \(target, start_element, end_element)\
function array_grab(a,i,j) : dim b,k : b = array() : call valid_arguments("array_grab",array(a,i,j),array("array","integer/long","integer/long")) : if i>j or i<0 or j>ubound(a) then : cerr("(array_grab) array has length ("&ubound(a)&"), can't allocate from ("&i&") to ("&j&")") : err.raise ERR_FUNCTION_ARRAY_GRAB, "array has length ("&ubound(a)&"), can't allocate from ("&i&") to ("&j&")", "ERR_FUNCTION_ARRAY_GRAB" : end if : for k=i to j : call push(b, a(k)) : next : array_grab = b : end function
'+array_grab_to(array, integer/long) :: array_grab \(target, to_position), grab array from 'front' to 'p'\
function array_grab_to(a,p) : array_grab_to = array_grab(a,0,p) : end function
'+array_grab_from(array, integer/long) :: array_grab \(target, from_position), grab array from 'p' to 'end'\
function array_grab_from(a,p) : array_grab_from = array_grab(a,p,ubound(a)) : end function
'+array_rotate(array, boolean) :: valid_arguments, pop, unshift, shift, push \(target, rotate_right?) \
function array_rotate(a,d) : dim b,c : c = a : call valid_arguments("array_rotate",array(a,d),array("array","boolean")) : if d then : b = pop(c) : call unshift(c, b) : else : b = shift(c) : call push(c,b) : end if : array_rotate = c : end function
'+array_rotate_right(array) :: array_rotate \\
function array_rotate_right(a) : array_rotate_right = array_rotate(a,true) : end function
'+array_rotate_left(array) :: array_rotate \\
function array_rotate_left(a) : array_rotate_left = array_rotate(a,false) : end function
'array_dimension(array) :: valid_arguments \detect array dimension\
function array_dimension(a) : call valid_arguments("dimension",array(a),array("array")) : on error resume next : dim i : i = 0 : do until err.number <> 0 : i=i+1 : call ubound(a,i) : loop : err.clear : array_dimension = i-1 : end function
'+array_chop(array) :: valid_arguments \(1,2) => (1)\
function array_chop(a) : call valid_arguments("array_chop",array(a),array("array")) : redim preserve a(ubound(a)-1) : array_chop = a : end function
'+array_chomp(array) :: valid_arguments \(1,2,"") => (1,2)\
function array_chomp(a) : call valid_arguments("array_chomp",array(a),array("array")) : if a(ubound(a)) = "" then : redim preserve a(ubound(a)-1) : end if : array_chomp = a : end function
'--
'primitive qsort
'+pqsort(array,integer/long,integer/long) :: valid_arguments, isvalue, cerr, swap \\
function pqsort(a,l,r) : dim i,j,p : call valid_arguments("pqsort",array(a,l,r),array("array","integer/long","integer/long")) : if r<0 then : pqsort = a : exit function : end if : i=l : j=r : p=a(fix((i+j)/2)) : do while i<=j : do while a(i) < p : i=i+1 : loop : if not isvalue(a(j)) then : cerr("(pqsort) detect object, abort sorting.") : pqsort = a : exit function : end if : do while a(j) > p : j=j-1 : loop : if i<=j then : call swap(a(i),a(j)) : i=i+1 : j=j-1 : end if : if l<j then : call pqsort(a, l, j) : end if : if i<r then : call pqsort(a, i, r) : end if : loop : pqsort = a : end function : 
'+qsort(array) :: valid_arguments, pqsort \quicksort\
function qsort(a) : call valid_arguments("qsort",array(a),array("array")) : qsort = pqsort(a,0,ubound(a)) : end function
'+rsort(array) :: array_reverse, qsort \reversed quicksort\
function rsort(a) : rsort = array_reverse(qsort(a)) : end function

'# environment #
'+getenv(string) :: valid_arguments, ashell \\
function getenv(s) : call valid_arguments("getenv",array(s),array("string")) : getenv = ashell.expandenvironmentstrings(s) : end function
'+env() :: getenv \alias to getenv() \
function env(s) :: env = getenv(s) : end function
'+getcd() :: afso \returns folder\
function getcd() : set getcd = afso.getfolder(".") : end function
'+pwd() :: absolutepath \returns string\
function pwd() : pwd = absolutepath(".") : end function

'# processes #
'+pid() :: isusewmi, exec, aconn, cerr \returns own process id using wmi.\
function pid() : dim b,p,c : if isusewmi() then : set b = pexec("cmd /K ") : set p = aconn.execquery("select ParentProcessId from win32_process where ProcessId = "&b.processid&"") : for each c in p : pid = c.ParentProcessId : exit for : next : b.stdin.writeline("exit") : b.terminate : else : cerr("(pid) can't find own process id because can't use WMI functions.") : end if : end function
'+ppid() :: valid_arguments, isusewmi, aconn, cerr \returns parent process id using wmi.\
function ppid(p) : dim b,c : call valid_arguments("ppid",array(p),array("integer/long")) : if isusewmi() then : set b = aconn.execquery("select ParentProcessId from win32_process where ProcessId = "&p&"") : for each c in b : ppid = c.ParentProcessId : exit for : next : else : cerr("(pid) can't find own process id because can't use WMI functions.") : end if : end function
'+getpid() :: pid \\
function getpid() : getpid = pid() : end function
'--
'*pexec(string) :: valid_arguments, ashell, flog \exec command. returns wshexec object. if you wants error, check exitcode.\
function pexec(s) : call valid_arguments("pexec",array(s),array("string")) : set pexec = ashell.exec(s) : flog("(pexec) ["&pexec.processid&"] """&s&"""") : end function
'*wexec(string) :: valid_arguments, ashell, flog, cerr, cout, usleep \exec command, wait to done. returns wshexec object. if you wants error, check exitcode.\
function wexec(s) : call valid_arguments("wexec",array(s),array("string")) : set wexec = ashell.exec(s) : flog("(wexec) ["&wexec.processid&"] """&s&"""") : do until (wexec.status <> 0 and wexec.stdout.atendofstream) : if not wexec.stdout.atendofstream then : cout(wexec.stdout.readline) : end if : usleep(10) : loop : do until wexec.stderr.atendofstream : cerr(wexec.stderr.readline) : loop : end function

'# echo # echo functions returns write length.
'+echo(value) :: valid_arguments, flog \\
function echo(s) : call valid_arguments("echo",array(s),array("value")) : echo = flog(s) : end function
'+pecho(value) :: valid_arguments, shellpopup, flog \popup echo. if you want response, use shellpopup()\
function pecho(s) : call valid_arguments("pecho",array(s),array("value")) : call shellpopup(s, 3, "["&scriptname&"]", 0) : pecho = flog(s) : end function
'+eecho(value) :: valid_arguments, flog \\
function eecho(s) : call valid_arguments("eecho",array(s),array("value")) : eecho = flog("[ERR ] "&s) : end function
'+iecho(value) :: valid_arguments, flog \\
function iecho(s) : call valid_arguments("iecho",array(s),array("value")) : iecho = flog("[INFO] "&s) : end function
'+wecho(value) :: valid_arguments, flog \\
function wecho(s) : call valid_arguments("wecho",array(s),array("value")) : wecho = flog("[WARN] "&s) : end function

'# echo_ # echo_ functions no returns.
'echo_array(array) :: valid_arguments, iif, isvalue, echo \array echo. for more info, use dumper()\
function echo_array(a) : dim i : call valid_arguments("echo_array",array(a),array("array")) : echo(typename(a)&"("&ubound(a)&") (") : for i=0 to ubound(a) : echo(string(2," ")&"("&i&") = "&typename(a(i))&"("&iif(isvalue(a(i)),a(i),"*")&")") : next : echo(")") : end function
'echo_array1(array) :: valid_arguments, iif, isvalue, echo \1 liner array echo\
function echo_array1(a) : dim i, b : b = "" : call valid_arguments("echo_array1",array(a),array("array")) : b = typename(a)&"("&ubound(a)&") (" : for i=0 to ubound(a) : b = b&string(2," ")&"("&i&") = "&typename(a(i))&"("&iif(isvalue(a(i)),a(i),"*")&")" : next : b = b&")" : echo(replace(b,vbnewline,"")) : end function
'echo_xml(domdocument/ixmldomnodelist) :: valid_arguments, isxml, echo \\
function echo_xml(x) : dim b : call valid_arguments("echo_xml",array(x),array("domdocument/ixmldomnodelist")) : if isxml(x) then : b = x.xml : else : b = x.item(0).xml : end if : echo(typename(x)&"(") : echo(string(2," ")&b) : echo(")") : end function
'echo_xml1(domdocument/ixmldomnodelist) :: valid_arguments, isxml, echo \1 liner xml echo\
function echo_xml1(x) : call valid_arguments("echo_xml1",array(x),array("domdocument/ixmldomnodelist")) : if isxml(x) then : echo(x.xml) : else : echo(x.item(0).xml) : end if : end function
'echo_dictionary(dictionary) :: valid_arguments, iif, isvalue, echo \\
function echo_dictionary(d) : dim k : call valid_arguments("echo_dictionary",array(d),array("dictionary")) : echo(typename(d)&"("&d.count&")"&" (") : for each k in d : echo(string(2," ")&"("&k&") => "&typename(d(k))&"("&iif(isvalue(d(k)),d(k),"*")&")") : next : echo(")") : end function
'echo_dictionary1(dictionary) :: valid_arguments, iif, isvalue, echo \1 liner dictionary echo\
function echo_dictionary1(d) : dim k,b : call valid_arguments("echo_dictionary1",array(d),array("dictionary")) : b = typename(d)&"("&d.count&")"&" (" : for each k in d : b = b&string(2," ")&"("&k&") => "&typename(d(k))&"("&iif(isvalue(d(k)),d(k),"*")&")" : next : b = b&")" : echo(b) : end function
'echo_matches(imatchcollection2/isubmatches) :: valid_arguments, ismatch, iif \\
function echo_matches(m) : dim i,j : call valid_arguments("echo_matches",array(m),array("imatchcollection2/isubmatches")) : if ismatch(m) then : echo(typename(m)&"("&m.count&") (") : for i=0 to m.count-1 : echo(string(2," ")&typename(m(i))&"("&i&") ( (firstindex, length, value) = ("&m(i).firstindex&", "&m(i).length&", "&typename(m(i).value)&"("&m(i).value&")) "&iif(m(i).submatches.count>0,"",")")) : if m(i).submatches.count > 0 then : for j=0 to m(i).submatches.count-1 : echo(string(4," ")&typename(m(i).submatches)&"("&m(i).submatches.count&") ( ("&j&") = ("&m(i).submatches(j)&") )") : next : echo(string(2," ")&")") : end if : next : echo(")") : else : echo(typename(m)&"("&m.count&") (") : for i=0 to m.count-1 : echo(string(2," ")&"("&i&") = "&typename(m(i))&"("&m(i)&")") : next : echo(")") : end if : end function
'echo_matches1(imatchcollection2/isubmatches) :: valid_arguments, ismatch, iif \1 liner matches/submatches echo\
function echo_matches1(m) : dim i,j,b : call valid_arguments("echo_matches1",array(m),array("imatchcollection2/isubmatches")) : if ismatch(m) then : b = typename(m)&"("&m.count&") (" : for i=0 to m.count-1 : b = b&string(2," ")&typename(m(i))&"("&i&") ( (firstindex, length, value) = ("&m(i).firstindex&", "&m(i).length&", "&typename(m(i).value)&"("&m(i).value&")) "&iif(m(i).submatches.count>0,"",")") : if m(i).submatches.count > 0 then : for j=0 to m(i).submatches.count-1 : b = b&string(4," ")&typename(m(i).submatches)&"("&m(i).submatches.count&") ( ("&j&") = ("&m(i).submatches(j)&") )" : next : b = b&string(2," ")&")" : end if : next : b = b&")" : echo(b) : else : b = typename(m)&"("&m.count&") (" : for i=0 to m.count-1 : b = b&string(2," ")&"("&i&") = "&typename(m(i))&"("&m(i)&")" : next : b = b&")" : echo(b) : end if : end function
'--
'dumper(*) :: isvalue, echo, FUNCTION_DUMPER_LABEL, FUNCTION_DUMPER_LEVEL \dump variable\
function dumper(v) : dim b,c : select case (isvalue(v) or isempty(v)) : case true : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&v&")") : case else : select case typename(v) : case "Variant()" : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&ubound(v)&") (") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for b=0 to ubound(v) : FUNCTION_DUMPER_LABEL = "(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&"("&b&") = " : call dumper(v(b)) : next : FUNCTION_DUMPER_LABEL = "(dumper) " : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : case "Dictionary" : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&v.count&") {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for each b in v : FUNCTION_DUMPER_LABEL = "(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(b)&"("&b&") => " : call dumper(v(b)) : next : FUNCTION_DUMPER_LABEL = "(dumper) " : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "IMatchCollection2" : echo(FUNCTION_DUMPER_LABEL&typename(v)&" {") : FUNCTION_DUMPER_LABEL = "(dumper) " : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : if v.count>0 then : for b=0 to v.count-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v(b))&"("&v.count&") (") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"("&b&") = (") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(firstindex) = ("&v(b).firstindex&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(length) = ("&v(b).length&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(value) = "&typename(v(b).value)&"("&v(b).value&")") : if v(b).submatches.count>0 then : call dumper(v(b).submatches) : end if : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : next : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : end if : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "ISubMatches" : echo("(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&" (") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for b=0 to v.count-1 : echo("(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&"("&b&") = "&typename(v(b))&"("&v(b)&")") : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo("(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : case "IMessage" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&" (") : FUNCTION_DUMPER_LABEL = "(dumper) " : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(from) = ("&v.from&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(to) = ("&v.to&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(cc) = ("&v.cc&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(bcc) = ("&v.bcc&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(subject) = ("&v.subject&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(htmlbody) = ("&v.htmlbody&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(textbody) = ("&v.textbody&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(bodypart.charset) = ("&v.bodypart.charset&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(attachments)("&v.attachments.count&") = {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for each b in v.attachments : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(filename) = "&typename(b.filename)&"("&b.filename&")") : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : FUNCTION_DUMPER_LABEL = "(dumper) " : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : case "DOMDocument" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&" {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : if v.haschildnodes then : FUNCTION_DUMPER_LABEL = "(dumper) " : call dumper(v.childnodes) : end if : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : FUNCTION_DUMPER_LABEL = "(dumper) " : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "IXMLDOMNodeList" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&"("&v.length&") {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for each b in v : call dumper(b) : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "IXMLDOMElement" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&"("&v.nodename&" -> "&v.nodevalue&") {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for b=0 to v.childnodes.length-1 : call dumper(v.childnodes(b)) : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "IXMLDOMText" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&"("&v.nodename&" -> "&v.nodevalue&")") : case "IXMLDOMSelection" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&"("&v.length&") {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for each b in v : FUNCTION_DUMPER_LABEL = "(dumper) " : call dumper(b) : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "File" : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&v.path&")") : case "Folder" : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&v.path&")") : case else : select case (isnothing(v) or isnull(v)) : case true : echo(FUNCTION_DUMPER_LABEL&typename(v)&"()") : case else : echo(FUNCTION_DUMPER_LABEL&typename(v)&"(*)") : end select : end select : end select : end function

'--
'+cout(string) :: \this function is primitive so do not use user functions in this.\
function cout(s) : on error resume next : cout = len(s) : wscript.stdout.writeline(s) : err.clear : end function
'+cerr(string) :: FUNCTION_CERR_ERRORLEVEL \this function is primitive so do not use user functions in this.\
function cerr(s) : on error resume next : if FUNCTION_CERR_ERRORLEVEL > 0 then : cerr = len(s) : if FUNCTION_CERR_ERRORLEVEL > 1 then : stop : end if : end if : wscript.stderr.writeline(s) : err.clear : end function

'# abbreviations #
'*afso() :: 
function afso() : set afso = wscript.createobject("scripting.filesystemobject") : end function
'*ashell() ::
function ashell() : set ashell = wscript.createobject("wscript.shell") : end function
'*adic() :: 
function adic() : set adic = wscript.createobject("scripting.dictionary") : end function
'*aapp() ::
function aapp() : set aapp = wscript.createobject("shell.application") : end function
'*anet() ::
function anet() : set anet = wscript.createobject("wscript.network") : end function
'*aarg() :: 
function aarg() : set aarg = wscript.arguments : end function
'*axmlhttp() :: 
function axmlhttp() : set axmlhttp = createobject("msxml2.xmlhttp") : end function
'*alocator() ::
function alocator() : set alocator = wscript.createobject("WbemScripting.SWbemLocator") : end function
'*aconn() :: alocator
function aconn() : set aconn = alocator.connectserver : end function
'*adb() :: 
function adb() : set adb = createobject("adodb.connection") : end function
'*astream() :: 
function astream() : set astream = createobject("adodb.stream") : end function
'*axml() :: 
function axml() : set axml = createobject("msxml2.domdocument") : end function
'*amail() :: amessage \alias to amessage\
function amail() : set amail = amessage() : end function
'*amessage() :: \\
function amessage() : on error resume next : set amessage = createobject("cdo.message") : if err.number <> 0 then : cerr("(amessage) can't create cdo.message object.") : stop : set amessage = nothing : err.clear : end if : end function
'*aconnsrv(string,string,string,string) :: alocator \(computer,namespace,username,password)\
function aconnsrv(c,n,u,p) : call valid_arguments("aconnsrv",array(c,n,u,p),array("string","string","string","string")) : set aconnsrv = alocator.connectserver(c,n,u,p) : end function
'+aan(string) :: valid_arguments, aarg \\
function aan(n) : call valid_arguments("aan",array(n),array("string")) : aan = aarg.named(n) : end function
'+aau(integer/long) :: valid_arguments, aarg \\
function aau(n) : call valid_arguments("aau",array(n),array("integer/long")) : if aarg.unnamed.count > n then : aau = aarg.unnamed(n) : end if : end function

'# filehandler # f*() allows file/string
'\textfile\ -> ftextfile
'*ftextfile(file/string,integer/long,boolean,integer/long) :: ftextfile \(filename,iomode,create,format)\
function ftextfile(f,iomode,create,format) : call valid_arguments("ftextfile",array(f,iomode,create,format),array("file/string","integer/long","boolean","integer/long")) : set ftextfile = afso.opentextfile(f,iomode,create,format) : end function
'*fread(file/string) :: ftextfile \\
function fread(f) : set fread = ftextfile(f,1,false,-2) : end function
'*fwrite(file/string) :: fappend \\
function fwrite(f) : set fwrite = fappend(f) : end function
'*fappend(file/string) :: ftextfile \\
function fappend(f) : set fappend = ftextfile(f,8,true,-2) : end function
'*fowrite(file/string) :: ftextfile \overwrite\
function fowrite(f) : set fowrite = ftextfile(f,2,true,-2) : end function
'*furead(file/string) :: ftextfile \\
function furead(f) : set furead = ftextfile(f,1,false,-1) : end function
'*fuwrite(file/string) :: fuappend \\
function fuwrite(f) : set fuwrite = fuappend(f) : end function
'*fuappend(file/string) :: ftextfile \\
function fuappend(f) : set fuappend = ftextfile(f,8,true,-1) : end function
'*fuowrite(file/string) :: ftextfile \overwrite\
function fuowrite(f) : set fuowrite = ftextfile(f,2,true,-1) : end function
'--
'\textstream\ -> ftextstream
'*ftextstream("file/string","integer/long","integer/long") :: valid_arguments, afso \(filename,iomode,format), open as textstream\
function ftextstream(f,iomode,format) : call valid_arguments("ftextstream",array(f,iomode,format),array("file/string","integer/long","integer/long")) : set ftextstream = afso.getfile(f).openastextstream(iomode,format) : end function
'*ftsread(file/string) :: ftextstream \\
function ftsread(f) : set ftsread = ftextstream(f,1,-2) : end function
'*ftswrite(file/string) :: ftsappend \\
function ftswrite(f) : set ftswrite = ftsappend(f) : end function
'*ftsappend(file/string) :: e, ftsowrite, ftextstream \\
function ftsappend(f) : if not e(f) then : call ftsowrite(f) : end if : set ftsappend = ftextstream(f,8,-2) : end function
'*ftsuread(file/string) :: ftextstream \\
function ftsuread(f) : set ftsuread = ftextstream(f,1,-1) : end function
'*ftsuwrite(file/string) :: ftsuappend \\
function ftsuwrite(f) : set ftsuwrite = ftsuappend(f) : end function
'*ftsuappend(file/string) :: e, ftsowrite, ftextstream \\
function ftsuappend(f) : if not e(f) then : call ftsowrite(f) : end if : set ftsuappend = ftextstream(f,8,-1) : end function
'*ftsowrite(file/string) :: fowrite, ftswrite \\ 
function ftsowrite(f) : call fowrite(f) : set ftsowrite = ftswrite(f) : end function
'*ftsuowrite(file/string) :: fowrite, ftsuwrite \\ 
function ftsuowrite(f) : call fowrite(f) : set ftsuowrite = ftsuwrite(f) : end function
'--
'readtext()
''-2 : by line
'-1 : readall
'n : by byte
'\stream\ -> fstream
'*fstream(file/string,string) :: valid_arguments, astream \(filename, charset)\
function fstream(f,charset) : call valid_arguments("fstream",array(f,charset),array("file/string","string")) : set fstream = astream() : fstream.charset = charset : end function
'*fsread(file/string) :: fstream \\
function fsread(f) : set fsread = fstream(f,"shift-jis") : fsread.open : fsread.loadfromfile(f) : end function
'*fswrite(file/string) :: fsappend \\
function fswrite(f) : set fswrite = fsappend(f) : end function
'*fsappend(file/string) :: fstream \\
function fsappend(f) : set fsappend = fstream(f,"shift-jis") : fsappend.open : fsappend.loadfromfile(f) : fsappend.position = fsappend.size : end function
'*fsuread(file/string) :: fstream \\
function fsuread(f) : set fsuread = fstream(f,"utf-8") : fsuread.open : fsuread.loadfromfile(f) : end function
'*fsuwrite(file/string) :: fsuappend \\
function fsuwrite(f) : set fsuwrite = fsuappend(f) : end function
'*fsuappend(file/string) :: fstream \\
function fsuappend(f) : set fsuappend = fstream(f,"utf-8") : fsuappend.open : fsuappend.loadfromfile(f) : fsuappend.position = fsuappend.size : end function
'+fs_write(file/string,value) :: valid_arguments, fswrite, \write string using fswrite()\
function fs_write(f,s) : dim b : call valid_arguments("fs_write",array(f,s),array("file/string","value")) : set b = fswrite(f) : b.writetext(s) : call b.savetofile(f,2) : fs_write = len(s) : end function
'+fs_writeline(file/string,value) :: valid_arguments, fswrite, \write string using fswrite()\
function fs_writeline(f,s) : dim b : call valid_arguments("fs_writeline",array(f,s),array("file/string","value")) : set b = fswrite(f) : call b.writetext(s,1) : call b.savetofile(f,2) : fs_writeline = len(s) : end function

'# log #
'flog_init() :: CSCRIPTLAUNCH, FUNCTION_FLOG_INIT, FUNCTION_FLOG_TYPENAME, FUNCTION_FLOG_FILENAME, buildpath, FUNCTOIN_FLOG_LOGDIR, iif, eau, ynd, basename, parentfolder \\
function flog_init() : if isempty(CSCRIPTLAUNCH) then : CSCRIPTLAUNCH = iif(iscscript(),true,false) : end if : if not CSCRIPTLAUNCH and FUNCTION_FLOG_TYPENAME = "flog0" then : FUNCTION_FLOG_INIT = true : FUNCTION_FLOG_TYPENAME = "flog1" : wscript.echo("'FUNCTION_FLOG_TYPENAME' is changed to '"&FUNCTION_FLOG_TYPENAME&"'") : flog("'FUNCTION_FLOG_TYPENAME' is changed to '"&FUNCTION_FLOG_TYPENAME&"'") : end if : if isempty(FUNCTION_FLOG_FILENAME) then : select case FUNCTION_FLOG_TYPENAME : case "flog2" : FUNCTION_FLOG_FILENAME = buildpath(FUNCTOIN_FLOG_LOGDIR, buildpath(iif(eau("logbase"),aan("logbase"),""),ynd(yyyynndd)&".log")) : case else : FUNCTION_FLOG_FILENAME = buildpath(FUNCTOIN_FLOG_LOGDIR, basename(wscript.scriptname)&".log") : end select : call mkdir(parentfolder(FUNCTION_FLOG_FILENAME)) : end if : end function
'+flogname() :: FUNCTION_FLOG_FILENAME, flog_init \\
function flogname() : if isempty(FUNCTION_FLOG_FILENAME) then : call flog_init() : end if : flogname = FUNCTION_FLOG_FILENAME : end function
'+flogepid() :: FUNCTION_FLOG_EPID, flog_init\\
function flogepid() : if isempty(FUNCTION_FLOG_EPID) then : FUNCTION_FLOG_EPID = rndstr(3): end if : flogepid = FUNCTION_FLOG_EPID : end function
'--
'+flog(*) :: FUNCTION_FLOG_INIT, flog_init, FUNCTION_FLOG_TYPENAME, dumper \prototype of flog* functions.\ 
function flog(s) : if isempty(FUNCTION_FLOG_INIT) then : call flog_init() : end if : if not isvalue(s) then : flog("(flog) fallback ..") : dumper(s) : else : flog = getref(FUNCTION_FLOG_TYPENAME)(s) : end if : end function
'+flog0(*) :: datetime, flog \write to console\
function flog0(s) : wscript.stdout.writeline(datetime()&vbtab&s) : flog0 = len(s) : end function
'+flog1(*) :: ftsappend, flogname, datetime, flog \write to scriptname.log\
function flog1(s) : ftsappend(flogname()).writeline(datetime()&vbtab&s) : flog1 = len(s) : end function
'+flog2(*) :: ftsappend, flogname, datetime, flog \write to date.log\
function flog2(s) : ftsappend(flogname()).writeline(datetime()&vbtab&s) : flog2 = len(s) : end function
'+flog3(*) :: FUNCTION_FLOG_EPID, rndstr, afso, flogname, FUNCTION_FLOG_ROTATE_MAXCOUNT, e, filename, ftsappend \write to scriptname.log rotate by each execution\
function flog3(s) : dim b : if isempty(FUNCTION_FLOG_EPID) then : call flogepid() : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT) then : afso.deletefile flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT : end if : for b=FUNCTION_FLOG_ROTATE_MAXCOUNT to 1 step -1 : if e(flogname()&"."&b) then : afso.getfile(flogname()&"."&b).name = filename(flogname()&"."&b+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : end if : end if : ftsappend(flogname()).writeline(datetime()&vbtab&s) : flog3 = len(s) : end function
'+fllog4(*) :: e, flogname, ftsread, FUNCTION_FLOG_ROTATE_MAXCOUNT, afso, ynd, ftswrite, filename \write to scriptname.log rotate by each day\
function flog4(s) : dim b,t : t = now() : if e(flogname()) then : if not left(ftsread(flogname()).readline,8) = year(t)&right("0"&month(t),2)&right("0"&day(t),2) then : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT) then : afso.deletefile flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT : end if : for b=FUNCTION_FLOG_ROTATE_MAXCOUNT to 1 step -1 : if e(flogname()&"."&b) then : afso.getfile(flogname()&"."&b).name = filename(flogname()&"."&b+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : end if : ftswrite(flogname()).writeline(ynd("yyyynndd")) : end if : else : ftswrite(flogname()).writeline(ynd("yyyynndd")) : end if : ftswrite(flogname()).writeline(datetime()&vbtab&s) : flog4 = len(s) : end function
'+flog5(*) :: e, flogname, afso, FUNCTION_FLOG_ROTATE_MAXSIZE, FUNCTION_FLOG_ROTATE_MAXCOUNT, filename, ftswrite \write to scritpname.log rotate by filesize limit\
function flog5(s) : dim b : if e(flogname()) then : if afso.getfile(flogname()).size >= FUNCTION_FLOG_ROTATE_MAXSIZE then : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT) then : afso.deletefile flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT : end if : for b=FUNCTION_FLOG_ROTATE_MAXCOUNT to 1 step -1 : if e(flogname()&"."&b) then : afso.getfile(flogname()&"."&b).name = filename(flogname()&"."&b+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : end if : end if : end if : ftswrite(flogname()).writeline(datetime()&vbtab&s) : flog5 = len(s) : end function : 
'+flog6(*) :: e, flogname, ftsread, yndHMS, FUNCTION_FLOG_ROTATE_PATTERN, FUNCTION_FLOG_ROTATE_MAXCOUNT, afso, filename, \write to scriptname.log rotate by time string pattern\
function flog6(s) : dim b : if e(flogname()) then : if not ftsread(flogname()).readline = yndHMS(FUNCTION_FLOG_ROTATE_PATTERN) then : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT) then : afso.deletefile flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT : end if : for b=FUNCTION_FLOG_ROTATE_MAXCOUNT to 1 step -1 : if e(flogname()&"."&b) then : afso.getfile(flogname()&"."&b).name = filename(flogname()&"."&b+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : end if : ftswrite(flogname()).writeline(yndHMS(FUNCTION_FLOG_ROTATE_PATTERN)) : end if : else : ftswrite(flogname()).writeline(yndHMS(FUNCTION_FLOG_ROTATE_PATTERN)) : end if : ftswrite(flogname()).writeline(datetime()&vbtab&s) : flog6 = len(s) : end function

'# file utilities #
'+fcut(file/string, integer/long, integer/long) :: class:rb, valid_arguments, e, cerr, ERR_FUNCTION_FCUT, ftswrite, ftsread \if end line has EOF only, function returns empty. \
function fcut(f,sl,el) : dim b, rb, ll, r : r = array() : set rb = new rb : call valid_arguments("fcut",array(f,sl,el),array("file/string","integer/long","integer/long")) : if not e(f) then : cerr("(fcut) "&f&" is missing.") : err.raise ERR_FUNCTION_FCUT, "'"&f&"' is missing ", "ERR_FUNCTION_FCUT" : end if : ll = ftswrite(f).line : if not ((sl>0 and sl<=ll) and (el>0 and el<=ll) and sl<=el) then : cerr("(fcut) invalid range ("&sl&" to "&el&")") : err.raise ERR_FUNCTION_FCUT, "invalid range ("&sl&" to "&el&")", "ERR_FUNCTION_FCUT" : end if : set b = ftsread(f) : do until b.line = sl : b.skipline : loop : rb.size = el-sl+1 : do until b.line = el : rb.value = b.readline : loop : if not b.atendofstream then : rb.value = b.readline : end if : if el=b.line and b.column=1 then : rb.value = empty : end if : fcut = rb.values : end function : '+ftailn(file/string,integer/long) :: valid_arguments, e, cerr, ERR_FUNCTION_FTAILN, ftswrite, echo, fcut \implement with fcut()\
function ftailn(f,n) : dim b,ll : call valid_arguments("ftailn",array(f,n),array("file/string","integer/long")) : if not e(f) then : cerr("(ftailn) '"&f&"' is missing.") : err.raise ERR_FUNCTION_FTAILN, "'"&f&"' is missing ", "ERR_FUNCTION_FTAILN" : end if : ll = ftswrite(f).line : if n>ll then : echo("(ftailn) '"&n&"' is out of range, fallback to '"&ll&"'") : n = ll : end if : b = fcut(f, ll-n+1, ll) : ftailn = b : end function
'+fheadn(file/string,integer/long) :: valid_arguments, e, cerr, ERR_FUNCTION_FHEADN, ftswrite, echo, fcut \implement with fcut()\
function fheadn(f,n) : dim b, ll : call valid_arguments("fheadn",array(f,n),array("file/string","integer/long")) : if not e(f) then : cerr("(fheadn) '"&f&"' is missing.") : err.raise ERR_FUNCTION_FHEADN, "'"&f&"' is missing ", "ERR_FUNCTION_FHEADN" : end if : ll = ftswrite(f).line : if n>ll then : echo("(ftailn) '"&n&"' is out of range, fallback to '"&ll&"'") : n = ll : end if : b = fcut(f, 1, n) : fheadn = b : end function
'+fhead(file/string) :: fheadn
function fhead(f) : fhead = fheadn(f,1) : end function
'+ftail(file/string) :: ftailn
function ftail(f) : ftail = ftailn(f,1) : end function
'+fcat(file/string) :: valid_arguments, e, cerr, ERR_FUNCTION_FCAT, ftsread \\
function fcat(f) : call valid_arguments("fcat",array(f),array("file/string")) : if not e(f) then : cerr("(fcat) '"&f&"' is missing. ") : err.raise ERR_FUNCTION_FCAT, "'"&f&"' is missing ", "ERR_FUNCTION_FCAT" : end if : fcat = ftsread(f).readall : end function
'+farray(string) :: f2a
function farray(f) : farray = f2a(f) : end function
'?ftouch(file/string) :: valid_arguments, e, afso, aapp, parentfolder, filename \\
function ftouch(f) : dim b : call valid_arguments("ftouch",array(f),array("file/string")) : if not e(f) then : afso.createtextfile(f) : else : set b = afso.getfile(f) : aapp.namespace(parentfolder(b.path)).parsename(filename(b.path)).ModifyDate = now() : end if : ftouch = e(f) : end function
'+fcleanup(file/string) :: vlid_arguments, e, cerr, ERR_FUNCTION_FCLEANUP, f2v, FUNCTION_FCLEANUP_BLOCK_REMOVE, FUNCTION_FCLEANUP_LINE_REMOVE, FUNCTION_FCLEANUP_LINE_REMOVE2, FUNCTION_FCLEANUP_LINE_REMOVE3, FUNCTION_FCLEANUP_STRING_BRACE, rremove, rmatch, push \\
function fcleanup(f) : dim b,buf,flg,p,r : call valid_arguments("fcleanup",array(f),array("file/string")) : if not e(f) then : cerr("(fcleanup) '"&f&"' is missing") : err.raise ERR_FUNCTION_FCLEANUP, "'"&f&"' is missing", "ERR_FUNCTION_FCLEANUP" : end if : r = array() : b = f2v(f) : for each p in FUNCTION_FCLEANUP_BLOCK_REMOVE : b = rremove(b,p(0)&"(\n|.)+?"&p(1)) : next : for each buf in split(b,vbnewline) : for each p in FUNCTION_FCLEANUP_LINE_REMOVE : if rmatch(buf,"^\s*"&p&".*$") then : buf = rremove(buf,"^\s*"&p&".*$") : end if : next : if not rmatch(buf,"^\s*$") then : for each p in FUNCTION_FCLEANUP_LINE_REMOVE2 : if rmatch(buf,p&".*$") then : buf = rremove(buf, p&"[^"&FUNCTION_FCLEANUP_STRING_BRACE&"]*$") : end if : next : buf = rremove(buf,"\s*$") : for each p in FUNCTION_FCLEANUP_LINE_REMOVE3 : if rmatch(buf,p&"[^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"][^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"]*[^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"]$") then : buf = rremove(buf,p&"[^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"][^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"]*[^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"]$") : end if : next : call push(r,rremove(buf,"\s*$")) : end if : next : fcleanup = r : end function : 
'+fgrep(file/string,string) :: valid_arguments, e, cerr, ERR_FUNCTION_FGREP, ftsread, rmatch, push \\
function fgrep(f,p) : dim b,buf,r : call valid_arguments("fgrep",array(f,p),array("file/string","string")) : if not e(f) then : cerr("(fgrep) '"&f&"' is missing.") : err.raise ERR_FUNCTION_FGREP, "'"&f&"' is missing.", "ERR_FUNCTION_FGREP" : end if : r = array() : set b = ftsread(f) : do until b.atendofstream : buf = b.readline : if rmatch(buf,p) then : call push(r,buf) : end if : loop : fgrep = r : end function

'# threads #
'?th_do(array) :: valid_arguments, echo, push, th_limitcheck, th_done \(cmd_string_array), for use to see sample.txt, function returns exitcode summary. if one of cmds failed, return false.\
function th_do(cmdlist) : dim b, cmds, flgs, ret : ret=true : call valid_arguments("th_do",array(cmdlist),array("array")) : cmds = array() : echo("(th_do) add jobs ("&ubound(cmdlist)+1&") using pexec(). ") : for each b in cmdlist : if typename(b)=typename("") then : call push(cmds, pexec(b)) : call th_limitcheck(cmds) : end if : next : flgs = th_done(cmds) : for b=0 to ubound(flgs) : echo(""""&cmdlist(b)&""" exit("&flgs(b)&")") : if flgs(b)>0 then : ret = false : end if : next : th_do = ret : end function
'th_limitcheck(array) :: valid_arguments,FUNCTION_TH_LIMITCHECK_CPUCOUNT, echo, usleep \(wshexec_array), th_limitcheck() using with th_do()\
function th_limitcheck(cmds) : dim cmd, s : s = 0 : call valid_arguments("th_limitcheck",array(cmds),array("array")) : if ubound(cmds)+2 <= FUNCTION_TH_LIMITCHECK_CPUCOUNT then : exit function : else : echo("(th_limitcheck) encountered threads limitation("&FUNCTION_TH_LIMITCHECK_CPUCOUNT&")") : do : s = 0 : for each cmd in cmds : if cmd.status = 0 then : s=s+1 : end if : next : usleep(100) : loop until s < FUNCTION_TH_LIMITCHECK_CPUCOUNT : end if : end function : 
'+th_done(array) :: valid_arguments, echo, usleep, push \(wshexec_array), th_done() using with th_do(), function returns cmd.exitcode array. \
function th_done(cmds) : dim cmd, flg : call valid_arguments("th_done",array(cmds),array("array")) : echo("(th_done) wait for all of command is completed.") : do : flg = true : for each cmd in cmds : if cmd.status=0 then : flg = false : end if : next : usleep(100) : loop until flg : echo("(th_done) jobs ("&ubound(cmds)+1&") are done.") : flg = array() : for each cmd in cmds : call push(flg, cmd.exitcode) : next : th_done = flg : end function

'# xml #
'*xml(string) :: valid_arguments, cerr \(dom_string) dom_string is such as "<root><child/></root>"\
function xml(s) : dim a : set a = axml() : call valid_arguments("xml",array(s),array("string")) : if a.loadxml(s) then : set xml = a : else : cerr("(xml) '"&s&"' is invalid xml.") : end if : end function
'*fxml(string/file) :: valid_arguments, isfile, e, cerr, ERR_FUNCTION_FXML \\
function fxml(fn) : dim a,f : set a = axml() : call valid_arguments("fxml",array(fn),array("string/file")) : if isfile(fn) then : f = fn.path : else : f = fn : end if : if not e(f) then : cerr("(fxml) not exists file '"&f&"'") : err.raise ERR_FUNCTION_FXML, "not exists file '"&f&"'","ERR_FUNCTION_FXML"  : end if : if a.load(f) then : set fxml = a : else : cerr("(fxml) '"&f&"' is not xml document.") : err.raise ERR_FUNCTION_FXML, "'"&f&"' is not xml document.","ERR_FUNCTION_FXML"  : end if : end function : 

'# class #
'wm for wmi
class wm
private w
'wm_class_initialize() :: adic, dic, wm_set_computer, iecho
private sub class_initialize : set w = adic() : call dic(w,"islocalusewmi",isusewmi()) : if w("islocalusewmi") then : set_computer(anet.computername) : else : iecho("(wm.class_initialize) => this computer cannot use wmi.") : end if : end sub
'wm_class_terminate() :: iecho, CLASS_WM_TERMINATE_WAITTIME
private sub class_terminate : set w = nothing : iecho("(wm.class_terminate) => terminating wm...") : wscript.sleep CLASS_WM_TERMINATE_WAITTIME : end sub
'wm_set_computer() :: dic, wm_isvalidcomputer, wm_isvalidclass, ed
private sub set_computer(t) : call dic(w,"computer",t) : call dic(w,"isvalidcomputer",isvalidcomputer()) : if ed(w,"class") then : call dic(w,"isvalidclass",isvalidclass()) : end if : end sub
'wm_computer() :: isstring, wm_set_computer, iecho
public property let computer(t) : if isstring(t) then : set_computer(t) : else : iecho("(wm.computer) => wants (string)") : end if : end property
'wm_get_computer() ::  
public property get computer : computer = w("computer") : end property
'?wm_isvalidcomputer() :: dic, isping, 
private function isvalidcomputer() : call dic(w,"isping",isping(w("computer"))) : if w("isping") then : on error resume next : call dic(w,"srvex",getobject("winmgmts:\\"&w("computer")&"\root\cimv2")) : isvalidcomputer = not (err.number <> 0) : err.clear : else : isvalidcomputer = false : end if : if not isvalidcomputer then : set w("srvex") = nothing : end if : end function
'wm_set_class() :: dic, wm_isvalidclass
private sub set_class(c) : call dic(w,"class",c) : call dic(w,"isvalidclass",isvalidclass()) : end sub
'wm_let_class() :: isstring, wm_set_class, iecho, dic, wm_isvalidclass
public property let [class](c) : if isstring(c) then : set_class(c) : else : iecho("(wm.class) => wants (string)") : end if : call dic(w,"isvalidclass",isvalidclass()) : end property
'?wm_isvalidclass() :: dic, 
private function isvalidclass() : if w("isping") then : on error resume next : call dic(w,"objex",getobject("winmgmts:\\"&w("computer")&"\root\cimv2:"&w("class"))) : call dic(w,"objset",getobject("winmgmts:\\"&w("computer")&"\root\cimv2").instancesof(w("class"))) : isvalidclass = not (err.number <> 0) : err.clear : else : isvalidclass = false : end if : if not isvalidclass then : set w("objectex") = nothing : set w("objectset") = nothing : end if : end function
'*wm_execquery() :: iecho
public function execquery() : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : set execquery = w("srvex").execquery("select * from "&w("class")) : else : iecho("(wm.execquery) => unfilled condition. check computer/class name or pinging to host") : end if : end function
'*wm_execquery2d() :: adic, dic, iecho
public function execquery2d() : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : dim d,a,b,c,count : count = 0 : set d = adic() : for each a in w("srvex").execquery("select * from "&w("class")) : set c = adic() : for each b in a.properties_ : call dic(c, b.name, b.value) : next : call dic(d,count,c) : count = count + 1 : next : set execquery2d = d : else : iecho("(wm.execquery2d) => unfilled condition. check computer/class name or pinging to host") : end if : if not isobject(execquery2d) then : set execquery2d = adic() : end if : end function
'*wm_q() :: wm_execquery
public function q() : set q = execquery() : end function
'*wm_q2d() :: wm_execquery2d
public function q2d() : set q2d = execquery2d() : end function
'*wm_filteredquery(string) :: isstring, wm_hasproperty, eecho, iecho
public function filteredquery(f) : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : if isstring(f) then : dim q : set q = w("srvex").execquery("select "&f&" from "&w("class")) : if not hasproperty(f) then : eechon("(wm.filteredquery) => return_object has no such property('"&f&"') on class('"&w("class")&"')") : set filteredquery = nothing : else : set filteredquery = q : end if : else : iecho("(wm.filteredquery) => wants (string)") : end if : else : iecho("(wm.filteredquery) => unfilled condition. check computer/class name or pinging to host") : end if : end function
'*wm_filteredquery2d(string) :: isstring, adic, wm_hasproperty
public function filteredquery2d(f) : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : if isstring(f) then : dim d,a,b,c,count,q : count = 0 : set d = adic() : set q = w("srvex").execquery("select "&f&" from "&w("class")) : if not hasproperty(f) then : eechon("(wm.filteredquery2d) => return_object has no such property('"&f&"') on class('"&w("class")&"')") : set filteredquery2d = nothing : else : for each a in q : set c = adic() : for each b in a.properties_ : call dic(c, b.name, b.value) : next : call dic(d,count,c) : count = count + 1 : next : set filteredquery2d = d : end if : else : iecho("(wm.filteredquery2d) => wants (string)") : end if : else : iecho("(wm.filteredquery2d) => unfilled condition. check computer/class name or pinging to host") : end if : if not isobject(filteredquery2d) then : set filteredquery2d = adic() : end if : end function
'*wm_fq(string) :: wm_filteredquery
public function fq(f) : set fq = filteredquery(f) : end function
'*wm_fq2d(string) :: wm_filteredquery2d
public function fq2d(f) : set fq2d = filteredquery2d(f) : end function
'?wm_hasproperty(string) :: isstring, rmatchi, iecho
private function hasproperty(f) : hasproperty = false : if isstring(f) then : dim a,b : for each a in q() : for each b in a.properties_ : if rmatchi(b.name,f) then : hasproperty = true : exit for : end if : next : exit for : next : else : iecho("(wm.hasproperty) => wants (string)") : end if : end function : 
'wm_g(string) :: \\
public function g(s) : set g = w("srvex").get(s) : end function
'wm_dumper() :: \\
public function dump() : dumper(w) : end function
end class

'rb for ring buffer
class rb
private sz,buf,ind,flg,mflg
'rb_class_initialize() :: rb_let_size \\
private sub class_initialize() : buf = array() : mflg = array() : size = 1 : flg = false : end sub
'rb_class_terminate() :: \\
private sub class_terminate() : end sub
'+rb_get_size() :: \\
public property get size : size = sz : end property
'+rb_get_buffer() :: \\
public property get buffer : buffer = buf : end property
'?rb_get_flag() :: \\
public property get flag : flag = flg : end property
'+rb_get_mflag() :: \\
public property get mflag : mflag = mflg : end property
'+rb_get_value() :: \\
public property get value : value = buf(ind) : end property
'+rb_get_pos() :: \\
public property get pos : pos = ind : end property

'+rb_get_values() :: \\
public property get values : values = buf : end property

'rb_let_size(integer/long) :: valid_arguments, cerr \\
public property let size(n) : call valid_arguments("rb_let_size",array(n),array("integer/long")) : if n<1 then : cerr("(rb_let_size) invalid size") : exit property : end if : sz = n-1 : redim buf(sz) : redim mflg(sz) : ind = 0 : flg = false : end property
'rb_let_value(*) :: valid_arguments, bind, \\
public property let value(n) : call valid_arguments("rb_let_value",array(n),array("*")) : call bind(buf(ind), n) : mflg(ind) = timer : if ind+1>sz then : ind = 0 : else : ind = ind+1 : end if : flg = true : end property

'rb_dump() :: cout, iif, \\
public function dump() : dim i : for i=0 to sz : cout(iif(ind=i,"->","")&"buffer("&i&") ["&mflg(i)&"] "&typename(buf(i))&"("&iif(isobject(buf(i)),"*",buf(i))&")") : next : end function
'rb_resize(integer/long) :: cerr, \\
public function resize(n) : call valid_arguments("rb_resize",array(n),array("integer/long")) : if n<1 then : cerr("(rb_resize) invalid value") : exit function : end if : sz = n-1 : redim preserve buf(sz) : redim preserve mflg(sz) : if flg and ind>=ubound(buf)+1 then : ind=0 : end if : end function
'rb_movepos2empty() :: \\
public function movepos2empty() : dim i : for i=0 to sz : if isempty(mflg(i)) then : ind = i : exit for : end if : next : end function
'rb_movepos(integer/long) :: \\
public function movepos(n) : if not n=0 then : n = (n mod (sz+1)) : if ((ind+n) mod (sz+1))<0 then : ind = sz+1+ind+n : else : ind = ind+n : end if : end if : end function
'rb_flush()
public function flush() : redim buf(sz) : end function
end class

'<!-- this line works as delimitre -->
'script starts here

'dim conf : set conf = skelconfig()
'dumper(conf)


]]>
</script>
</job>


<!-- version of skel.wsf -->
<!-- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -->
<job id="version" error="true" debug="false">
<runtime>
<description>skel.wsf のバージョンを返却します。組み込み時は skelv() 関数を利用してください。</description>
<example>cscript skel.wsf //job:version</example>
</runtime>
<script language="VBScript">
<![CDATA[
option explicit

wscript.echo replace(replace(replace(createobject("Scripting.FileSystemObject").getfile(wscript.scriptfullname).datelastmodified," ",""),"/",""),":","")

]]>
</script>
</job>


<!-- extract skel.vbs from skel.wsf -->
<!-- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -->
<job id="extract" error="true" debug="false">
<runtime>
<description>skel.wsf から skel.vbs を抽出します。
project オプションでプロジェクト名が指定された場合はプロジェクト名配下に必須フォルダも作成します。
プロジェクト名にフォルダ階層が含まれると最上位のフォルダ名をプロジェクト名とみなします。</description>
<named name="project" helpstring="プロジェクト名を指定します。プロジェクト名は '^([\w]+\\*)+?$' を満たす必要があります" type="string" retuired="false" />
<named name="overwrite" helpstring="同名のプロジェクト名がある場合に上書きします" type="string" retuired="false" />
<example>cscript skel.wsf //job:extract [/project:PROJECT_NAME [/overwrite]]</example>
<!--
	projectname\
	+- bin\
	+- conf\
	+- log\
	+- lib\
		+- skel.vbs
//-->
</runtime>
<script language="VBScript">
<![CDATA[
option explicit

'--script starts here--
const DELIMITER = "^'<!-- this line works as delimitre -->$"
const PROJECTNAME_PATTERN = "^([\w]+\\*)+?$"
const DIRECTORY_LIST = "bin conf lib log"
dim afso : set afso = createobject("Scripting.FileSystemObject")
dim f : set f = afso.opentextfile(wscript.scriptfullname)
dim rgp : set rgp = new regexp
dim flg : flg = false
dim fwrite 'file pointer
dim buffer 'buffer
dim vbs_filename, wsf_filename 'filename
dim projectname 'projectname if set by /project

'project or else?
if wscript.arguments.named.exists("project") then
	projectname = wscript.arguments.named("project")
	if not len(projectname)>0 then
		wscript.echo "[ERR] project name is empty."
		wscript.quit(1)
	end if
	rgp.pattern = PROJECTNAME_PATTERN
	if not rgp.test(projectname) then
		wscript.echo "[ERR] project name has not allowed character, use only '([\w_]\\*)+?'"
		wscript.quit(1)
	end if
end if

'build path
if not isempty(projectname) then
	if instr(projectname,"\")>0 then
		wsf_filename = left(projectname, instr(projectname,"\")-1)&".wsf"
	else
		wsf_filename = projectname&".wsf"
	end if
	wsf_filename = afso.buildpath(projectname, wsf_filename)
	vbs_filename = afso.buildpath(projectname, "lib\"&afso.getbasename(wscript.scriptname)&".vbs")
	if afso.folderexists(afso.getparentfoldername(vbs_filename)) then
		if not wscript.arguments.named.exists("overwrite") then
			wscript.echo "[ERR] '"&projectname&"' project is already exist."
			wscript.quit(2)
		end if
	end if
	call mkdir(afso.getparentfoldername(vbs_filename))
	for each buffer in split(DIRECTORY_LIST)
		if not afso.folderexists(afso.buildpath(projectname, buffer)) then
			call mkdir(afso.buildpath(projectname, buffer))
		end if
	next
else
	vbs_filename = afso.getbasename(wscript.scriptname)&".vbs"
end if

'set pointer to write for `vbs_filename`
set fwrite = afso.opentextfile(vbs_filename, 2, true)

'write out to `vbs_filename`
''skelv
fwrite.writeline("const skelv = """&replace(replace(replace(afso.getfile(wscript.scriptfullname).datelastmodified," ",""),"/",""),":","")&"""")
''functions
rgp.pattern = DELIMITER
do until f.atendofstream
	buffer = f.readline
	if rgp.test(buffer) then
		flg = not flg
	end if 
	if flg then
		'wscript.echo buffer
		fwrite.writeline(buffer)
	end if
loop

'write out to `wsf_filename`
if not isempty(wsf_filename) then
	set fwrite = afso.opentextfile(wsf_filename, 2, true)
	fwrite.writeline("<?xml version=""1.0"" encoding=""Shift_JIS"" standalone=""yes"" ?>")
	fwrite.writeline("<package><job error=""true"" debug=""false""><runtime>")
	fwrite.writeline("<description> コマンドの概要を記載します </description>")
	fwrite.writeline("<!-- skel.vbs で提供されるデフォルトの引数です //-->")
	fwrite.writeline("<named name=""logbase"" helpstring=""ログファイルのベース名を指定します"" type=""string"" required=""false"" />")
	fwrite.writeline("<named name=""noconfigure"" helpstring=""(sensored)"" type=""string"" required=""false"" />")
	fwrite.writeline("<named name=""notypecast"" helpstring=""(sensored)"" type=""string"" required=""false"" />")
	fwrite.writeline("<named name=""configure"" helpstring=""(sensored)"" type=""string"" required=""false"" />")
	fwrite.writeline("<!-- ---- //-->")
	fwrite.writeline("</runtime>")
	fwrite.writeline("<script language=""VBScript"" src=""lib\skel.vbs""></script>")
	fwrite.writeline("<script language=""VBScript"">")
	fwrite.writeline("<![CDATA[")
	fwrite.writeline("option explicit")
	fwrite.writeline("'write logs to console as default. if you need to write to file, to set TYPENAME to flog(1|2|3|4|5|6)")
	fwrite.writeline("'FUNCTION_FLOG_TYPENAME = ""flog6"""&vbnewline)
	fwrite.writeline("'--script starts here--"&vbnewline)
	fwrite.writeline("'==functions are here=="&vbnewline)
	fwrite.write("]") : fwrite.writeline("]>")
	fwrite.write("</") : fwrite.writeline("script>")
	fwrite.write("</") : fwrite.writeline("job>")
	fwrite.write("</") : fwrite.writeline("package>")
end if

wscript.quit(0)
'==functions are here==
'recursive mkdir
function mkdir(n)
	if (instr(n,"\")>0) then
		call mkdir(afso.getparentfoldername(n))
	end if
	if not afso.folderexists(n) then
		call afso.createfolder(n)
		mkdir = true
	else
		mkdir = false
	end if
end function

]]>
</script>
</job>

<!-- shows dependence of functions and extact utility -->
<!-- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -->
<job id="deptree" error="true" debug="false">
<runtime>
<description>skel.wsf で定義される関数の依存関係を出力します。
extract オプションにより、依存関係にある関数セットを vbs ファイルとして出力します。</description>
<unnamed name="FUNCTION_NAME" helpstring="関数名を指定します" type="string" retuired="true" />
<named name="extract" helpstring="依存関係にある関数セットを vbs ファイルとして出力します。" type="string" retuired="false" />
<named name="list" helpstring="定義される関数一覧を出力します。" type="string" retuired="false" />
<example>cscript skel.wsf //job:deptree {FUNCTION_NAME [/extract] | /list}</example>
</runtime>
<script language="VBScript" src="lib\dumper.vbs"></script>
<script language="VBScript" src="lib\push.vbs"></script>
<script language="VBScript">
<![CDATA[
option explicit

const DELIMITER = "^'<!-- this line works as delimitre -->$"
const DESCRIPTION = "^'(\?|\+|\*|-)*([a-zA-Z_\d]*)\((.*)\)\s*::\s*([a-zA-Z\d, _]*)(\\(.*)\\)*\s*$"
const TRIMPATTERN = ",\s*$"
dim src, fwrite
dim buffer, bufmatch, bufdic, buf
dim deps : set deps = createobject("scripting.dictionary")
dim called : set called = createobject("scripting.dictionary")
dim funcs : set funcs = createobject("scripting.dictionary")
dim rgp : set rgp = new regexp
dim flg : flg = false
dim afso : set afso = createobject("scripting.filesystemobject")
set src = afso.getfile(wscript.scriptfullname).openastextstream(1)

'read own
do until src.atendofstream
	buffer = src.readline
	rgp.pattern = DELIMITER
	if rgp.test(buffer) then
		flg = not flg
	end if
	if flg then
		rgp.pattern = DESCRIPTION
		if rgp.test(buffer) then
			set bufmatch = rgp.execute(buffer)
			set bufdic = createobject("scripting.dictionary")
			call bufdic.add("raw", buffer)
			call bufdic.add("type", bufmatch(0).submatches(0))
			call bufdic.add("name", bufmatch(0).submatches(1))
			rgp.pattern = TRIMPATTERN
			call bufdic.add("args", split(replace(rgp.replace(bufmatch(0).submatches(2),"")," ",""),","))
			call bufdic.add("deps", split(replace(rgp.replace(bufmatch(0).submatches(3),"")," ",""),","))
			call bufdic.add("description", bufmatch(0).submatches(5))
			call funcs.add(bufmatch(0).submatches(1), src.readline)
			call deps.add(bufmatch(0).submatches(1), bufdic)
		end if
	end if
loop

dim a : a = array()
if wscript.arguments.named.exists("list") then
	for each buffer in deps
		call push(a,buffer)
	next
	call qsort(a,0,ubound(a))
	for each buffer in a
		cstdw buffer&", "
	next
	wscript.quit(0)
end if

if wscript.arguments.unnamed.count < 1 then
	cerr "missing arguments"
	wscript.arguments.showusage
	wscript.quit(1)
end if

if not deps.exists(wscript.arguments.unnamed(0)) then
	cstd wscript.arguments.unnamed(0)&"() is not defined."
	wscript.quit(0)
end if

'show dependence
cstd(wscript.arguments.unnamed(0)&"() depend on:")
call tree(0, wscript.arguments.unnamed(0), deps(wscript.arguments.unnamed(0))("deps"))

'show applied to 
cstd("")
cstd(wscript.arguments.unnamed(0)&"() applied to:")
for each buffer in deps
	for each buf in deps(buffer)("deps")
		if buf = wscript.arguments.unnamed(0) then
			cstd " "&buffer&"()"
		end if
	next
next

if wscript.arguments.named.exists("extract") then
	set fwrite = afso.opentextfile(wscript.arguments.unnamed(0)&".vbs", 2, true)
	for each buffer in called
		if funcs.exists(buffer) then
			fwrite.writeline(deps(buffer)("raw"))
			fwrite.writeline(funcs(buffer))
		else
			cstd "'missing "&buffer&"()"
			fwrite.writeline("'missing "&buffer&"()")
		end if
	next
	cstd("")
	cstd("write out '"&wscript.arguments.unnamed(0)&"' function and dependencies to "&wscript.arguments.unnamed(0)&".vbs")
end if




wscript.quit(0)
'==functions are here==
function cstd(s) : wscript.stdout.writeline(s) : end function
function cstdw(s) : wscript.stdout.write(s) : end function
function cerr(s) : wscript.stderr.writeline("[ERR ] "&s) : end function
function tree(i, fn, dp)
	dim f
	if not called.exists(fn) then
		call called.add(fn, fn)
	end if
	cstd string(i," ")&fn&"()"
	for each f in dp
		if not called.exists(f) then
			if deps.exists(f) then
				call tree(i+1, f, deps(f)("deps"))
			else
				rgp.pattern = "[A-Z_][A-Z_0-9]*"
				if rgp.test(f) then
					cstd string(i+1," ")&f&" [CONST]"
				else
					cstd string(i+1," ")&f&"() [UNDEFINED]"
					cstd "[ERR] undefined function. "&f&"()"
				end if
			end if
		else
			cstd string(i+1," ")&f&"() ..."
		end if
	next
end function
]]>
</script>
</job>
</package>
