<?xml version="1.0" encoding="Shift_JIS" standalone="yes" ?>
<package>
<job error="true" debug="false">
<script language="VBScript">
<![CDATA[
option explicit
'<!-- this line works as delimitre -->

'/* POLICIES
'    * all of messages of function write out to stdout or stderr.
'    * arguments are not be changed.
'    
'    # design
'    "FUNCTIONS_" affix applied to all of functions.
'    "FUNCTION_" affix applied to own function. 
'    cerr() has FUNCTION_CERR_ERRORLEVEL := (0,1,2) = (noerr, standard, debug)
'    f*() file utility always allow path-string/file.path argument
'    
'    # function returns
'      return void
'    + return value (string, array, etc.)
'    * return pointer (object)
'    - return value or pointer
'    ? return boolean 
'
'    function has sticky comment := RETURN_TYPE FUNCTION_NAME(ARG_TYPE, ...) :: depend_FUNCTION_NAME, ... \COMMENT,...\
'    
'    # typename
'    string, boolean, variable, variant() as array, dictionary, OBJECTNAME(*) as object, * as anything
'
'    skel option
'    /debug      : display checked function by valid_arguments()
'    /config     : set configname, default name defined skelconfname()
'    /configid   : set config id for read, default is unset
'    /notypecast : set uncast(string) value to config while read config
'    
'*/

'global definitions ====================================
CONST MATH_PI = 3.14159265358979
CONST NEGATIVE_INFINITY = &H80000000
CONST POSITIVE_INFINITY = &H7FFFFFFF
'INTMAX cint(2^15-1), 
'INTMIN cint(-2^15), 
'LONGMAX clng(2^31-1), 
'LONGMIN clng(-2^32), hex(-2^31)
'for Errors --------------------------------------------
CONST ERR_FUNCTIONARG                        = 1
CONST ERR_FUNCTIONARG_NOTMATCHED             = 2
CONST ERR_FUNCTION_PADDING                   = 10
CONST ERR_FUNCTION_S2A                       = 11
CONST ERR_FUNCTION_FXML                      = 12
CONST ERR_FUNCTION_F2A                       = 13
CONST ERR_FUNCTION_F2V                       = 14
CONST ERR_FUNCTION_F2D                       = 15
CONST ERR_FUNCTION_ARRAY_GRAB                = 16
CONST ERR_FUNCTION_CNUM                      = 17
CONST ERR_FUNCTION_SL                        = 18
CONST ERR_FUNCTION_EVENTLOG                  = 19
CONST ERR_FUNCTION_SELECTFOLDER              = 20
CONST ERR_FUNCTION_FHEADN                    = 30
CONST ERR_FUNCTION_FTAILN                    = 31
CONST ERR_FUNCTION_FCAT                      = 32
CONST ERR_FUNCTION_FCUT                      = 33
CONST ERR_FUNCTION_FCLEANUP                  = 34
CONST ERR_FUNCTION_FGREP                     = 35
CONST ERR_FUNCTION_SKELCONFIGNAME            = 50
CONST ERR_FUNCTION_SETCONFIG                 = 51
'for Functions -----------------------------------------
CONST FUNCTIONS_ARGUMENTSTYPE_CHECK          = true
CONST FUNCTIONS_UNIXTIME_BASIS               = #1970/01/01 00:00:00#

CONST FUNCTION_EVENTLOG_SUCCESS              = 0
CONST FUNCTION_EVENTLOG_ERROR                = 1
CONST FUNCTION_EVENTLOG_WARNING              = 2
CONST FUNCTION_EVENTLOG_INFORMATION          = 4
CONST FUNCTION_EVENTLOG_AUDIT_SUCCESS        = 8
CONST FUNCTION_EVENTLOG_AUDIT_FAILURE        = 16
CONST FUNCTION_NEWCMD_WAITTIME               = 1000
CONST FUNCTION_CMDKEY_WAITTIME               = 100
CONST FUNCTION_DICTIONARY_FORMAT             = "^{\s*([^,][^,]*)\s*=>\s*([^,][^,]*)\s*(,\s*([^,][^,]*)\s*=>\s*([^,][^,]*)\s*){0,}}$"
CONST FUNCTION_PMAILER_SCHEMA                = "http://schemas.microsoft.com/cdo/configuration"
'suspending --------------------------------------------
CONST CLASS_WM_TERMINATE_WAITTIME            = 1000
CONST FUNCTION_CONFIGURE_SET_EMPTY           = false
'suspending --------------------------------------------


'global variables ======================================
'for skel ----------------------------------------------
dim CSCRIPTLAUNCH                            'if launched by 'cscript', set value.
'for Functions -----------------------------------------
'(flog) ------------------------------------------------
dim FUNCTION_FLOG_TYPENAME                   'flog0 -> logged to console (and echo(), echon() function will be set to disable)
                                             'flog1 -> logged to `FUNCTION_FLOG_FILENAME`.log (no log-rotate)
                                             'flog2 -> logged to "./yyyymmdd.log"
                                             'flog3 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated at each execution
                                             'flog4 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated at each day
                                             'flog5 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated at each size
                                             'flog6 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated pattern by FUNCTION_FLOG_ROTATEPATTERN
                                             'if set /logbase option, adopt aan("logbase").log for log-filename on flog[1345]
    FUNCTION_FLOG_TYPENAME                   = "flog0"
dim FUNCTOIN_FLOG_LOGDIR                     'default log directory is created on same path of script.
    FUNCTOIN_FLOG_LOGDIR                     = wscript.createobject("scripting.filesystemobject").buildpath(wscript.createobject("scripting.filesystemobject").getparentfoldername(wscript.scriptfullname), "log")
dim FUNCTION_FLOG_FILENAME                   'default log filename is `FUNCTOIN_FLOG_LOGDIR`\`scriptname`.log set by flogname() function
    FUNCTION_FLOG_FILENAME                   = empty
dim FUNCTION_FLOG_EPID                       'emulated pid
dim FUNCTION_FLOG_ROTATE_MAXCOUNT
		FUNCTION_FLOG_ROTATE_MAXCOUNT            = 10
dim FUNCTION_FLOG_ROTATE_MAXSIZE
		FUNCTION_FLOG_ROTATE_MAXSIZE             = 1048576
dim FUNCTION_FLOG_ROTATE_PATTERN 
		FUNCTION_FLOG_ROTATE_PATTERN             = "yyyynnddHH"
'(datetime) --------------------------------------------
dim FUNCTION_DATETIME_TYPENAME               'datetime0 -> 100114165801
                                             'datetime1 -> 2010/11/41 16:58:01.12
                                             'datetime2 -> 2010/11/41 16:58:01
                                             'datetime3 -> 20101141165801
    FUNCTION_DATETIME_TYPENAME               = "datetime1"
'(skelconf) --------------------------------------------
dim FUNCTOIN_SKELCONFIGNAME_CONFDIR          'default log directory is created on same path of script.
    FUNCTOIN_SKELCONFIGNAME_CONFDIR          = wscript.createobject("scripting.filesystemobject").buildpath(wscript.createobject("scripting.filesystemobject").getparentfoldername(wscript.scriptfullname), "conf")
'(else) ------------------------------------------------
dim FUNCTION_ECMD_EXT
		FUNCTION_ECMD_EXT                        = array("",".com",".exe",".bat",".cmd",".vbs",".js",".jar",".wsf")
dim FUNCTION_CERR_ERRORLEVEL
		FUNCTION_CERR_ERRORLEVEL                 = 1
dim FUNCTION_DUMPER_LABEL
		FUNCTION_DUMPER_LABEL                    = "(dumper) "
dim FUNCTION_DUMPER_LEVEL
		FUNCTION_DUMPER_LEVEL                    = 0
dim FUNCTION_FLOG_INIT                       'if called 'flog()', set value.
dim FUNCTION_FCLEANUP_BLOCK_REMOVE
    FUNCTION_FCLEANUP_BLOCK_REMOVE           = array(array("/\*","\*/")) 'array( pattern1(start, end), pattern2()... )
dim FUNCTION_FCLEANUP_LINE_REMOVE
    FUNCTION_FCLEANUP_LINE_REMOVE            = array("(#|'|//|--|/\*)") 'array( pattern1, pattern2... )
dim FUNCTION_FCLEANUP_LINE_REMOVE2
    FUNCTION_FCLEANUP_LINE_REMOVE2           = array("(//|--)") 'array( pattern1, pattern2... )
dim FUNCTION_FCLEANUP_LINE_REMOVE3
    FUNCTION_FCLEANUP_LINE_REMOVE3           = array("'","#") 'array( pattern1, pattern2... )
dim FUNCTION_FCLEANUP_STRING_BRACE
    FUNCTION_FCLEANUP_STRING_BRACE           = """"
dim FUNCTION_TH_LIMITCHECK_CPUCOUNT          'if you want to change value, replace value to number or 'iif(env("%NUMBER_OF_PROCESSORS%")="%NUMBER_OF_PROCESSORS%", 2, cint(env("%NUMBER_OF_PROCESSORS%")))' 
    FUNCTION_TH_LIMITCHECK_CPUCOUNT          = cint(2)

'= functions ='=========================================
'# checker #
'?valid_arguments(string, array, array) :: FUNCTIONS_ARGUMENTSTYPE_CHECK, cerr, ERR_FUNCTIONARG_  \this function is primitive so do not use userfunctions (exclude cout,cerr) in this.\
function valid_arguments(f, a, b) : dim i,c : valid_arguments = true : dim af,at : af = "" : at = "" : if not FUNCTIONS_ARGUMENTSTYPE_CHECK then : exit function : end if : for each c in a : af = af&typename(c)&", " : next : for each c in b : at = at&c&", " : next : af = left(af,len(af)-2) : at = left(at,len(at)-2) : if wscript.arguments.named.exists("debug") then : cout( f ) : end if : if ubound(a) = ubound(b) then : for i=0 to ubound(a) : if not instr(replace(replace(replace(replace(b(i),"mail","imessage"),"numeric","integer/long/single/float/double"),"array","variant()"),"value","integer/long/float/double/string/boolean/single/currency/byte"), lcase(typename(a(i))))>0 and not b(i) = "*" then : cerr("(valid_arguments) function '"&f&"()' required ("&at&"), not matched ("&af&")") : err.raise ERR_FUNCTIONARG_NOTMATCHED, f&"()","ERR_FUNCTIONARG_NOTMATCHED"  : end if : next : else : cerr("(valid_arguments) function '"&f&"()' required ("&at&")") : err.raise ERR_FUNCTIONARG, f&"()","ERR_FUNCTIONARG"  : end if : end function : 

'# evaluation #
'?e(string/empty) :: valid_arguments, afso \(file_path)\
function e(s) : call valid_arguments("e", array(s), array("string/empty/file")) : e = afso.fileexists(s) : end function
'?ef(string/empty) :: valid_arguments, afso \(folder_path)\
function ef(s) : call valid_arguments("ef", array(s), array("string/empty/folder")) : ef = afso.folderexists(s) : end function
'?ea(string/empty) :: valid_arguments, ea \(named_argument)\
function ea(s) : call valid_arguments("ea", array(s), array("string/empty")) : ea = aarg.named.exists(s) : end function
'?eau(string/empty) :: valid_arguments, ea, aan \(named_argument) is exists and have length\
function eau(s) : call valid_arguments("eau",array(s),array("string/empty")) : eau = (ea(s) and len(aan(s))>0) : end function
'?ed(dictionary, string) :: valid_arguments \(dictionary, key_string)\
function ed(d, s) : call valid_arguments("ed",array(d,s),array("dictionary","value")) : ed = d.exists(s) : end function
'+ecmd(string) :: valid_arguments, FUNCTION_ECMD_EXT, buildpath \(command_string), search command and if found, returns command file path\
function ecmd(s) : dim p, c : call valid_arguments("ecmd",array(s),array("string")) : for each p in split(env("%path%")&";.\",";") : for each c in FUNCTION_ECMD_EXT : if e(buildpath(p,s&c)) then : ecmd = buildpath(p,s&c) : exit function : end if : next : next : end function
'--
'?iscscript() :: filename \launched by cscript?\
function iscscript() : iscscript = (instr(lcase(filename(wscript.fullname)),"cscript.exe")>0) : end function
'?iscmd(string) :: valid_arguments, iif, ecmd \(command_string), search command for each %path% and current directory.\
function iscmd(s) : call valid_arguments("iscmd",array(s),array("string")) : iscmd = iif(len(ecmd(s))>0,true,false) : end function
'-iif(boolean, *, *) :: valid_arguments, bind \immediate if\
function iif(c,t,f) : call valid_arguments("iif",array(c,t,f),array("boolean","*","*")) : if (c) then : call bind(iif,t) : else : call bind(iif,f) : end if : end function
'?isinteger(*) :: \\
function isinteger(v) : isinteger = cbool(vartype(v) = vbInteger) : end function
'?isint(*) :: isinteger \alias to isinteger()\
function isint(v) : isint = isinteger(v) : end function
'?islong(*) :: \\
function islong(v) : islong = cbool(vartype(v) = vbLong) : end function
'?issingle(*) :: \\
function issingle(v) : issingle = cbool(vartype(v) = vbSingle) : end function
'?isdouble(*) :: \\
function isdouble(v) : isdouble = cbool(vartype(v) = vbDouble) : end function
'?iscurrency(*) :: \\
function iscurrency(v) : iscurrency = cbool(vartype(v) = vbCurrency) : end function
'?isstring(*) :: \\
function isstring(v) : isstring = cbool(vartype(v) = vbString) : end function
'?iserror(*) :: \\
function iserror(v) : iserror = cbool(vartype(v) = vbError) : end function
'?isboolean(*) :: \\
function isboolean(v) : isboolean = cbool(vartype(v) = vbBoolean) : end function
'?isvariant(*) :: \\
function isvariant(v) : isvariant = cbool(vartype(v) = vbVariant) : end function
'?isdataobject(*) :: \\
function isdataobject(v) : isdataobject = cbool(vartype(v) = vbDataObject) : end function
'?isbyte(*) :: \\
function isbyte(v) : isbyte = cbool(vartype(v) = vbByte) : end function
'isvalue(*) :: isnothing \value is not array, object, empty, nothing or null\
function isvalue(v) : isvalue = not (isarray(v) or isobject(v) or isempty(v) or isnothing(v) or isnull(v)) : end function
'?isdictionary(*) :: adic \\
function isdictionary(v) : isdictionary = (typename(v) = typename(adic())) : end function
'?ismatch(*) :: getmatch \\
function ismatch(v) : ismatch = (typename(v) = typename(getmatch("",""))) : end function
'?isnothing(*) :: \\
function isnothing(v) : isnothing = (typename(v) = typename(nothing)) : end function
'?iswshexec(*) :: ashell \\
function iswshexec(v) : iswshexec = (typename(v) = typename(ashell.exec("cmd.exe /c rem"))) : end function
'?isdb(*) :: adb \\
function isdb(v) : isdb = (typename(v) = typename(adb())) : end function
'?isrgp(*) :: rgp \\
function isrgp(o) : isrgp = (typename(o) = typename(rgp(""))) : end function
'?issubmatch(*) :: getmatch \\
function issubmatch(o) : issubmatch = (typename(o) = typename(getmatch("t","(t)")(0).submatches)) : end function
'?isfile(*) :: afso \\
function isfile(o) : isfile = (typename(o) = typename(afso.getfile(wscript.scriptfullname))) : end function
'?isfolder(*) :: afso \\
function isfolder(o): isfolder = (typename(o) = typename(afso.getfolder(afso.getparentfoldername(wscript.scriptfullname)))) : end function
'?istextstream(*) :: ftsread \\
function istextstream(o) : istextstream = (typename(o) = typename(ftsread(wscript.scriptfullname))) : end function
'?isstream(*) :: fsread \\
function isstream(o) : isstream = (typename(o) = typename(fsread(wscript.scriptfullname))) : end function
'?isxml(*) :: strcmp, axml \\
function isxml(o) : isxml = (typename(o) = typename(axml())) : end function
'?isxmlchild(*) :: xml \\
function isxmlchild(o) : isxmlchild = (typename(o) = typename(xml("<a/>").childnodes)) : end function
'?ismail(*) :: amail \\
function ismail(m) : dim a : set a = amail() : ismail = false : if isnothing(a) then : exit function : else : ismail = (typename(m) = typename(a)) : end if : end function

'--
'?isprintable(*) :: isvalue \\
function isprintable(v) : isprintable = isvalue(v) : end function
'?isdirectory(string) :: ef \alias of ef()\
function isdirectory(s) : isdirectory = ef(s) : end function
'?isinarray(array,value) :: valid_arguments, isvalue, cerr \search value in array\
function isinarray(a,v) : dim b : call valid_arguments("isinarray",array(a,v),array("array","value")) : isinarray = false : for each b in a : if isvalue(b) then : if b = v then : isinarray = true : exit function : end if : else : cerr("(isinarray) found not value in array, skipped.") : end if : next : end function
'?isinarray_obj(array, *) :: valid_arguments \search obj by typename in array\
function isinarray_obj(a,o) : dim b : call valid_arguments("isinarray_obj", array(a,o), array("array","*")) : isinarray_obj = false : for each b in a : if typename(b) = typename(o) then : isinarray_obj = true : exit function : end if : next : end function
'?isinarray_string(array, string/numeric) :: valid_arguments, isstring, rmatch, cerr \(array, regexp_string)search string in array\
function isinarray_string(a,s) : dim b : isinarray_string = false : call valid_arguments("isinarray_string",array(a,s),array("array","string")) : for each b in a : if isstring(b) then : if rmatch(b,s) then : isinarray_string = true : exit function : end if : else : cerr("(isinarray_string) found '"&typename(b)&"' in array, skipped.") : end if : next : end function
'?isindictionary(dictionary, value) :: valid_argumens, isvalue, cerr \search value in dictionary\
function isindictionary(d,v) : dim b : call valid_arguments("isindictionary",array(d,v),array("dictionary","value")) : isindictionary = false : for each b in d : if isvalue(b) then : if d(b) = v then : isindictionary = true : exit function : end if : else : cerr("(isindictionary) found not value in dictionary, skipped.") : end if : next : end function
'?isindictionary_obj(dictionary, *) :: valid_arguments \search obj by typename in dictionary\
function isindictionary_obj(d,o) : dim b : isindictionary_obj = false : call valid_arguments("isindictionay_obj",array(d,o),array("dictionary","*")) : for each b in d : if typename(d(b)) = typename(o) then : isindictionary_obj = true : exit function : end if : next : end function
'?isindictionary_string(dictionary, string/numeric) :: valid_arguments, isstring, rmatch, cerr \(dictionary, regexp_string) search string in dictionary\
function isindictionary_string(d,s) : dim b : isindictionary_string = false : call valid_arguments("isindictionary_string",array(d,s),array("dictionary","string")) : for each b in d : if isstring(d(b)) then : if rmatch(d(b), s) then : isindictionary_string = true : exit function : end if : else : cerr("(isindictionary_string) found '"&typename(d(b))&"' in dictionary, skipped.") : end if : next : end function
'--
'?isroot(*) :: valid_arguments, isfolder, ef, afso \isrootfolder? \
function isroot(so) : call valid_arguments("isroot",array(so),array("folder/string")) : if isfolder(so) then : isroot = so.isrootfolder : else : if ef(so) then : isroot = afso.getfolder(so).isrootfolder : else : cerr("(isroot) not exists folder '"&so&"'.") : isroot = false : end if : end if : end function
'?isping(string) :: valid_arguments, texec \is ping responce?\
function isping(s) : call valid_arguments("isping",array(s),array("string")) : isping = false : if wexec("cmd /c ping.exe -w 1 -n 1 -4 "&s&" >nul ").exitcode = 0 then : isping = true : end if : end function
'?isusewmi() :: \can use wmi?\
function isusewmi() : on error resume next : call getobject("winmgmts:\\.\root\cimv2") : if err.number <> 0 then : isusewmi = false : err.clear : else : isusewmi = true : end if : end function
'--
'?iswshexec_array(array) :: valid_arguments, iswshexec \for th_* functions, check all values are wshexec object\
function iswshexec_array(a) : dim o : call valid_arguments("iswshexec_array",array(a),array("array")) : for each o in a : if not iswshexec(o) then : iswshexec_array = false : exit function : end if : next : iswshexec_array = true : end function

'# bind #
'bind(variable,*) :: \\
function bind( k,byval v) : if(isobject(v)) then : set k = v : else k = v : end if : end function
'?swap(*, *) :: valid_arguments, bind \swap variable, returns true\
function swap(a,b) : dim t : call valid_arguments("swap",array(a,b),array("*","*")) : call bind(t,a) : call bind(a,b) : call bind(b,t) : swap = true : end function : 


'# regular expression #
'*rgo(string, string) :: valid_arguments \(pattern, options[igo])\
function rgo(p,o) : call valid_arguments("rgo",array(p,o),array("string","string")) : set rgo = new regexp : rgo.pattern = p : rgo.ignorecase = (instr(o,"i")>0) : rgo.global = (instr(o,"g")>0) : rgo.multiline = (instr(o,"o")>0) : end function
'*rgp(string) :: valid_arguments \(pattern)\
function rgp(p) : call valid_arguments("rgp",array(p),array("string")) : set rgp = new regexp : rgp.pattern = p : end function
'?rmatch(string, string) :: valid_arguments, rgp \(target, pattern)\
function rmatch(s,p) : call valid_arguments("rmatch",array(s,p),array("string","string")) : rmatch = rgp(p).test(s) : end function
'?rmatchi(string, string) :: valid_arguments, rgo \(target, pattern)\
function rmatchi(s,p) : call valid_arguments("rmatchi",array(s,p),array("string","string")) : rmatchi = rgo(p,"i").test(s) : end function
'*getmatch(string, string) :: valid_arguments, rgo \(target, pattern)\
function getmatch(s,p) : call valid_arguments("getmatch",array(s,p),array("string","string")) : set getmatch = rgo(p,"g").execute(s) : end function
'*getsubmatch(string, string) :: valid_arguments, getmatch, \(target, pattern), pattern must inlcude ()\
function getsubmatch(s,p) : dim i,g : call valid_arguments("getsubmatch",array(s,p),array("string","string")) : set g = getmatch(s,p) : if (g.count>0) then : for i=0 to g.count-1 : if (g(i).submatches.count>0) then : set getsubmatch = g(i).submatches : end if : next : end if : end function
'+rreplace(string, string, string) :: valid_arguments, rgo \(target, pattern, replacement)\
function rreplace(s,p,r) : call valid_arguments("rreplace",array(s,p,r),array("string","string","string")) : rreplace = rgo(p,"g").replace(s,r) : end function
'+rremove(string, string) :: valid_arguments, rreplace \(target, removement)\
function rremove(s,p) : call valid_arguments("rreplace",array(s,p),array("string","string")) : rremove = rreplace(s,p,"") : end function

'# strings #
'?strcmp(string, string) :: valid_arguments \strcmp returns loose match result, strcmp("Test","test") => true\
function strcmp(s,t) : strcmp = false : call valid_arguments("strcmp",array(s,t),array("string","string")) : strcmp = (lcase(s) = lcase(t)) : end function
'?strcmpr(string, string) :: valid_arguments \rstrcmp returns strict match result, rstrcmp("Test","test") => false\
function strcmpr(s,t) : strcmpr = false : call valid_arguments("strcmpr",array(s,t),array("string","string")) : strcmpr = (s = t) : end function
'--
'+dleft(string, integer/long/single) :: valid_arguments \(target, delete_position) delete from left\
function dleft(s,n) : call valid_arguments("dleft",array(s,n),array("string","integer/long/single")) : if len(s)>n then : dleft = right(s, len(s)-n) : else dleft = "" : end if : end function
'+dright(string, integer/long/single) :: valid_arguments \(target, delete_position) delete from right, equal left()\
function dright(s,n) : call valid_arguments("dright",array(s,n),array("string","integer/long/single")) : if len(s)>n then : dright = left(s, len(s)-n) : else dright = "" : end if : end function
'replicate(string, integer) :: valid_arguments \repeat n times string\
function replicate(s,n) : dim i,b : b = "" : call valid_arguments("replicate",array(s,n),array("string","integer")) : for i=1 to n : b = b&s : next : replicate = b : end function
'+revstr(string) :: reverse \\
function revstr(s) : revstr = reverse(s) : end function
'+reverse(string) :: valid_arguments \\
function reverse(s) : call valid_arguments("reverse",array(s),array("value")) : reverse = strreverse(s) : end function
'--
'primitive padding
'+ppadding(value, string, integer, boolean) :: valid_arguments, cerr \(target, padding_char, length, direction) returns string.\
function ppadding(s,c,n,f) : call valid_arguments("ppadding",array(s,c,n,f),array("value","string","integer","boolean")) : if len(cstr(s))>=n then : ppadding = cstr(s) : else : if len(c)>1 then : cerr("(ppadding) padding string has length("&len(c)&"), use first char.") : end if : if len(c)>0 and n>len(cstr(s)) then : if f then : ppadding = string(n-len(cstr(s)),c)&s : else : ppadding = s&string(n-len(cstr(s)),c) : end if : else : cerr("(ppadding) invalid padding string") : err.raise ERR_FUNCTION_PADDING, "use empty string for padding","ERR_FUNCTION_PADDING"  : end if : end if : end function
'+padding(value, integer) :: ppadding \padding by " "\
function padding(s,n) : padding = ppadding(s," ",n,true) : end function
'+padding_right(value, string, integer) :: ppadding \padding from right, alias\
function padding_right(s,c,n) : padding_right = ppadding(s,c,n,false) : end function
'+padding_left(value, string, integer) :: ppadding \padding from left, alias\
function padding_left(s,c,n) : padding_left = ppadding(s,c,n,true) : end function
'--
'+divide(string, string) :: valid_arguments \(target, divide_string) divide target by first found position. returns array()\
function divide(s,c) : call valid_arguments("divide",array(s,c),array("string","string")) : if instr(s,c)>0 then : divide = array(split(s,c)(0), dleft(s,len(split(s,c)(0)&c))) : else : divide = array(s,"") : end if : end function
'e.g. String( "test string" ) => String(test string), String( "te st" .) => String("te st" .)
'+btrim(string) :: valid_arguments, rmatch, getsubmatch \brackets trim\
function btrim(s) : dim b : call valid_arguments("btrim",array(s),array("string")) : b = trim(s) : if rmatch(b,"^""(.*)""$") then : b = getsubmatch(b,"^""(.*)""$")(0) : end if : btrim = b : end function
'--
'+chop(string) :: valid_arguments, dright \returns removed string, alias to dright()\
function chop(s) : call valid_arguments("chop",array(s),array("string")) : chop = dright(s,1) : end function
'+chomp(string) :: valid_arguments, dright \returns removed string\
function chomp(s) : call valid_arguments("chomp",array(s),array("string")) : if right(s,2) = vbnewline then : chomp = dright(s,2) : else : chomp = s : end if : end function
'*byref_chop(string) :: valid_arguments, dright \returns string, perl like. string is modified.\
function byref_chop(byref s) : call valid_arguments("byref_chop",array(s),array("string")) : byref_chop = right(s,1) : s = dright(s,1) : end function
'+byref_chomp(string) :: valid_arguments, dright \returns numeric, perl like. string is modified.\
function byref_chomp(byref s) : call valid_arguments("byref_chomp",array(s),array("string")) : if right(s,2) = vbnewline then : byref_chomp = len(right(s,2)) : s = dright(s,2) : else : byref_chomp = "" : end if : end function

'# transform #
'e.g. s2a("test, test1, test21",",") => array("test"," test1"," test21")
'e.g. s2a("test, test1, test21",3) => ("tes","t, ","tes","t1," ... "1  ")
'+s2a(string, string/integer) :: valid_arguments, isstring, push, dleft, ERR_FUNCTION_S2A \(target, delimiter_string/point) string to array\
function s2a(s, d) : dim b,a : a = array() : call valid_arguments("s2a",array(s,d),array("string","string/integer")) : if isstring(d) then : s2a = split(s,d) : else : b = s : if d>0 then : do until len(b)<=d : call push(a,left(b,d)) : b = dleft(b,d) : loop : if len(b)>0 then : call push(a,b&string(d-len(b)," ")) : end if : s2a = a : else : cerr("(s2a) invalid split length.") : err.raise ERR_FUNCTION_S2A, "invalid split length","ERR_FUNCTION_S2A" : end if : end if : end function
'+f2a(file/string) :: valid_arguments, isfile, e, cerr, ERR_FUNCTION_F2A, ftsread, push \(file/path_string) file to array\
function f2a(fn) : dim f, o, a : a = array() : call valid_arguments("f2a",array(fn),array("file/string")) : if isfile(fn) then : f = fn.path : else : f = fn : end if : if not e(f) then : cerr("(f2a) '"&f&"' is missing ") : err.raise ERR_FUNCTION_F2A, "'"&f&"' is missing ", "ERR_FUNCTION_F2A" : end if : set o = ftsread(f) : do until o.atendofstream : call push(a,o.readline) : loop : f2a = a : end function
'+f2v(file/string) :: valid_arguments, isfile, e, ftsread, cerr, ERR_FUNCTION_F2V \(file/path_string) file to variable\
function f2v(fn) : dim f, o, b : b = "" : call valid_arguments("f2v",array(fn),array("file/string")) : if isfile(fn) then : f = fn.path : else : f = fn : end if : if e(f) then : set o = ftsread(f) : do until o.atendofstream : b = b&o.readline&vbnewline : loop : f2v = b : else : cerr("(f2v) '"&f&"' is missing. ") : err.raise ERR_FUNCTION_F2V, "'"&f&"' is missing ", "ERR_FUNCTION_F2V" : end if : end function
'+f2s(file/string) :: a2s, f2a \(file/path_string) file to 1 line string\
function f2s(fn) : f2s = a2s(f2a(fn)," ") : end function
'e.g. au2a() := skel.wsf a b c / /: /:1 => array("a","b","c")
'+au2a() :: aarg, push \unnamed argument to array\
function au2a() : dim b,a : a = array() : for each b in aarg.unnamed : call push(a, b) : next : au2a = a : end function
'e.g. an2a() := skel.wsf a b c / /a /a: /a:1 => array("",empty,"a",empty,"a","","a","1")
'+an2a() :: aarg, push \named argument to array such as (key1, value1, key2, value2 ...)\
function an2a() : dim b,a : a = array() : for each b in aarg.named : call push(a,b) : call push(a,aarg.named(b)) : next : an2a = a : end function

'*f2drs(file/string, string, integer, integer) :: f2d \(filename, array(regexp_pattern, keyno, value_no))\
function f2drs(fn, regexp_pattern, keyno, valno) : call valid_arguments("f2drs",array(fn, regexp_pattern, keyno, valno),array("file/string", "string", "integer", "integer")) : set f2drs = f2d(fn, array(regexp_pattern, keyno, valno)) : end function
'*f2dr(file/string, string, string) :: f2d \(filename, array(regexp_pattern, delim_string))\
function f2dr(fn, regexp_pattern, delim_string) : call valid_arguments("f2dr",array(fn, regexp_pattern, delim_string), array("file/string","string","string")) : set f2dr = f2d(fn, array(regexp_pattern, delim_string)) : end function
'e.g. f2d("test.txt", ",") simple separate with trim
'e.g. f2d("test.txt", array("^.*=.*$","=")) separate with pattarn check and trim
'e.g. f2d("test.txt", array("^(.*)=(.*)$",0,1)) separate with regular expression
'*f2d(file/string, string/array) :: valid_arguments, adic, isfile, e, cerr, ERR_FUNCTION_F2D, ftsread, isstring, divide, dic, rmatch, getmatch, max \(file/path_string, pattern/array("pattern","separator") or array("pattern",key_indicator, value_indicator)))\
function f2d(fn, a) : dim b, f, o, d : call valid_arguments("f2d",array(fn,a),array("file/string","string/array")) : set d = adic() : if isfile(fn) then : f = fn.apth : else : f = fn : end if : if not e(f) then : cerr("(f2d) '"&f&"' is missing.") : err.raise ERR_FUNCTION_F2D, "'"&f&"' is missing.", "ERR_FUNCTION_F2D" : end if : set o = ftsread(f) : do until o.atendofstream : b = o.readline : select case isstring(a) : case true : if instr(b,a)>0 then : b = divide(b, a) : call dic(d, btrim(b(0)), btrim(b(1))) : end if : case else : if rmatch(b, a(0)) then : set b = getmatch(b,a(0)) : if ubound(a)>1 then : if b(0).submatches.count > max(cint(a(1)),cint(a(2))) then : call dic(d, btrim(b(0).submatches(cint(a(1)))), btrim(b(0).submatches(cint(a(2))))) : else : cerr("(f2d) '"&b(0)&"' has unmatched submatch section, can't allocate key/value.") : err.raise ERR_FUNCTION_F2D, "'"&b(0)&"' has unmatched submatch section, can't allocate key/value.", "ERR_FUNCTION_F2D" : end if : else : b = divide(b(0).value, a(1)) : call dic(d, btrim(b(0)), btrim(b(1))) : end if : end if : end select : loop : set f2d = d : end function

'primitive a2s
'+pa2s(array, string) :: valid_arguments \\
function pa2s(a,c) : dim i, s : s = "" : call valid_arguments("pa2s",array(a,c),array("array","string")) : for i=0 to ubound(a)-1 : s = s&a(i)&c : next : s = s&a(i) : pa2s = s : end function
'+a2s(array) :: pa2s \always returns string\
function a2s(a) : a2s = pa2s(a," ") : end function : 
'*a2d(array) :: dictionary \each element's format must meet FUNCTION_DICTIONARY_FORMAT condition.\
function a2d(a) : set a2d = dictionary(a) : end function
'*s2d(string) :: dictionary \string format must meet FUNCTION_DICTIONARY_FORMAT condition.\
function s2d(s) : set s2d = dictionary(s) : end function
'+d2s(dictionary) :: valid_arguments \according to the format FUNCTION_DICTIONARY_FORMAT\
function d2s(d) : dim b, s : s = "{ " : call valid_arguments("d2s",array(d),array("dictionary")) : for each b in d : s = s&""""&b&""" => """&d(b)&""", " : next : s = s&" }" : d2s = s : end function
'+d2a(dictionary) :: valid_arguments, push \according to the format FUNCTION_DICTIONARY_FORMAT\
function d2a(d) : dim b,a : a = array() : call valid_arguments("d2a",array(d),array("dictionary")) : for each b in d : call push(a,""""&b&""" => """&d(b)&"""") : next : d2a = a : end function

'+cast(value, string) :: valid_arguments, cerr \if cannot cast value to type, display error message.\
function cast(v,s) : dim b : call valid_arguments("cast",array(v,s),array("*","string")) : b = lcase(s) : on error resume next : select case b : case "int" : cast = cint(v) : case "integer" : cast = cint(v) : case "str" : cast = cstr(v) : case "string" : cast = cstr(v) : case "date" : cast = cdate(v) : case "time" : cast = cdate(v) : case "datetime" : cast = cdate(v) : case "lng" : cast = clng(v) : case "long" : cast = clng(v) : case "sng" : cast = csng(v) : case "single" : cast = csng(v) : case "dbl" : cast = cdbl(v) : case "double" : cast = cdbl(v) : case "bool" : cast = cbool(v) : case "boolean" : cast = cbool(v) : case "byte" : cast = cbyte(v) : case "cur" : cast = ccur(v) : case "currency" : cast = ccur(v) : case "money" : cast = ccur(v) : case "null" : cast = null : case "empty" : cast = empty : case else : cast = empty : end select : if err.number <> 0 then : cerr("(cast) can't cast to '"&s&"'.") : err.clear : end if : end function
'cnum(value) :: valid_arguments, rmatch, cerr, ERR_FUNCTION_CNUM \cast NUMER-STRING "^\s*-*\d*(\.\d*)*\s*$" to number.\
function cnum(o) : call valid_arguments("cnum",array(o),array("value")) : if rmatch(o, "^\s*-*\d*(\.\d*)*\s*$") then : if rmatch(o,"\.") then : cnum = cdbl(o) : else : on error resume next : cnum = cint(o) : if err.number <> 0 then : err.clear : cnum = clng(o) : if err.number <> 0 then : err.clear : cnum = 0 : end if : end if : end if : else : cerr("(cnum) argument is not number string") : err.raise ERR_FUNCTION_CNUM, "argument is not number string", "ERR_FUNCTION_CNUM" : end if : end function

'# calculation #
'+pfloor(numeric, numeric) :: valid_arguments, iif \\
function pfloor(n,d) : call valid_arguments("pfloor",array(n,d), array("numeric", "numeric")) : pfloor = iif(n<fix(n),(fix(n/d)-1)*d,fix(n/d)*d) : end function
'+floor(numeric) :: pfloor \\
function floor(n) : floor = pfloor(n,1) : end function
'primitive ceil
'+pceil(numeric, numeric) :: valid_arguments, iif \\
function pceil(n,d) : call valid_arguments("pceil",array(n,d), array("numeric", "numeric")) : pceil = iif(n<fix(n),fix(n/d)*d,(fix(n/d)+1)*d) : end function : 
'+ceil(numeric) :: pceil \\
function ceil(n) : ceil = pceil(n,1) : end function
'+sstep(numeric) :: hcstep \simple step function, sstep(0) = 1.0 \
function sstep(n) : sstep = hcstep(1.0,n) : end function
'+ustep(numeric) :: hcstep \unit step function, ustep(0) = 0.0 \
function ustep(n) : ustep = hcstep(0.0,n) : end function
'+hstep(numeric) :: hcstep \Heaviside step function, hstep(0) = 0.5 \
function hstep(n) : hstep = hcstep(0.5,n) : end function
'+hcstep(numeric) :: sustep \Heaviside(0) step function\
function hcstep(z,n) : hcstep = sustep(0.0,z,n) : end function
'primitive *step
'+sustep(numeric, numeric, numeric) :: valid_arguments \shift unit step function\
function sustep(t, z, n) : call valid_arguments("sustep",array(t,z,n),array("numeric","numeric","numeric")) : if n>t then : sustep = 1.0 : else : if n<t then : sustep = 0.0 : else : sustep = z : end if : end if : end function
'+tarai(numeric, numeric, numeric) :: \Takenaka function, do arguments check before use\
function tarai(x,y,z) : if (x<=y) then : tarai = y : else : tarai = tarai(tarai(x-1,y,z),tarai(y-1,z,x),tarai(z-1,x,y)) : end if : end function
'+tak(numeric, numeric, numeric) :: \John McCarthy function, do arguments check before use\
function tak(x,y,z) : if (x<=y) then : tak = z : else : tak = tak(tak(x-1,y,z),tak(y-1,z,x),tak(z-1,x,y)) : end if : end function
'--
'+max(numeric, numeric) :: valid_arguments, iif \\
function max(v,r) : call valid_arguments("max",array(v,r),array("numeric","numeric")) : max = iif(v > r, v ,r) : end function
'+min(numeric, numeric) :: valid_arguments, iif \\
function min(v,r) : call valid_arguments("min",array(v,r),array("numeric","numeric")) : min = iif(v < r, v ,r) : end function
'+max_array(array) :: NEGATIVE_INFINITY, valid_arguments, max \search max number in array, not allowed string\
function max_inarray(a) : dim b,r : r = NEGATIVE_INFINITY : call valid_arguments("max_inarray",array(a),array("array")) : for each b in a : if isnumeric(b) then : r = max(r,b) : end if : next : max_inarray = r : end function
'+min_inarray(array) :: POSITIVE_INFINITY, valid_arguments, min \search min number in array, not allowed string\
function min_inarray(a) : dim b,r : r = POSITIVE_INFINITY : call valid_arguments("min_inarray",array(a),array("array")) : for each b in a : if isnumeric(b) then : r = min(r,b) : end if : next : min_inarray = r : end function
'+roundup(numeric,numeric) :: valid_arguments \\
function roundup(n,d) : call valid_arguments("roundup",array(n,d),array("numeric","numeric")) : roundup = round(n + 0.1^(d+1)*5, d) : end function
'+rounddown(numeric,numeric) :: valid_arguments \\
function rounddown(n,d) : call valid_arguments("rounddwon",array(n,d),array("numeric","numeric")) : rounddown = round(n - 0.1^(d+1)*5, d) : end function
'--
'sec(numeric) :: \secont\
function sec(x) : sec = 1/cos(x) : end function
'csc(numeric) :: \cosecont\
function csc(x) : csc = 1/sin(x) : end function
'cot(numeric) :: \cotangent\
function cot(x) : cot = 1/tan(x) : end function
'asin(numeric) :: MATH_PI \arc sine -1<=x<=1 \
function asin(x) : if abs(x)=1 then : asin = sgn(x)*MATH_PI/2.0 : else : asin = atn(x/sqr(-x*x+1)) : end if : end function
'acos(numeric) :: MATH_PI \arc cosine -1<=x<=1 \
function acos(x) : if abs(x)=1 then : acos = sgn(x)*MATH_PI/2.0+MATH_PI/2.0 : else : acos = atn(-x/sqr(-x*x+1))+2*atn(1) : end if : end function
'atan(numeric) :: \arc tangent\
function atan(x) : atan = atn(x) : end function
'asec(numeric) :: \arc secont\
function asec(x) : asec = 2*atn(1)-atn(sgn(x)/sqr(x*x-1)) : end function
'acsc(numeric) :: \arc cosecont\
function acsc(x) : acsc = atn(sgn(x)/sqr(x*x-1)) : end function
'acot(numeric) :: \arc cotangent\
function acot(x) : acot = 2*atn(1)-atn(x): end function
'sinh(numeric) :: \hyperbolic sine\
function sinh(x) : sinh = (exp(x)-exp(-x))/2 : end function
'cosh(numeric) :: \hyperbolic cosine\
function cosh(x) : conh = (exp(x)+exp(-x))/2 : end function
'tanh(numeric) :: sinh, conh \hyperbolic tangent\
function tanh(x) : tanh = sinh(x)/conh(x) : end function
'coth(numeric) :: tanh \hyperboric cotangent\
function coth(x) : coth = 1/tanh(x) : end function
'sech(numeric) :: cosh \hyperbolic secont\
function sech(x) : sech = 1/cosh(x) : end function
'csch(numeric) :: sinh \hyerbolic cosecont\
function csch(x) : csch = 1/sinh(x) : end function
'--
'logn(numeric, numeric) :: valid_arguments \ n=x=1 => undefined. \
function logn(n,x) : call valid_arguments("logn",array(n,x),array("numeric","numeric")) : logn = log(x)/log(n) : end function
'log2(x) :: logn \\
function log2(x) : log2 = logn(2,x) : end function
'log10(x) :: logn \\
function log10(x) : log10 = logn(10,x) : end function

'# bit calculation #
'?nor(boolean, boolean) :: isboolean \\
function nor(a,b) : nor = false : if isboolean(a) and isboolean(b) then : nor = not(a or b) : end if : end function
'?b_nor(boolean, boolean) :: nor \\
function b_nor(a,b) : b_nor = nor(a,b) : end function
'?b_not(boolean) :: nor \\
function b_not(a) : b_not = b_nor(a,a) : end function
'?b_and(boolean, boolean) :: nor \\
function b_and(a,b) : b_and = b_nor(b_not(a),b_not(b)) : end function
'?b_or(boolean, boolean) :: nor \\
function b_or(a,b) : b_or = b_not(b_nor(a,b)) : end function
'?b_nand(boolean, boolean) :: nor \\
function b_nand(a,b) : b_nand = b_not(b_and(a,b)) : end function
'?b_xor(boolean, boolean) :: nor \\
function b_xor(a,b) : b_xor = b_or(b_and(b_not(a),b),b_and(a,b_not(b))) : end function
'?b_xnor(boolean, boolean) :: nor \\
function b_xnor(a,b) : b_xnor = b_or(b_and(a,b),b_and(b_not(a),b_not(b))) : end function
'?b_tf(numeric) :: iif \1 returns true else false\
function b_tf(n) : call valid_arguments("b_tf",array(n),array("numeric")) : b_tf = iif(n=1, true, false) : end function
'+b_sl(numeric, integer) :: \arithmetic shift left\
function b_sl(n,k) : call valid_arguments("b_sl",array(n,k),array("numeric","integer")) : b_sl = n*2^k : end function
'+b_sr(numeric, integer) :: \arithmetic shift right\
function b_sr(n,k) : call valid_arguments("b_sr",array(n,k),array("numeric","integer")) : b_sr = n/2^k : end function
'+b_lsl(numeric, integer) :: b_b2n, b_n2b \logical shift left\
function b_lsl(n,k) : call valid_arguments("b_lsl",array(n,k),array("numeric","integer")) : b_lsl = b_b2n(right(b_n2b(n)&string(k,"0"),32)) : end function
'+b_lsr(numeric, integer) :: b_b2n, b_n2b \logical shift right\
function b_lsr(n,k) : call valid_arguments("b_lsl",array(n,k),array("numeric","integer")) : b_lsr = b_b2n(left(string(k,"0")&b_n2b(n),32)) : end function
'--
'+b_n2b(numeric) :: valid_arguments, iif, \number to binary string, no operation with over long range.\
function b_n2b(n) : dim i,s,b : s = "" : call valid_arguments("b_n2b",array(n),array("numeric")) : b = sgn(n)*n : s = iif((sgn(n) = 1),"0","1") : for i=30 to 0 step -1 : if fix(b / 2^i) > 0 then : s = s & "1" : b = b - 2^i : else : s = s & "0" : end if : next : b_n2b = s : end function
'+b_b2n(string) :: valid_arguments, iif, dleft, rmatch \binary string to number, no operation with not binary string.\
function b_b2n(b) : dim c,a,s,i : a = 0 : call valid_arguments("b_b2n",array(b),array("string")) : c = right(string(32,"0")&b,32) : s = iif(left(c,1)=0,1,-1) : c = dleft(c,1) : if rmatch(b,"^[01][01]*$") then : for i=30 to 0 step -1 : a = a+2^i*left(c,1) : c = dleft(c,1) : next : end if : b_b2n = s*a : end function
'+b_print(string) :: valid_arguments, dright \string has always has 32 digit\
function b_print(b) : dim i,c,s : i=1 : s = "" : call valid_arguments("b_print", array(b), array("string")) : for each c in s2a(b,1) : s=s&c : if i mod 4 = 0 then : s=s&" " : end if : i = i+1 : next : b_print = dright(s,1) : end function

'# utilities #
'# system #
'quit(numeric) :: valid_arguments \\
function quit(n) : call valid_arguments("quit",array(n),array("numeric")) : flog("(quit) "&n&"") : wscript.quit(n) : end function
'halt() :: flog, errmsg \\
function halt() : flog("(halt) halted ["&errmsg(err)&"]") : end function
'--
'+eventlog(integer, string) :: valid_arguments, isinarray, FUNCTION_EVENTLOG_, cerr, ashell, ERR_FUNCTION_EVENTLOG \returns write string length, (eventid, string) write to application event log. source by 'WSH'. this function is sub-procedure.\
function eventlog(t,s) : call valid_arguments("eventlog",array(t,s),array("integer","string")) : if not isinarray(array(FUNCTION_EVENTLOG_SUCCESS,FUNCTION_EVENTLOG_ERROR,FUNCTION_EVENTLOG_WARNING,FUNCTION_EVENTLOG_INFORMATION,FUNCTION_EVENTLOG_AUDIT_SUCCESS,FUNCTION_EVENTLOG_AUDIT_FAILURE),t) then : cerr("(eventlog) invalid type '"&t&"', can't allocate eventid.") : err.raise ERR_FUNCTION_EVENTLOG, "invalid type '"&t&"', can't allocate eventid.", "ERR_FUNCTION_EVENTLOG" : else : ashell.logevent t, s : eventlog = flog("(eventlog) write to application eventlog. ['"&t&"', "&s&"]") : end if : end function
'+e_error(string) :: eecho, eventlog \write eventlog with echo\
function e_error(s) : eecho(s) : e_error = eventlog(FUNCTION_EVENTLOG_ERROR, s) : end function
'+e_warn(string) :: wecho, eventlog \write eventlog with echo\
function e_warn(s) : wecho(s) : e_warn = eventlog(FUNCTION_EVENTLOG_WARNING, s) : end function
'+e_info(string) :: iecho, eventlog \write eventlog with echo\
function e_info(s) : iecho(s) : e_info = eventlog(FUNCTION_EVENTLOG_INFORMATION, s) : end function
'+errmsg() :: \use in detected error directive.\
function errmsg() : errmsg = "[ "&err.number&", "&err.description&", "&err.source&" ]" : end function

'# path #
'?isvalidpath(string) :: valid_arguments, dleft, absolutepath, iif, rmatch \is valid path string\
function isvalidpath(s) : dim b : call valid_arguments("isvalidpath",array(s),array("string")) : b = dleft(absolutepath(s),3) : isvalidpath = iif(rmatch(b,"[:/\*\|\?<>""]"),false,true) : end function
'?mkdir(string) :: valid_arguments, absolutepath, isvalidpath, cerr, ef, parentfolder, afso \(path_string), absolutepath marumeru \
function mkdir(s) : dim b : call valid_arguments("mkdir",array(s),array("string")) : b = absolutepath(s) : if not isvalidpath(s) then : cerr("(mkdir) found invalid string in '"&b&"', can't create folder.") : mkdir = false : exit function : end if : if not ef(parentfolder(b)) then : call mkdir(parentfolder(b)) : end if : if not ef(b) then : afso.createfolder(b) : end if : mkdir = ef(absolutepath(s)) : end function
'+basename(value/file/folder) :: valid_arguments, afso \\
function basename(s) : call valid_arguments("basename",array(s),array("value/file/folder")) : basename = afso.getbasename(s) : end function
'+filename(value/file/folder) :: valid_arguments, afso \\
function filename(v) : call valid_arguments("filename",array(v),array("value/file/folder")) : filename = afso.getfilename(v) : end function
'+absolutepath(value/file/folder) :: valid_arguments, afso \\
function absolutepath(v) : call valid_arguments("absolutepath",array(v),array("value/file/folder")) : absolutepath = afso.getabsolutepathname(v) : end function
'+extension(value/file/folder) :: valid_arguments, afso \\
function extension(v) : call valid_arguments("extension",array(v),array("value/file/folder")) : extension = afso.getextensionname(v) : end function
'+parentfolder(value/file/folder) :: valid_arguments, afso \\
function parentfolder(v) : call valid_arguments("parentfolder",array(v),array("value/file/folder")) : parentfolder = afso.getparentfoldername(v) : end function
'+drivename(value/file/folder) :: valid_arguments, afso \\
function drivename(v) : call valid_arguments("drivename",array(v),array("value/file/folder")) : drivename = afso.getdrivename(v) : end function
'+buildpath(value/file/folder,value/file/folder) :: valid_arguments, afso \\
function buildpath(v,s) : call valid_arguments("buildpath",array(v,s),array("value/file/folder","value/file/folder")) : buildpath = afso.buildpath(v,s) : end function
'+scriptname() :: \\
function scriptname() : scriptname = replace(wscript.scriptname,"."&extension(wscript.scriptname),"") : end function

'# random #
'+rndstr(integer) :: valid_arguments, rand \returns random string using char(48-56, 65-90, 97-122)\
function rndstr(n) : dim b,i : b = "" : call valid_arguments("rndstr",array(n),array("integer")) : i = n : randomize(timer) : do while i>0 : select case rand(1,3) : case 1 : b = b&chr(rand(48,56)) : case 2 : b = b&chr(rand(65,90)) : case else : b = b&chr(rand(97,122)) : end select : i=i-1 : loop : rndstr = b : end function
'+rndstrn(integer) :: valid_arguments, rand \returns random string using char(32-126)\
function rndstrn(n) : dim b,i : b = "" : call valid_arguments("rndstrn",array(n),array("integer")) : i = n : randomize(timer) : do while i>0 : b = b&chr(rand(32,126)) : i = i-1 : loop : rndstrn = b : end function
'+rndstrm(integer) :: valid_arguments, rand \returns random string using 2nd argument\
function rndstrm(n,s) : dim b,i,j : b = "" : call valid_arguments("rndstrm",array(n,s),array("integer","string")) : i = n : j = cint(len(s)) : randomize(timer) : do while i>0 : b = b&mid(rand(1,j),1) : i=i-1 : loop : rndstrm = b : end function
'+rand(integer,integer) :: valid_arguments \ (n <= m) \
function rand(n,m) : call valid_arguments("rand",array(n,m),array("integer","integer")) : randomize(timer) : rand = int((m-n+1)*rnd()+n) : end function

'# foreach #
'+foreach_rreplace(array, string, string) :: valid_arguments, push, rreplace \(targets, target, replacement)\
function foreach_rreplace(a, s, t) : dim b, r : r = array() : call valid_arguments("foreach_rreplace",array(a,s,t),array("array","string","string")) : for each b in a : call push(r, rreplace(b, s, t)) : next : foreach_rreplace = r : end function : 
'+foreach_rremove(array, string) : valid_arguments, halt, push, rremove\(targets, removement)\
function foreach_rremove(a, s) : dim b, r : r = array() : call valid_arguments("foreach_rremove",array(a,s),array("array","string")) : for each b in a : call push(r, rremove(b, s)) : next : foreach_rremove = r : end function
'+foreach_typename(array) :: valid_arguments, push, a2s \\
function foreach_typename(a) : dim b,r : r = array : call valid_arguments("foreach_typename", array(a), array("array")) : for each b in a : call push(r, typename(b)) : next : foreach_typename = a2s(r, ", ") : end function

'# skelmisc #
'+skelconfigname() :: eau, aan, ef, buildpath, FUNCTION_SKELCONFIGNAME_CONFDIR, cerr, ERR_FUNCTION_SKELCONFIGNAME, afso \return default configname. if you want another config, use /config option.\
function skelconfigname() : dim b : if eau("config") then : b = aan("config") : else : if ef(FUNCTOIN_FLOG_LOGDIR) then : b = buildpath(FUNCTOIN_SKELCONFIGNAME_CONFDIR,scriptname&".conf") : else : b = scriptname&".conf" : end if : end if : if not e(b) then : cerr("(skelconfigname) '"&b&"' is missing.") : err.raise ERR_FUNCTION_SKELCONFIGNAME, "'"&b&"' is missing.", "ERR_FUNCTION_SKELCONFIGNAME" : end if : set skelconfigname = afso.getfile(b) : end function
'*setconfig(file/string) :: valid_arguments, e, cerr, ERR_FUNCTION_SETCONFIG, adic, iif, ea, aan, fcleanup, rmatch, getsubmatch, dic, skeltypecast, ed, dic, push \read config. see example(conf\skel.configure)\
function setconfig(c) : dim b,d,v,flg : flg = 0 : dim tag_start, tag_end : call valid_arguments("setconfig",array(c),array("file/string")) : if not e(c) then : cerr("(setconfig) '"&c&"' is missing") : err.raise ERR_FUNCTION_SETCONFIG, "'"&c&"' is missing", "ERR_FUNCTION_SETCONFIG" : end if : set d = adic() : tag_start = "^<conf(igure)*"&iif(ea("configid"),"\s\s*id\s*=\s*""*"&aan("configid")&"""*\s*","")&">" : tag_end = "^</conf(igure)*"&iif(ea("configid"),"\s\s*id\s*=\s*""*"&aan("configid")&"""*\s*","")&">" : for each b in fcleanup(c) : if rmatch(b,tag_start) then : flg=flg+1 : end if : if rmatch(b,tag_end) then : flg=flg+1 : end if : if flg=1 and rmatch(b,"^\s*(""*[a-zA-Z][a-zA-Z0-9\._]*""*)\s*=\s*(.*)\s*$") then : set v = getsubmatch(b,"^\s*(""*[a-zA-Z][a-zA-Z0-9\._]*""*)\s*=\s*(.*)\s*$") : if len(v(0))>0 and len(v(1))>0 then : call dic(d,v(0), iif(ea("notypecast"), v(1), skeltypecast(v(1))) ) : end if : end if : next : if not ed(d,"_readconfigs") then : call dic(d,"_readconfigs",array()) : end if : d("_readconfigs") = push(d("_readconfigs"),c) : set setconfig = d : end function
'-skeltypecast(string) :: valid_arguments, rmatch, rremove, rmatchi, dictionary \use in setconfig()\
function skeltypecast(s) : call valid_arguments("skeltypecast",array(s),array("string")) : if rmatch(s,"^"".*""$") then : skeltypecast = rremove(s,"(^"")|(""$)") : else : if rmatchi(s,"true|false") then : skeltypecast = cbool(s) : exit function : end if : if rmatch(s,"^%arr(ay)*%") then : skeltypecast = split(rremove(s,"^%arr(ay)*%\(|\)$"),",") : exit function : end if : if rmatch(s,"^%dic(tionary)*%") then : set skeltypecast = dictionary(rremove(s,"^%dic(tionary)*%")) : exit function : end if : if rmatch(s,"^#[0-9/:][0-9/:]*#$") then : skeltypecast = cdate(rremove(s,"(^#)|(#$)")) : exit function : end if : if isnumeric(s) then : skeltypecast = eval(s) : else : skeltypecast = s : end if : end if : end function : 
'*skelconfig() :: setconfig, skelconfigname, dic, skelversion, datetime1, flogname, FUNCTION_FLOG_TYPENAME, FUNCTION_DATETIME_TYPENAME \\
function skelconfig() : dim b : set b = setconfig(skelconfigname()) : call dic(b,"_skelverion",skelversion()) : call dic(b,"_startdate",datetime1()) : call dic(b,"_logname",flogname()) : call dic(b,"_logtype",FUNCTION_FLOG_TYPENAME) : call dic(b,"_datetimetype",FUNCTION_DATETIME_TYPENAME) : set skelconfig = b : end function
'+skelversion() :: 
function skelversion() : on error resume next : skelversion = skelv : if err.number <> 0 then : skelversion = "undefined" : err.clear : end if : end function
'--
'+configure_xml() :: adic, iif, eau, aan, basename, e, ef, buildpath, xml, echo,cerr, FUNCTION_CONFIGURE_SET_EMPTY, rmatch, dic, cast, push, skelversion, datetime1, flogname, FUNCTION_FLOG_TYPENAME, FUNCTION_DATETIME_TYPENAME
function configure_xml() : dim d, fn,oxml,param,i,a,name, elem, num : num = 0 : set d = adic() : fn = iif(eau("config"),aan("config"),basename(wscript.scriptname)&".config.xml") : if not e(fn) and ef("conf") then : fn = iif(e(buildpath("conf",basename(wscript.scriptname)&".config.xml")),buildpath("conf",basename(wscript.scriptname)&".config.xml"),fn) : end if : set oxml = fxml(fn) : echo("(configure_xml) detect "&oxml.documentElement.getElementsByTagName("param").length&" parameters.") : for each param in oxml.documentElement.selectNodes("/configure/param") : set name = param.getElementsByTagName("name") : set elem = param.getElementsByTagName("element") : if name.length<1 then : cerr("(configure_xml) invalid 'param' ("&num&": undefined 'name'), skipped.") : else : if elem.length<1 then : cerr("(configure_xml) invalid 'param' ("&num&": undefined 'element'), skipped.") : else : if not elem(0).haschildnodes then : if isnull(elem(0).getattribute("type")) then : if FUNCTION_CONFIGURE_SET_EMPTY then : call dic(d, name(0).text, empty) : else : cerr("(configure_xml) detect empty 'element' ("&num&": has no 'value'), skipped.") : end if : else : if FUNCTION_CONFIGURE_SET_EMPTY then : if rmatch(elem(0).getattribute("type"),"(dic|dictionary)") then : call dic(d, name(0).text, adic()) : end if : if rmatch(elem(0).getattribute("type"),"(arr|array)") then : call dic(d, name(0).text, array()) : end if : else : cerr("(configure_xml) detect empty 'element' ("&num&": has no 'value'), skipped.") : end if : end if : else : if isnull(elem(0).getattribute("type")) then : if elem(0).childnodes.length>1 then : cerr("(configure_xml) invalid 'value' ("&num&": has multiple 'value', only allowed in 'type': array/dictionary), skipped.") : else : call dic(d, name(0).text, cast(elem(0).childnodes(0).text, elem(0).childnodes(0).getattribute("type"))) : end if : else : if rmatch(elem(0).getattribute("type"),"(arr|array)") then : a = array() : for i=0 to elem(0).childnodes.length-1 : if rmatch(elem(0).childnodes(i).getattribute("type"),"(arr|array|dic|dictionary)") then : cerr("(configure_xml) invalid 'value,type' ("&num&","&i&": not allowed '"&elem(0).childnodes(i).getattribute("type")&"' yet), skipped.") : else : call push(a, cast(elem(0).childnodes(i).text, elem(0).childnodes(i).getattribute("type"))) : end if : next : call dic(d, name(0).text, a) : end if : if rmatch(elem(0).getattribute("type"),"(dic|dictionary)") then : set a = adic() : for i=0 to elem(0).childnodes.length-1 : if rmatch(elem(0).childnodes(i).getattribute("type"),"(arr|array|dic|dictionary)") then : cerr("(configure_xml) invalid 'value,type' ("&num&","&i&": not allowed '"&elem(0).childnodes(i).getattribute("type")&"' yet), skipped.") : else : if isnull(elem(0).childnodes(i).getattribute("key")) then : cerr("(configure_xml) invalid value ("&num&","&i&": not allowed null 'key'), skipped.") : else : call dic(a, elem(0).childnodes(i).getattribute("key"), cast(elem(0).childnodes(i).text, elem(0).childnodes(i).getattribute("type"))) : end if : end if : next : call dic(d, name(0).text, a) : end if : if not rmatch(elem(0).getattribute("type"),"(dic|dictionary|arr|array)") then : cerr("(configure_xml) not support '"&elem(0).getattribute("type")&"' has multiple 'value', skipped.") : end if : end if : end if : end if : end if : num = num+1 : next : call dic(d,"_skelverion",skelversion()) : call dic(d,"_configure",fn) : call dic(d,"_startdate",datetime1()) : call dic(d,"_logname",flogname()) : call dic(d,"_logtype",FUNCTION_FLOG_TYPENAME) : call dic(d,"_datetimetype",FUNCTION_DATETIME_TYPENAME) : set configure_xml = d : end function : 

'e.g. property_dictionary has {from=>string, to=>array/string, cc=>array/string, bcc=>array/string,
'     subject=>string, htmlbody=>string, textbody=>string, bodypart.charset=>string, attachment=>array/file/string }
'*mkmail(dictionary) :: valid_arguments, amail, cerr, iif, env, ed, anet, e, absolutepath, bind \returns mail object with property\
function mkmail(p) : dim a,b : call valid_arguments("mkmail",array(p),array("dictionary")) : set mkmail = amail() : if isnothing(mkmail) then : cerr("(mkmail) can't create mail with property.") : exit function : end if : mkmail.from = iif(len(p("from"))>0,p("from"),lcase(env("%USERNAME%@%USERDNSDOMAIN%"))) : mkmail.subject = iif(ed(p,"subject"),p("subject"),"send from "&anet.computername&" <"&wscript.scriptfullname&">") : mkmail.htmlbody = p("htmlbody") : mkmail.htmlbody = p("textbody") : mkmail.htmlbody = p("bodypart.charset") : if isarray(p("to")) then : mkmail.to = join(p("to"),",") : else : mkmail.to = p("to") : end if : if isarray(p("cc")) then : mkmail.cc = join(p("cc"),",") : else : mkmail.cc = p("cc") : end if : if isarray(p("bcc")) then : mkmail.bcc = join(p("bcc"),",") : else : mkmail.bcc = p("bcc") : end if : if not isarray(p("attachment")) then : a = array(p("attachment")) : else : a = p("attachment") : end if : for each b in a : if not isempty(b) then : if e(absolutepath(b)) then : mkmail.addattachment(absolutepath(b)) : end if : end if : next : end function
'e.g. send_mail("from@mail.addr", "to@mail.addr", "cc@mail.addr", "subject", "mail body", null, "smtpserver", 25, 1000)
'*send_mail(string,string,string,string,string,string/file/null,string,numeric,numeric) :: valid_arguments, adic, dic, pmailer \for backward compatibility. do not use.\
function send_mail(addr_from, addr_to, addr_cc, subject, body, attachment, smtpsvr, smtpport, timeout) : dim d : call valid_arguments("send_mail",array(addr_from, addr_to, addr_cc, subject, body, attachment, smtpsvr, smtpport, timeout),array("string", "string", "string", "string", "string", "string/file/null", "string", "numeric", "numeric")) : set d = adic() : call dic(d,"from",""""&addr_from&"""") : call dic(d,"to",addr_to) : call dic(d,"cc",addr_cc) : call dic(d,"subject",subject) : call dic(d,"textbody",body) : if not isnull(attachment) then : if isempty(attachment) then : call dic(d,"attachment","") : else : call dic(d,"attachment",attachment) : end if : end if : set send_mail = pmailer(mkmail(d), 2, smtpsvr, smtpport, timeout, false, 1, "", "") : end function
'+sendmail(string,string,string,string,string,string/file/null,string,numeric,numeric) :: send_mail, errmsg \if you set FUNCTION_SEND_MAIL_ALWAYS_SEND to true, replace send_mail() to sendmail(), returns err.number as result. \
function sendmail(addr_from, addr_to, addr_cc, subject, body, attachment, smtpsvr, smtpport, timeout) : on error resume next : send_mail(addr_from, addr_to, addr_cc, subject, body, attachment, smtpsvr, smtpport, timeout).send() : if err.number <> 0 then : cerr("(sendmail) can't send mail. "&errmsg(err)) : end if : sendmail = err.number : end function
'*mailer(imessage_object, string, string) :: valid_arguments, pmailer \returns mail object, if you want to send a mail, use .send() method or use sendmail() \
function mailer(mail, svr, prt) : call valid_arguments("mailer",array(mail, svr, prt),array("mail","string","string")) : set mailer = pmailer(mail, 2, svr, prt, 1000, false, 1, "", "") : end function
'primitive mailer
'*pmailer(mail, string, string, numeric, numeric, string, string, string, string) :: valid_arguments, cerr, FUNCTION_PMAILER_SCHEMA \returns mail object\
function pmailer(mail, su, svr, prt, tmout, ssl, auth, name, pswd) : dim schema : call valid_arguments("pmailer",array(mail, su, svr, prt, tmout, ssl, auth, name, pswd),array("mail", "string", "string", "numeric", "numeric", "string", "string", "string", "string")) : schema = FUNCTION_PMAILER_SCHEMA : mail.configuration.fields.item(schema&"/sendusing") = su : mail.configuration.fields.item(schema&"/smtpserver") = svr : mail.configuration.fields.item(schema&"/smtpserverport") = prt : mail.configuration.fields.item(schema&"/smtpconnectiontimeout") = tmout : mail.configuration.fields.item(schema&"/smtpusessl") = ssl : mail.configuration.fields.item(schema&"/smtpauthenticate") = auth : mail.configuration.fields.item(schema&"/sendusername") = name : mail.configuration.fields.item(schema&"/sendpassword") = pswd : mail.configuration.fields.update() : if err.number <> 0 then : cerr("(pmailer) set configuration error.") : set pmailer = nothing : err.clear : exit function : end if : set pmailer = mail : end function
'--
'+sleep(n) :: \(second), returns empty. sec sleep.\
function sleep(n) : sleep = usleep(n*1000) : end function
'+usleep(n) :: \(milisecond), returns empty. ms sleep\
function usleep(n) : usleep = wscript.sleep(n) : end function
'+newcmd() :: rndstr, ashell, flog, usleep, FUNCTION_NEWCMD_WAITTIME \returns window-title string.\
function newcmd() : dim t : t = rndstr(10) : ashell.run "cmd /C start """&t&"""", 2, false : flog("(newcmd) new cmd, windowname("&t&")") : newcmd = t : usleep(FUNCTION_NEWCMD_WAITTIME) : end function
'?cmdkeys(string/integer/long, array) :: valid_arguments, cmdkey \(window_title/processid, command_array())\
function cmdkeys(t,a) : dim b : call valid_arguments("cmdkeys",array(t,a),array("string/integer/long","array")) : for each b in a : if not cmdkey(t,b) then : cmdkeys = false : exit function : end if : next : cmdkeys = true : end function
'?cmdkey(string/integer/long,string) :: valid_arguments, ashell, exec, cerr, flog, \\
function cmdkey(p,s) : dim a ,b : call valid_arguments("cmdkey",array(p,s),array("string/integer/long","string")) : set a = ashell() : if isnumeric(p) then : b = pexec("cmd /c tasklist /fo:csv /nh /fi ""pid eq "&p&" | findstr "&p).stdout.readall : else : b = pexec("cmd /c tasklist /fo:csv /nh /v | findstr "&p).stdout.readall : end if : if not len(b)>0 then : cerr("(cmdkey) can't found process/windows ["&p&"], command ["&s&"] is abort.") : cmdkey = false : exit function : end if : flog(b) : do until a.appactivate(p) : exit do : loop : a.sendkeys(s&"~") : usleep(FUNCTION_CMDKEY_WAITTIME) : cmdkey = true : end function
'+selectfolder() :: app, cerr, ERR_FUNCTION_SELECTFOLDER\if canceled selection, script abort.\
function selectfolder() : dim b : set b = aapp.browseforfolder(0,"select a folder", 0) : if isnothing(b) then : cerr("(selectfolder) canceled. abort.") : err.raise ERR_FUNCTION_SELECTFOLDER, "canceled. abort.", "ERR_FUNCTION_SELECTFOLDER" : else : selectfolder = b.items.item.path : end if : end function : 
'+tee(string) :: valid_arguments, cout, flog \output console and log.\
function tee(s) : call valid_arguments("tee",array(s),array("string")) : cout(s) : tee = flog(s) : end function
'+ftee(string/file) :: valid_arguments, cout, fwrite \output console and file.\
function ftee(f,s) : call valid_arguments("ftee",array(f,s),array("string/file","string")) : cout(s) : call fwrite(f).writeline(s) : ftee = len(s) : end function
'shellpopup(value,integer/long,string,integer) :: valid_arguments, ashell \(string, closetime, title, typeint)\
function shellpopup(str,tm,title,typ) : call valid_arguments("shellpopup",array(str,tm,title,typ),array("value","integer/long","string","integer")) : shellpopup = ashell.popup(str, tm, title, typ) : end function

'# datetime #
'+datetime() :: FUNCTION_DATETIME_TYPENAME \speed rank = datetime2 >> datetime1 > datetime0\
function datetime() :: datetime = getref(FUNCTION_DATETIME_TYPENAME) : end function
'+datetime0() :: yndHMS, datetime \2016/01/29 18:18:10.123 => 160129181810\
function datetime0() : datetime0 = right(yndHMS("yyyynnddHHMMSS"),12) : end function
'+datetime1() :: datetime \2016/01/29 18:18:10.123 => 2016/01/29 18:18:10.12\
function datetime1() : datetime1 = now()&"."&right(fix(timer*100.0),2) : end function
'+datetime2() :: datetime \2016/01/29 18:18:10.123 => 2016/01/29 18:18:10\
function datetime2() : datetime2 = now() : end function
'+datetime3() :: datetime, yndHMS \2016/01/29 18:18:10.123 => 20160129181810\
function datetime3() : datetime3 = yndHMS("yyyynnddHHMMSS") : end function

'unixtimenow() :: unixtime \\
function unixtimenow() : unixtimenow = unixtime(now) : end function
'unixtime(date) :: valid_arguments, FUNCTIONS_UNIXTIME_BASIS \returns unixtime\
function unixtime(d) : call valid_arguments("unixtime",array(d),array("date")) : unixtime = datediff("s",FUNCTIONS_UNIXTIME_BASIS,d) : end function : 
'unix2date(numeric) :: valid_arguments, FUNCTIONS_UNIXTIME_BASIS \\
function unix2date(d) : call valid_arguments("unix2date",array(d),array("numeric")) : unix2date = dateadd("s", d, FUNCTIONS_UNIXTIME_BASIS) : end function
'--
'e.g. "2 years later" => 2018/02/01 18:18:00
'+date_natural(s) :: pdate_natural \returns natural-selection date from now() \
function date_natural(s) : date_natural = pdate_natural(s,now()) : end function
'+pdate_natural(string, date) :: valid_arguments, rmatch, getsubmatch, date_unit, cerr \if not matched, return empty.\
function pdate_natural(s,d) : dim m, op : call valid_arguments("pdate_natural",array(s,d),array("string","date")) : if rmatch(s,"^\s*(-*\d\d*)\s*(years*|months*|days*|hours*|min(uite)*s*|sec(ond)*s*)\s*(later|before|after|ago)\s*$") then : set m = getsubmatch(s,"^\s*(-*\d\d*)\s*(years*|months*|days*|hours*|min(uite)*s*|sec(ond)*s*)\s*(later|after|ago|before)\s*$") : set op = date_unit() : pdate_natural = dateadd(op(m(1)),op(m(4)) * m(0),d) : else : cerr("(pdate_natural) '"&s&"' is not matched pattern. (e.g. ""2 years later"")") : end if : end function
'e.g. date_element("10 days after") = dictionary({unit=>, number=>, flg=>})
'*date_element(string) :: valid_arguments, adic, rmatch, getsubmatch, date_unit, dic \return dictionary, {unit=>, number=>, flg=>}\
function date_element(s) : dim d,m,op : call valid_arguments("date_element",array(s),array("string")) : set d = adic() : if rmatch(s,"^\s*(-*\d\d*)\s*(years*|months*|days*|hours*|min(uite)*s*|sec(ond)*s*)\s*(later|before|after|ago)\s*$") then : set m = getsubmatch(s,"^\s*(-*\d\d*)\s*(years*|months*|days*|hours*|min(uite)*s*|sec(ond)*s*)\s*(later|before|after|ago)\s*$") : set op = date_unit() : call dic(d,"unit",op(m(1))) : call dic(d,"number",m(0)) : call dic(d,"flag",op(m(4))) : end if : set date_element = d : end function : 
'*date_unit() :: dictionary \return date-unit dictionary. (for pdate_natural and date_natural)\
function date_unit() : set date_unit = dictionary("{y => yyyy, m => m, d => d, H => h, M => n, S => s, year => yyyy, years => yyyy, month => m, months => m, day => d, days => d, hour => h, hours => h, min => n, minute => n, mins => n, minutes => n, sec => s, second => s, secs => s, seconds => s, later => 1, ago => -1, after => 1, before => -1}") : end function
'e.g. "2 days ago" => (2016/02/02 11:11:11, 2016/02/01 11:11:11)
'+date_list(string) :: pdate_list \returns array of the date from now that specified in natural language\
function date_list(s) : date_list = pdate_list(s,now()) : end function 
'+pdate_list(string, date) :: valid_arguments, date_element, push \\
function pdate_list(s,d) : dim i,u,a : a = array() : call valid_arguments("pdate_list",array(s,d),array("string","date")) : set u = date_element(s) : for i=u("flag") to u("number")*u("flag") step u("flag") : call push(a,dateadd(u("unit"),i,d)) : next : pdate_list = a : end function
'--
'primitive ynd()
'+pynd(string, date) :: preplace, dictionary \pattern: yyyy/nn/dd \
function pynd(s,d) : call valid_arguments("pynd",array(s,d),array("string","date")) : pynd = preplace(s,dictionary("{yyyy=>"""&year(d)&""", nn=>"""&right("0"&month(d),2)&""", dd=>"""&right("0"&day(d),2)&"""}")) : end function
'+ynd(string) :: pynd \from now(), pattern: yyyy/nn/dd\
function ynd(s) : ynd = pynd(s,now()) : end function
'primitive yndHMS()
'+pyndHMS(string, date) :: valid_arguments, adic, dic, preplace \pattern: yyyy/nn/dd/HH/MM/SS \
function pyndHMS(s,d) : dim b,p : call valid_arguments("pyndHMS",array(s,d),array("string","date")) : b = s : set p = adic() : call dic(p,"yyyy",year(d)) : call dic(p,"yy",right(year(d),2)) : call dic(p,"nn",right("0"&month(d),2)) : call dic(p,"dd",right("0"&day(d),2)) : call dic(p,"HH",right("0"&hour(d),2)) : call dic(p,"MM",right("0"&minute(d),2)) : call dic(p,"SS",right("0"&second(d),2)) : pyndHMS = preplace(s,p) : end function
'+yndHMS(string) :: pyndHMS \from now(), pattern: yyyy/nn/dd/HH/MM/SS \
function yndHMS(s) : yndHMS = pyndHMS(s,now()) : end function
'+preplace(string, dictionary) :: valid_arguments, \(target, pattern_dictionary) \
function preplace(s,p) : dim b,k : call valid_arguments("preplace",array(s,p),array("string","dictionary")) : b = s : for each k in p : b = replace(b, k, p(k)) : next : preplace = b : end function

'# dictionary #
'?dic(dictionary, value, *) :: valid_arguments, ed \key allow value. but strongly recommend use string.\
function dic(byref d,k,v) : call valid_arguments("dic",array(d,k,v),array("dictionary","value","*")) : if ed(d,k) then : if isobject(v) then : set d(k) = v : else : d(k) = v : end if : else : d.add k, v : end if : dic = true : end function
'*byval_dic(dictionary, value, *) :: valid_arguments, ed, bind \byval_dic returns dictionary.\
function byval_dic(d,k,v) : dim b : call valid_arguments("byval_dic",array(d,k,v),array("dictionary","value","*")) : set b = d : if ed(b,k) then : call bind(b(k),v) : else : b.add k, v : end if : set byval_dic = b : end function
'primitive dicmerge()
'?pdicmerge(dictionary, dictionary, boolean) :: valid_arguments, ed, bind \(merged, source) dicmerge returns true. affect to original dictionary.\
function pdicmerge(byref d,m,f) : dim k : call valid_arguments("pdicmerge",array(d,m,f),array("dictionary","dictionary","boolean")) : for each k in m : if ed(d,k) then : if f then : call bind(d(k),m(k)) : d(k) = m(k) : end if : else : d.add k, m(k) : end if : next : pdicmerge = true : end function
'?dicmerge(dictionary, dictionary) :: pdicmerge \(merged, source) dicmerge returns true. affect to original dictionary. if found same key, overwrite value.\
function dicmerge(byref d,m) : dicmerge = pdicmerge(d, m, true) : end function
'*byval_dicmerge(dictionary, dictionary) :: valid_arguments, ed, bind \(sorce, source). byval_dicmerge resturns merged dictionary.\
function byval_dicmerge(d,m) : dim b,c,k : call valid_arguments("byval_dicmerge",array(d,m),array("dictionary","dictionary")) : set b = d : set c = m : for each k in c : if ed(d,k) then : call bind(b(k), c(k)) : else : b.add k, c(k) : end if : next : set byval_dicmerge = d : end function
'?dicunite(dictionary, dictionary) :: pdicmerge \(merged, source) dicmerge returns true. affect to original dictionary. if found same key, do nothing.\
function dicunite(byref d,m) : dicunite = pdicmerge(d,m,false) : end function
'e.g. dictionary("{1=>2, 2=>true, 3=>"str", }") => dictionary object
'*dictionary(string) :: valid_arguments, adic, rmatch, rremove, dic, btrim, skeltypecast, FUNCTION_DICTIONARY_FORMAT \\
function dictionary(s) : dim a,b,d : call valid_arguments("dictionary",array(s),array("string")) : set d = adic() : if rmatch(s,FUNCTION_DICTIONARY_FORMAT) then : a = split(rremove(s,"^{|}$"),",") : for each b in a : call dic(d,btrim(split(b,"=>")(0)),skeltypecast(trim(split(b,"=>")(1)))) : next : end if : set dictionary = d : end function

'# array #
'e.g. shift <-  array() -> pop
'e.g. unshift -> array() <- push
'+pop(array) :: valid_arguments, bind \(1,2,3) -> (1,2), 3 ,returns value and modified original.\
function pop(a) : call valid_arguments("pop",array(a),array("array")) : if ubound(a)>-1 then : call bind(pop, a(ubound(a))) : redim preserve a(ubound(a)-1) : end if : end function : 
'+byval_pop(array) :: valid_arguments, pop \(1,2,3) -> (1,2,3), 3 ,returns value and not modified original.\
function byval_pop(a) : dim b : call valid_arguments("byval_pop",array(a),array("array")) : b = a : byval_pop = pop(b) : end function
'+shift(array) :: valid_arguments, bind \(1,2,3) -> (2,3), 1 ,returns value and modified original\
function shift(a) : dim i : call valid_arguments("shift",array(a),array("array")) : if ubound(a)>-1 then : call bind(shift,a(0)) : for i=0 to ubound(a)-1 : call bind(a(i),a(i+1)) : next : redim preserve a(ubound(a)-1) : end if : end function
'+byval_shift(array) :: valid_arguments \(1,2,3) -> (1,2,3), 1 ,returns value and modified original\
function byval_shift(a) : call valid_arguments("byval_shift",array(a),array("array")) : if ubound(a)>-1 then : byval_shift = a(0) : end if : end function
'+push(array, *) :: valid_arguments, bind \(1,2) ,3 -> (1,2,3) ,returns array and modified original.\
function push(a,v) : call valid_arguments("push",array(a,v),array("array","*")) : redim preserve a(ubound(a)+1) : call bind(a(ubound(a)),v) : push = a : end function
'+byval_push(array, *) :: valid_arguments, push \(1,2) ,3 -> (1,2,3) ,returns array and not modified original.\
function byval_push(a,v) : dim b : call valid_arguments("byval_push",array(a,v),array("array","*")) : b = a : byval_push = push(b,v) : end function
'+unshift(array, *) :: valid_arguments, bind \(1,2) ,3 -> (3,1,2) ,returns array and modified original.\
function unshift(a,v) : dim i : call valid_arguments("unshift",array(a,v),array("array","*")) : redim preserve a(ubound(a)+1) : for i=ubound(a) to 1 step -1 : call bind(a(i), a(i-1)) : next : call bind(a(0), v) : unshift = a : end function
'+byval_unshift(array, *) :: valid_arguments, unshift \(1,2) ,3 -> (3,1,2) ,returns array and not modified original.\
function byval_unshift(a,v) : dim i,b : call valid_arguments("unshift",array(a,v),array("array","*")) : b = a : byval_unshift = unshift(b,v) : end function
'+popn(array,integer/long) :: valid_arguments, push, pop \modified original\
function popn(a,n) : dim b,i : b = array() : call valid_arguments("popn",array(a,n),array("array","integer/long")) : i = iif(n>0,n,0) : do while i>0 : call push(b,pop(a)) : i=i-1 : loop : popn = b : end function
'+shiftn(array,integer/long) :: valid_arguments, push, pop \modified original\
function shiftn(a,n) : dim b,i : b = array() : call valid_arguments("shiftn",array(a,n),array("array","integer/long")) : i = iif(n>0,n,0) : do while i>0 : call push(b,shift(a)) : i=i-1 : loop : shiftn = b : end function
'+byval_popn(array,integer/long) :: valid_arguments, popn \not modified original\ 
function byval_popn(a,n) : dim b : call valid_arguments("byval_popn",array(a,n),array("array","integer/long")) : b = a : byval_popn = popn(b,n) : end function
'+byval_shiftn(array,integer/long) :: valid_arguments, shiftn \not modified original\
function byval_shiftn(a,n) : dim b : call valid_arguments("byval_shiftn",array(a,n),array("array","integer/long")) : b = a : byval_shiftn = shiftn(b,n) : end function
'+pull(array,integer/long) :: valid_arguments, bind, swap \(target, indicator) indicator starts 0\
function pull(a,n) : dim i : call valid_arguments("pull",array(a,n),array("array","integer/long")) : if ubound(a)<0 then : pull = a : exit function : else : if n>ubound(a) then : pull = empty : exit function : end if : end if : call bind(pull,a(n)) : for i=n to ubound(a)-1 : call swap(a(i),a(i+1)) : next : redim preserve a(ubound(a)-1) : end function
'--
'+array_merge(array,array) :: valid_arguments, bind \(1,2), (3,4) -> (1,2,3,4), returns array, not modified original\
function array_merge(a,b) : dim i,c : c = array() : call valid_arguments("amerge",array(a,b),array("array","array")) : for i=0 to ubound(a) : redim preserve c(ubound(c)+1) : call bind(c(ubound(c)),a(i)) : next : for i=0 to ubound(b) : redim preserve c(ubound(c)+1) : call bind(c(ubound(c)),b(i)) : next : array_merge = c : end function : 
'+array_reverse(array) :: valid_arguments, swap \\
function array_reverse(a) : dim i,j : call valid_arguments("array_reverse",array(a),array("array")) : if ubound(a)<0 then : array_reverse = a : exit function : end if : i = 0 : j = ubound(a) : do while i<j : call swap(a(i),a(j)) : i=i+1 : j=j-1 : loop : array_reverse = a : end function
'e.g. array_grab(array(1,2,3,4,5),1,4) => array(2,3,4,5)
'+array_grab(array, integer/long, integer/long) :: valid_arguments, cerr, ERR_FUNCTION_ARRAY_GRAB, push \(target, start_element, end_element)\
function array_grab(a,i,j) : dim b,k : b = array() : call valid_arguments("array_grab",array(a,i,j),array("array","integer/long","integer/long")) : if i>j or i<0 or j>ubound(a) then : cerr("(array_grab) array has length ("&ubound(a)&"), can't allocate from ("&i&") to ("&j&")") : err.raise ERR_FUNCTION_ARRAY_GRAB, "array has length ("&ubound(a)&"), can't allocate from ("&i&") to ("&j&")", "ERR_FUNCTION_ARRAY_GRAB" : end if : for k=i to j : call push(b, a(k)) : next : array_grab = b : end function
'+array_grab_to(array, integer/long) :: array_grab \(target, to_position), grab array from 'front' to 'p'\
function array_grab_to(a,p) : array_grab_to = array_grab(a,0,p) : end function
'+array_grab_from(array, integer/long) :: array_grab \(target, from_position), grab array from 'p' to 'end'\
function array_grab_from(a,p) : array_grab_from = array_grab(a,p,ubound(a)) : end function
'+array_rotate(array, boolean) :: valid_arguments, pop, unshift, shift, push \(target, rotate_right?) \
function array_rotate(a,d) : dim b,c : c = a : call valid_arguments("array_rotate",array(a,d),array("array","boolean")) : if d then : b = pop(c) : call unshift(c, b) : else : b = shift(c) : call push(c,b) : end if : array_rotate = c : end function
'+array_rotate_right(array) :: array_rotate \\
function array_rotate_right(a) : array_rotate_right = array_rotate(a,true) : end function
'+array_rotate_left(array) :: array_rotate \\
function array_rotate_left(a) : array_rotate_left = array_rotate(a,false) : end function
'array_dimension(array) :: valid_arguments \detect array dimension\
function array_dimension(a) : call valid_arguments("dimension",array(a),array("array")) : on error resume next : dim i : i = 0 : do until err.number <> 0 : i=i+1 : call ubound(a,i) : loop : err.clear : array_dimension = i-1 : end function
'+array_chop(array) :: valid_arguments \(1,2) => (1)\
function array_chop(a) : call valid_arguments("array_chop",array(a),array("array")) : redim preserve a(ubound(a)-1) : array_chop = a : end function
'+array_chomp(array) :: valid_arguments \(1,2,"") => (1,2)\
function array_chomp(a) : call valid_arguments("array_chomp",array(a),array("array")) : if a(ubound(a)) = "" then : redim preserve a(ubound(a)-1) : end if : array_chomp = a : end function
'--
'primitive qsort
'+pqsort(array,integer/long,integer/long) :: valid_arguments, isvalue, cerr, swap \\
function pqsort(a,l,r) : dim i,j,p : call valid_arguments("pqsort",array(a,l,r),array("array","integer/long","integer/long")) : if r<0 then : pqsort = a : exit function : end if : i=l : j=r : p=a(fix((i+j)/2)) : do while i<=j : do while a(i) < p : i=i+1 : loop : if not isvalue(a(j)) then : cerr("(pqsort) detect object, abort sorting.") : pqsort = a : exit function : end if : do while a(j) > p : j=j-1 : loop : if i<=j then : call swap(a(i),a(j)) : i=i+1 : j=j-1 : end if : if l<j then : call pqsort(a, l, j) : end if : if i<r then : call pqsort(a, i, r) : end if : loop : pqsort = a : end function : 
'+qsort(array) :: valid_arguments, pqsort \quicksort\
function qsort(a) : call valid_arguments("qsort",array(a),array("array")) : qsort = pqsort(a,0,ubound(a)) : end function
'+rsort(array) :: array_reverse, qsort \reversed quicksort\
function rsort(a) : rsort = array_reverse(qsort(a)) : end function

'# environment #
'+getenv(string) :: valid_arguments, ashell \\
function getenv(s) : call valid_arguments("getenv",array(s),array("string")) : getenv = ashell.expandenvironmentstrings(s) : end function
'+env() :: getenv \alias to getenv() \
function env(s) :: env = getenv(s) : end function
'+getcd() :: afso \returns folder\
function getcd() : set getcd = afso.getfolder(".") : end function
'+pwd() :: absolutepath \returns string\
function pwd() : pwd = absolutepath(".") : end function

'# processes #
'+pid() :: isusewmi, exec, aconn, cerr \returns own process id using wmi.\
function pid() : dim b,p,c : if isusewmi() then : set b = pexec("cmd /K ") : set p = aconn.execquery("select ParentProcessId from win32_process where ProcessId = "&b.processid&"") : for each c in p : pid = c.ParentProcessId : exit for : next : b.stdin.writeline("exit") : b.terminate : else : cerr("(pid) can't find own process id because can't use WMI functions.") : end if : end function
'+ppid() :: valid_arguments, isusewmi, aconn, cerr \returns parent process id using wmi.\
function ppid(p) : dim b,c : call valid_arguments("ppid",array(p),array("integer/long")) : if isusewmi() then : set b = aconn.execquery("select ParentProcessId from win32_process where ProcessId = "&p&"") : for each c in b : ppid = c.ParentProcessId : exit for : next : else : cerr("(pid) can't find own process id because can't use WMI functions.") : end if : end function
'+getpid() :: pid \\
function getpid() : getpid = pid() : end function
'--
'*pexec(string) :: valid_arguments, ashell, flog \exec command. returns wshexec object. if you wants error, check exitcode.\
function pexec(s) : call valid_arguments("pexec",array(s),array("string")) : set pexec = ashell.exec(s) : flog("(pexec) ["&pexec.processid&"] """&s&"""") : end function
'*wexec(string) :: valid_arguments, ashell, flog, cerr, cout, usleep \exec command, wait to done. returns wshexec object. if you wants error, check exitcode.\
function wexec(s) : call valid_arguments("wexec",array(s),array("string")) : set wexec = ashell.exec(s) : flog("(wexec) ["&wexec.processid&"] """&s&"""") : do until (wexec.status <> 0 and wexec.stdout.atendofstream) : if not wexec.stdout.atendofstream then : cout(wexec.stdout.readline) : end if : usleep(10) : loop : do until wexec.stderr.atendofstream : cerr(wexec.stderr.readline) : loop : end function

'# echo # echo functions returns write length.
'+echo(value) :: valid_arguments, flog \\
function echo(s) : call valid_arguments("echo",array(s),array("value")) : echo = flog(s) : end function
'+pecho(value) :: valid_arguments, shellpopup, flog \popup echo. if you want response, use shellpopup()\
function pecho(s) : call valid_arguments("pecho",array(s),array("value")) : call shellpopup(s, 3, "["&scriptname&"]", 0) : pecho = flog(s) : end function
'+eecho(value) :: valid_arguments, flog \\
function eecho(s) : call valid_arguments("eecho",array(s),array("value")) : eecho = flog("[ERR ] "&s) : end function
'+iecho(value) :: valid_arguments, flog \\
function iecho(s) : call valid_arguments("iecho",array(s),array("value")) : iecho = flog("[INFO] "&s) : end function
'+wecho(value) :: valid_arguments, flog \\
function wecho(s) : call valid_arguments("wecho",array(s),array("value")) : wecho = flog("[WARN] "&s) : end function

'# echo_ # echo_ functions no returns.
'echo_array(array) :: valid_arguments, iif, isvalue, echo \array echo. for more info, use dumper()\
function echo_array(a) : dim i : call valid_arguments("echo_array",array(a),array("array")) : echo(typename(a)&"("&ubound(a)&") (") : for i=0 to ubound(a) : echo(string(2," ")&"("&i&") = "&typename(a(i))&"("&iif(isvalue(a(i)),a(i),"*")&")") : next : echo(")") : end function
'echo_array1(array) :: valid_arguments, iif, isvalue, echo \1 liner array echo\
function echo_array1(a) : dim i, b : b = "" : call valid_arguments("echo_array1",array(a),array("array")) : b = typename(a)&"("&ubound(a)&") (" : for i=0 to ubound(a) : b = b&string(2," ")&"("&i&") = "&typename(a(i))&"("&iif(isvalue(a(i)),a(i),"*")&")" : next : b = b&")" : echo(replace(b,vbnewline,"")) : end function
'echo_xml(domdocument/ixmldomnodelist) :: valid_arguments, isxml, echo \\
function echo_xml(x) : dim b : call valid_arguments("echo_xml",array(x),array("domdocument/ixmldomnodelist")) : if isxml(x) then : b = x.xml : else : b = x.item(0).xml : end if : echo(typename(x)&"(") : echo(string(2," ")&b) : echo(")") : end function
'echo_xml1(domdocument/ixmldomnodelist) :: valid_arguments, isxml, echo \1 liner xml echo\
function echo_xml1(x) : call valid_arguments("echo_xml1",array(x),array("domdocument/ixmldomnodelist")) : if isxml(x) then : echo(x.xml) : else : echo(x.item(0).xml) : end if : end function
'echo_dictionary(dictionary) :: valid_arguments, iif, isvalue, echo \\
function echo_dictionary(d) : dim k : call valid_arguments("echo_dictionary",array(d),array("dictionary")) : echo(typename(d)&"("&d.count&")"&" (") : for each k in d : echo(string(2," ")&"("&k&") => "&typename(d(k))&"("&iif(isvalue(d(k)),d(k),"*")&")") : next : echo(")") : end function
'echo_dictionary1(dictionary) :: valid_arguments, iif, isvalue, echo \1 liner dictionary echo\
function echo_dictionary1(d) : dim k,b : call valid_arguments("echo_dictionary1",array(d),array("dictionary")) : b = typename(d)&"("&d.count&")"&" (" : for each k in d : b = b&string(2," ")&"("&k&") => "&typename(d(k))&"("&iif(isvalue(d(k)),d(k),"*")&")" : next : b = b&")" : echo(b) : end function
'echo_matches(imatchcollection2/isubmatches) :: valid_arguments, ismatch, iif \\
function echo_matches(m) : dim i,j : call valid_arguments("echo_matches",array(m),array("imatchcollection2/isubmatches")) : if ismatch(m) then : echo(typename(m)&"("&m.count&") (") : for i=0 to m.count-1 : echo(string(2," ")&typename(m(i))&"("&i&") ( (firstindex, length, value) = ("&m(i).firstindex&", "&m(i).length&", "&typename(m(i).value)&"("&m(i).value&")) "&iif(m(i).submatches.count>0,"",")")) : if m(i).submatches.count > 0 then : for j=0 to m(i).submatches.count-1 : echo(string(4," ")&typename(m(i).submatches)&"("&m(i).submatches.count&") ( ("&j&") = ("&m(i).submatches(j)&") )") : next : echo(string(2," ")&")") : end if : next : echo(")") : else : echo(typename(m)&"("&m.count&") (") : for i=0 to m.count-1 : echo(string(2," ")&"("&i&") = "&typename(m(i))&"("&m(i)&")") : next : echo(")") : end if : end function
'echo_matches1(imatchcollection2/isubmatches) :: valid_arguments, ismatch, iif \1 liner matches/submatches echo\
function echo_matches1(m) : dim i,j,b : call valid_arguments("echo_matches1",array(m),array("imatchcollection2/isubmatches")) : if ismatch(m) then : b = typename(m)&"("&m.count&") (" : for i=0 to m.count-1 : b = b&string(2," ")&typename(m(i))&"("&i&") ( (firstindex, length, value) = ("&m(i).firstindex&", "&m(i).length&", "&typename(m(i).value)&"("&m(i).value&")) "&iif(m(i).submatches.count>0,"",")") : if m(i).submatches.count > 0 then : for j=0 to m(i).submatches.count-1 : b = b&string(4," ")&typename(m(i).submatches)&"("&m(i).submatches.count&") ( ("&j&") = ("&m(i).submatches(j)&") )" : next : b = b&string(2," ")&")" : end if : next : b = b&")" : echo(b) : else : b = typename(m)&"("&m.count&") (" : for i=0 to m.count-1 : b = b&string(2," ")&"("&i&") = "&typename(m(i))&"("&m(i)&")" : next : b = b&")" : echo(b) : end if : end function
'--
'dumper(*) :: isvalue, echo, FUNCTION_DUMPER_LABEL, FUNCTION_DUMPER_LEVEL \dump variable\
function dumper(v) : dim b,c : select case (isvalue(v) or isempty(v)) : case true : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&v&")") : case else : select case typename(v) : case "Variant()" : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&ubound(v)&") (") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for b=0 to ubound(v) : FUNCTION_DUMPER_LABEL = "(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&"("&b&") = " : call dumper(v(b)) : next : FUNCTION_DUMPER_LABEL = "(dumper) " : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : case "Dictionary" : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&v.count&") {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for each b in v : FUNCTION_DUMPER_LABEL = "(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(b)&"("&b&") => " : call dumper(v(b)) : next : FUNCTION_DUMPER_LABEL = "(dumper) " : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "IMatchCollection2" : echo(FUNCTION_DUMPER_LABEL&typename(v)&" {") : FUNCTION_DUMPER_LABEL = "(dumper) " : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : if v.count>0 then : for b=0 to v.count-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v(b))&"("&v.count&") (") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"("&b&") = (") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(firstindex) = ("&v(b).firstindex&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(length) = ("&v(b).length&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(value) = "&typename(v(b).value)&"("&v(b).value&")") : if v(b).submatches.count>0 then : call dumper(v(b).submatches) : end if : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : next : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : end if : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "ISubMatches" : echo("(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&" (") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for b=0 to v.count-1 : echo("(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&"("&b&") = "&typename(v(b))&"("&v(b)&")") : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo("(dumper) "&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : case "IMessage" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&" (") : FUNCTION_DUMPER_LABEL = "(dumper) " : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(from) = ("&v.from&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(to) = ("&v.to&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(cc) = ("&v.cc&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(bcc) = ("&v.bcc&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(subject) = ("&v.subject&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(htmlbody) = ("&v.htmlbody&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(textbody) = ("&v.textbody&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(bodypart.charset) = ("&v.bodypart.charset&")") : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(attachments)("&v.attachments.count&") = {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for each b in v.attachments : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"(filename) = "&typename(b.filename)&"("&b.filename&")") : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : FUNCTION_DUMPER_LABEL = "(dumper) " : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&")") : case "DOMDocument" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&" {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : if v.haschildnodes then : FUNCTION_DUMPER_LABEL = "(dumper) " : call dumper(v.childnodes) : end if : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : FUNCTION_DUMPER_LABEL = "(dumper) " : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "IXMLDOMNodeList" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&"("&v.length&") {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for each b in v : call dumper(b) : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "IXMLDOMElement" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&"("&v.nodename&" -> "&v.nodevalue&") {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for b=0 to v.childnodes.length-1 : call dumper(v.childnodes(b)) : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "IXMLDOMText" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&"("&v.nodename&" -> "&v.nodevalue&")") : case "IXMLDOMSelection" : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&typename(v)&"("&v.length&") {") : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL+1 : for each b in v : FUNCTION_DUMPER_LABEL = "(dumper) " : call dumper(b) : next : FUNCTION_DUMPER_LEVEL = FUNCTION_DUMPER_LEVEL-1 : echo(FUNCTION_DUMPER_LABEL&string(FUNCTION_DUMPER_LEVEL,"  ")&"}") : case "File" : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&v.path&")") : case "Folder" : echo(FUNCTION_DUMPER_LABEL&typename(v)&"("&v.path&")") : case else : select case (isnothing(v) or isnull(v)) : case true : echo(FUNCTION_DUMPER_LABEL&typename(v)&"()") : case else : echo(FUNCTION_DUMPER_LABEL&typename(v)&"(*)") : end select : end select : end select : end function

'--
'+cout(string) :: \this function is primitive so do not use user functions in this.\
function cout(s) : on error resume next : cout = len(s) : wscript.stdout.writeline(s) : err.clear : end function
'+cerr(string) :: FUNCTION_CERR_ERRORLEVEL \this function is primitive so do not use user functions in this.\
function cerr(s) : on error resume next : if FUNCTION_CERR_ERRORLEVEL > 0 then : cerr = len(s) : if FUNCTION_CERR_ERRORLEVEL > 1 then : stop : end if : end if : wscript.stderr.writeline(s) : err.clear : end function

'# abbreviations #
'*afso() :: 
function afso() : set afso = wscript.createobject("scripting.filesystemobject") : end function
'*ashell() ::
function ashell() : set ashell = wscript.createobject("wscript.shell") : end function
'*adic() :: 
function adic() : set adic = wscript.createobject("scripting.dictionary") : end function
'*aapp() ::
function aapp() : set aapp = wscript.createobject("shell.application") : end function
'*anet() ::
function anet() : set anet = wscript.createobject("wscript.network") : end function
'*aarg() :: 
function aarg() : set aarg = wscript.arguments : end function
'*axmlhttp() :: 
function axmlhttp() : set axmlhttp = createobject("msxml2.xmlhttp") : end function
'*alocator() ::
function alocator() : set alocator = wscript.createobject("WbemScripting.SWbemLocator") : end function
'*aconn() :: alocator
function aconn() : set aconn = alocator.connectserver : end function
'*adb() :: 
function adb() : set adb = createobject("adodb.connection") : end function
'*astream() :: 
function astream() : set astream = createobject("adodb.stream") : end function
'*axml() :: 
function axml() : set axml = createobject("msxml2.domdocument") : end function
'*amail() :: amessage \alias to amessage\
function amail() : set amail = amessage() : end function
'*amessage() :: \\
function amessage() : on error resume next : set amessage = createobject("cdo.message") : if err.number <> 0 then : cerr("(amessage) can't create cdo.message object.") : stop : set amessage = nothing : err.clear : end if : end function
'*aconnsrv(string,string,string,string) :: alocator \(computer,namespace,username,password)\
function aconnsrv(c,n,u,p) : call valid_arguments("aconnsrv",array(c,n,u,p),array("string","string","string","string")) : set aconnsrv = alocator.connectserver(c,n,u,p) : end function
'+aan(string) :: valid_arguments, aarg \\
function aan(n) : call valid_arguments("aan",array(n),array("string")) : aan = aarg.named(n) : end function
'+aau(integer/long) :: valid_arguments, aarg \\
function aau(n) : call valid_arguments("aau",array(n),array("integer/long")) : if aarg.unnamed.count > n then : aau = aarg.unnamed(n) : end if : end function

'# filehandler # f*() allows file/string
'\textfile\ -> ftextfile
'*ftextfile(file/string,integer/long,boolean,integer/long) :: ftextfile \(filename,iomode,create,format)\
function ftextfile(f,iomode,create,format) : call valid_arguments("ftextfile",array(f,iomode,create,format),array("file/string","integer/long","boolean","integer/long")) : set ftextfile = afso.opentextfile(f,iomode,create,format) : end function
'*fread(file/string) :: ftextfile \\
function fread(f) : set fread = ftextfile(f,1,false,-2) : end function
'*fwrite(file/string) :: fappend \\
function fwrite(f) : set fwrite = fappend(f) : end function
'*fappend(file/string) :: ftextfile \\
function fappend(f) : set fappend = ftextfile(f,8,true,-2) : end function
'*fowrite(file/string) :: ftextfile \overwrite\
function fowrite(f) : set fowrite = ftextfile(f,2,true,-2) : end function
'*furead(file/string) :: ftextfile \\
function furead(f) : set furead = ftextfile(f,1,false,-1) : end function
'*fuwrite(file/string) :: fuappend \\
function fuwrite(f) : set fuwrite = fuappend(f) : end function
'*fuappend(file/string) :: ftextfile \\
function fuappend(f) : set fuappend = ftextfile(f,8,true,-1) : end function
'*fuowrite(file/string) :: ftextfile \overwrite\
function fuowrite(f) : set fuowrite = ftextfile(f,2,true,-1) : end function
'--
'\textstream\ -> ftextstream
'*ftextstream("file/string","integer/long","integer/long") :: valid_arguments, afso \(filename,iomode,format), open as textstream\
function ftextstream(f,iomode,format) : call valid_arguments("ftextstream",array(f,iomode,format),array("file/string","integer/long","integer/long")) : set ftextstream = afso.getfile(f).openastextstream(iomode,format) : end function
'*ftsread(file/string) :: ftextstream \\
function ftsread(f) : set ftsread = ftextstream(f,1,-2) : end function
'*ftswrite(file/string) :: ftsappend \\
function ftswrite(f) : set ftswrite = ftsappend(f) : end function
'*ftsappend(file/string) :: e, ftsowrite, ftextstream \\
function ftsappend(f) : if not e(f) then : call ftsowrite(f) : end if : set ftsappend = ftextstream(f,8,-2) : end function
'*ftsuread(file/string) :: ftextstream \\
function ftsuread(f) : set ftsuread = ftextstream(f,1,-1) : end function
'*ftsuwrite(file/string) :: ftsuappend \\
function ftsuwrite(f) : set ftsuwrite = ftsuappend(f) : end function
'*ftsuappend(file/string) :: e, ftsowrite, ftextstream \\
function ftsuappend(f) : if not e(f) then : call ftsowrite(f) : end if : set ftsuappend = ftextstream(f,8,-1) : end function
'*ftsowrite(file/string) :: fowrite, ftswrite \\ 
function ftsowrite(f) : call fowrite(f) : set ftsowrite = ftswrite(f) : end function
'*ftsuowrite(file/string) :: fowrite, ftsuwrite \\ 
function ftsuowrite(f) : call fowrite(f) : set ftsuowrite = ftsuwrite(f) : end function
'--
'readtext()
''-2 : by line
'-1 : readall
'n : by byte
'\stream\ -> fstream
'*fstream(file/string,string) :: valid_arguments, astream \(filename, charset)\
function fstream(f,charset) : call valid_arguments("fstream",array(f,charset),array("file/string","string")) : set fstream = astream() : fstream.charset = charset : end function
'*fsread(file/string) :: fstream \\
function fsread(f) : set fsread = fstream(f,"shift-jis") : fsread.open : fsread.loadfromfile(f) : end function
'*fswrite(file/string) :: fsappend \\
function fswrite(f) : set fswrite = fsappend(f) : end function
'*fsappend(file/string) :: fstream \\
function fsappend(f) : set fsappend = fstream(f,"shift-jis") : fsappend.open : fsappend.loadfromfile(f) : fsappend.position = fsappend.size : end function
'*fsuread(file/string) :: fstream \\
function fsuread(f) : set fsuread = fstream(f,"utf-8") : fsuread.open : fsuread.loadfromfile(f) : end function
'*fsuwrite(file/string) :: fsuappend \\
function fsuwrite(f) : set fsuwrite = fsuappend(f) : end function
'*fsuappend(file/string) :: fstream \\
function fsuappend(f) : set fsuappend = fstream(f,"utf-8") : fsuappend.open : fsuappend.loadfromfile(f) : fsuappend.position = fsuappend.size : end function
'+fs_write(file/string,value) :: valid_arguments, fswrite, \write string using fswrite()\
function fs_write(f,s) : dim b : call valid_arguments("fs_write",array(f,s),array("file/string","value")) : set b = fswrite(f) : b.writetext(s) : call b.savetofile(f,2) : fs_write = len(s) : end function
'+fs_writeline(file/string,value) :: valid_arguments, fswrite, \write string using fswrite()\
function fs_writeline(f,s) : dim b : call valid_arguments("fs_writeline",array(f,s),array("file/string","value")) : set b = fswrite(f) : call b.writetext(s,1) : call b.savetofile(f,2) : fs_writeline = len(s) : end function

'# log #
'flog_init() :: CSCRIPTLAUNCH, FUNCTION_FLOG_INIT, FUNCTION_FLOG_TYPENAME, FUNCTION_FLOG_FILENAME, buildpath, FUNCTOIN_FLOG_LOGDIR, iif, eau, ynd, basename, parentfolder \\
function flog_init() : if isempty(CSCRIPTLAUNCH) then : CSCRIPTLAUNCH = iif(iscscript(),true,false) : end if : if not CSCRIPTLAUNCH and FUNCTION_FLOG_TYPENAME = "flog0" then : FUNCTION_FLOG_INIT = true : FUNCTION_FLOG_TYPENAME = "flog1" : wscript.echo("'FUNCTION_FLOG_TYPENAME' is changed to '"&FUNCTION_FLOG_TYPENAME&"'") : flog("'FUNCTION_FLOG_TYPENAME' is changed to '"&FUNCTION_FLOG_TYPENAME&"'") : end if : if isempty(FUNCTION_FLOG_FILENAME) then : select case FUNCTION_FLOG_TYPENAME : case "flog2" : FUNCTION_FLOG_FILENAME = buildpath(FUNCTOIN_FLOG_LOGDIR, buildpath(iif(eau("logbase"),aan("logbase"),""),ynd(yyyynndd)&".log")) : case else : FUNCTION_FLOG_FILENAME = buildpath(FUNCTOIN_FLOG_LOGDIR, basename(wscript.scriptname)&".log") : end select : call mkdir(parentfolder(FUNCTION_FLOG_FILENAME)) : end if : end function
'+flogname() :: FUNCTION_FLOG_FILENAME, flog_init \\
function flogname() : if isempty(FUNCTION_FLOG_FILENAME) then : call flog_init() : end if : flogname = FUNCTION_FLOG_FILENAME : end function
'+flogepid() :: FUNCTION_FLOG_EPID, flog_init\\
function flogepid() : if isempty(FUNCTION_FLOG_EPID) then : FUNCTION_FLOG_EPID = rndstr(3): end if : flogepid = FUNCTION_FLOG_EPID : end function
'--
'+flog(*) :: FUNCTION_FLOG_INIT, flog_init, FUNCTION_FLOG_TYPENAME, dumper \prototype of flog* functions.\ 
function flog(s) : if isempty(FUNCTION_FLOG_INIT) then : call flog_init() : end if : if not isvalue(s) then : flog("(flog) fallback ..") : dumper(s) : else : flog = getref(FUNCTION_FLOG_TYPENAME)(s) : end if : end function
'+flog0(*) :: datetime, flog \write to console\
function flog0(s) : wscript.stdout.writeline(datetime()&vbtab&s) : flog0 = len(s) : end function
'+flog1(*) :: ftsappend, flogname, datetime, flog \write to scriptname.log\
function flog1(s) : ftsappend(flogname()).writeline(datetime()&vbtab&s) : flog1 = len(s) : end function
'+flog2(*) :: ftsappend, flogname, datetime, flog \write to date.log\
function flog2(s) : ftsappend(flogname()).writeline(datetime()&vbtab&s) : flog2 = len(s) : end function
'+flog3(*) :: FUNCTION_FLOG_EPID, rndstr, afso, flogname, FUNCTION_FLOG_ROTATE_MAXCOUNT, e, filename, ftsappend \write to scriptname.log rotate by each execution\
function flog3(s) : dim b : if isempty(FUNCTION_FLOG_EPID) then : call flogepid() : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT) then : afso.deletefile flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT : end if : for b=FUNCTION_FLOG_ROTATE_MAXCOUNT to 1 step -1 : if e(flogname()&"."&b) then : afso.getfile(flogname()&"."&b).name = filename(flogname()&"."&b+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : end if : end if : ftsappend(flogname()).writeline(datetime()&vbtab&s) : flog3 = len(s) : end function
'+fllog4(*) :: e, flogname, ftsread, FUNCTION_FLOG_ROTATE_MAXCOUNT, afso, ynd, ftswrite, filename \write to scriptname.log rotate by each day\
function flog4(s) : dim b,t : t = now() : if e(flogname()) then : if not left(ftsread(flogname()).readline,8) = year(t)&right("0"&month(t),2)&right("0"&day(t),2) then : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT) then : afso.deletefile flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT : end if : for b=FUNCTION_FLOG_ROTATE_MAXCOUNT to 1 step -1 : if e(flogname()&"."&b) then : afso.getfile(flogname()&"."&b).name = filename(flogname()&"."&b+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : end if : ftswrite(flogname()).writeline(ynd("yyyynndd")) : end if : else : ftswrite(flogname()).writeline(ynd("yyyynndd")) : end if : ftswrite(flogname()).writeline(datetime()&vbtab&s) : flog4 = len(s) : end function
'+flog5(*) :: e, flogname, afso, FUNCTION_FLOG_ROTATE_MAXSIZE, FUNCTION_FLOG_ROTATE_MAXCOUNT, filename, ftswrite \write to scritpname.log rotate by filesize limit\
function flog5(s) : dim b : if e(flogname()) then : if afso.getfile(flogname()).size >= FUNCTION_FLOG_ROTATE_MAXSIZE then : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT) then : afso.deletefile flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT : end if : for b=FUNCTION_FLOG_ROTATE_MAXCOUNT to 1 step -1 : if e(flogname()&"."&b) then : afso.getfile(flogname()&"."&b).name = filename(flogname()&"."&b+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : end if : end if : end if : ftswrite(flogname()).writeline(datetime()&vbtab&s) : flog5 = len(s) : end function : 
'+flog6(*) :: e, flogname, ftsread, yndHMS, FUNCTION_FLOG_ROTATE_PATTERN, FUNCTION_FLOG_ROTATE_MAXCOUNT, afso, filename, \write to scriptname.log rotate by time string pattern\
function flog6(s) : dim b : if e(flogname()) then : if not ftsread(flogname()).readline = yndHMS(FUNCTION_FLOG_ROTATE_PATTERN) then : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT) then : afso.deletefile flogname()&"."&FUNCTION_FLOG_ROTATE_MAXCOUNT : end if : for b=FUNCTION_FLOG_ROTATE_MAXCOUNT to 1 step -1 : if e(flogname()&"."&b) then : afso.getfile(flogname()&"."&b).name = filename(flogname()&"."&b+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : end if : ftswrite(flogname()).writeline(yndHMS(FUNCTION_FLOG_ROTATE_PATTERN)) : end if : else : ftswrite(flogname()).writeline(yndHMS(FUNCTION_FLOG_ROTATE_PATTERN)) : end if : ftswrite(flogname()).writeline(datetime()&vbtab&s) : flog6 = len(s) : end function

'# file utilities #
'+fcut(file/string, integer/long, integer/long) :: class:rb, valid_arguments, e, cerr, ERR_FUNCTION_FCUT, ftswrite, ftsread \if end line has EOF only, function returns empty. \
function fcut(f,sl,el) : dim b, rb, ll, r : r = array() : set rb = new rb : call valid_arguments("fcut",array(f,sl,el),array("file/string","integer/long","integer/long")) : if not e(f) then : cerr("(fcut) "&f&" is missing.") : err.raise ERR_FUNCTION_FCUT, "'"&f&"' is missing ", "ERR_FUNCTION_FCUT" : end if : ll = ftswrite(f).line : if not ((sl>0 and sl<=ll) and (el>0 and el<=ll) and sl<=el) then : cerr("(fcut) invalid range ("&sl&" to "&el&")") : err.raise ERR_FUNCTION_FCUT, "invalid range ("&sl&" to "&el&")", "ERR_FUNCTION_FCUT" : end if : set b = ftsread(f) : do until b.line = sl : b.skipline : loop : rb.size = el-sl+1 : do until b.line = el : rb.value = b.readline : loop : if not b.atendofstream then : rb.value = b.readline : end if : if el=b.line and b.column=1 then : rb.value = empty : end if : fcut = rb.values : end function : '+ftailn(file/string,integer/long) :: valid_arguments, e, cerr, ERR_FUNCTION_FTAILN, ftswrite, echo, fcut \implement with fcut()\
function ftailn(f,n) : dim b,ll : call valid_arguments("ftailn",array(f,n),array("file/string","integer/long")) : if not e(f) then : cerr("(ftailn) '"&f&"' is missing.") : err.raise ERR_FUNCTION_FTAILN, "'"&f&"' is missing ", "ERR_FUNCTION_FTAILN" : end if : ll = ftswrite(f).line : if n>ll then : echo("(ftailn) '"&n&"' is out of range, fallback to '"&ll&"'") : n = ll : end if : b = fcut(f, ll-n+1, ll) : ftailn = b : end function
'+fheadn(file/string,integer/long) :: valid_arguments, e, cerr, ERR_FUNCTION_FHEADN, ftswrite, echo, fcut \implement with fcut()\
function fheadn(f,n) : dim b, ll : call valid_arguments("fheadn",array(f,n),array("file/string","integer/long")) : if not e(f) then : cerr("(fheadn) '"&f&"' is missing.") : err.raise ERR_FUNCTION_FHEADN, "'"&f&"' is missing ", "ERR_FUNCTION_FHEADN" : end if : ll = ftswrite(f).line : if n>ll then : echo("(ftailn) '"&n&"' is out of range, fallback to '"&ll&"'") : n = ll : end if : b = fcut(f, 1, n) : fheadn = b : end function
'+fhead(file/string) :: fheadn
function fhead(f) : fhead = fheadn(f,1) : end function
'+ftail(file/string) :: ftailn
function ftail(f) : ftail = ftailn(f,1) : end function
'+fcat(file/string) :: valid_arguments, e, cerr, ERR_FUNCTION_FCAT, ftsread \\
function fcat(f) : call valid_arguments("fcat",array(f),array("file/string")) : if not e(f) then : cerr("(fcat) '"&f&"' is missing. ") : err.raise ERR_FUNCTION_FCAT, "'"&f&"' is missing ", "ERR_FUNCTION_FCAT" : end if : fcat = ftsread(f).readall : end function
'+farray(string) :: f2a
function farray(f) : farray = f2a(f) : end function
'?ftouch(file/string) :: valid_arguments, e, afso, aapp, parentfolder, filename \\
function ftouch(f) : dim b : call valid_arguments("ftouch",array(f),array("file/string")) : if not e(f) then : afso.createtextfile(f) : else : set b = afso.getfile(f) : aapp.namespace(parentfolder(b.path)).parsename(filename(b.path)).ModifyDate = now() : end if : ftouch = e(f) : end function
'+fcleanup(file/string) :: vlid_arguments, e, cerr, ERR_FUNCTION_FCLEANUP, f2v, FUNCTION_FCLEANUP_BLOCK_REMOVE, FUNCTION_FCLEANUP_LINE_REMOVE, FUNCTION_FCLEANUP_LINE_REMOVE2, FUNCTION_FCLEANUP_LINE_REMOVE3, FUNCTION_FCLEANUP_STRING_BRACE, rremove, rmatch, push \\
function fcleanup(f) : dim b,buf,flg,p,r : call valid_arguments("fcleanup",array(f),array("file/string")) : if not e(f) then : cerr("(fcleanup) '"&f&"' is missing") : err.raise ERR_FUNCTION_FCLEANUP, "'"&f&"' is missing", "ERR_FUNCTION_FCLEANUP" : end if : r = array() : b = f2v(f) : for each p in FUNCTION_FCLEANUP_BLOCK_REMOVE : b = rremove(b,p(0)&"(\n|.)+?"&p(1)) : next : for each buf in split(b,vbnewline) : for each p in FUNCTION_FCLEANUP_LINE_REMOVE : if rmatch(buf,"^\s*"&p&".*$") then : buf = rremove(buf,"^\s*"&p&".*$") : end if : next : if not rmatch(buf,"^\s*$") then : for each p in FUNCTION_FCLEANUP_LINE_REMOVE2 : if rmatch(buf,p&".*$") then : buf = rremove(buf, p&"[^"&FUNCTION_FCLEANUP_STRING_BRACE&"]*$") : end if : next : buf = rremove(buf,"\s*$") : for each p in FUNCTION_FCLEANUP_LINE_REMOVE3 : if rmatch(buf,p&"[^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"][^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"]*[^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"]$") then : buf = rremove(buf,p&"[^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"][^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"]*[^"&FUNCTION_FCLEANUP_STRING_BRACE&p&"]$") : end if : next : call push(r,rremove(buf,"\s*$")) : end if : next : fcleanup = r : end function : 
'+fgrep(file/string,string) :: valid_arguments, e, cerr, ERR_FUNCTION_FGREP, ftsread, rmatch, push \\
function fgrep(f,p) : dim b,buf,r : call valid_arguments("fgrep",array(f,p),array("file/string","string")) : if not e(f) then : cerr("(fgrep) '"&f&"' is missing.") : err.raise ERR_FUNCTION_FGREP, "'"&f&"' is missing.", "ERR_FUNCTION_FGREP" : end if : r = array() : set b = ftsread(f) : do until b.atendofstream : buf = b.readline : if rmatch(buf,p) then : call push(r,buf) : end if : loop : fgrep = r : end function

'# threads #
'?th_do(array) :: valid_arguments, echo, push, th_limitcheck, th_done \(cmd_string_array), for use to see sample.txt, function returns exitcode summary. if one of cmds failed, return false.\
function th_do(cmdlist) : dim b, cmds, flgs, ret : ret=true : call valid_arguments("th_do",array(cmdlist),array("array")) : cmds = array() : echo("(th_do) add jobs ("&ubound(cmdlist)+1&") using pexec(). ") : for each b in cmdlist : if typename(b)=typename("") then : call push(cmds, pexec(b)) : call th_limitcheck(cmds) : end if : next : flgs = th_done(cmds) : for b=0 to ubound(flgs) : echo(""""&cmdlist(b)&""" exit("&flgs(b)&")") : if flgs(b)>0 then : ret = false : end if : next : th_do = ret : end function
'th_limitcheck(array) :: valid_arguments,FUNCTION_TH_LIMITCHECK_CPUCOUNT, echo, usleep \(wshexec_array), th_limitcheck() using with th_do()\
function th_limitcheck(cmds) : dim cmd, s : s = 0 : call valid_arguments("th_limitcheck",array(cmds),array("array")) : if ubound(cmds)+2 <= FUNCTION_TH_LIMITCHECK_CPUCOUNT then : exit function : else : echo("(th_limitcheck) encountered threads limitation("&FUNCTION_TH_LIMITCHECK_CPUCOUNT&")") : do : s = 0 : for each cmd in cmds : if cmd.status = 0 then : s=s+1 : end if : next : usleep(100) : loop until s < FUNCTION_TH_LIMITCHECK_CPUCOUNT : end if : end function : 
'+th_done(array) :: valid_arguments, echo, usleep, push \(wshexec_array), th_done() using with th_do(), function returns cmd.exitcode array. \
function th_done(cmds) : dim cmd, flg : call valid_arguments("th_done",array(cmds),array("array")) : echo("(th_done) wait for all of command is completed.") : do : flg = true : for each cmd in cmds : if cmd.status=0 then : flg = false : end if : next : usleep(100) : loop until flg : echo("(th_done) jobs ("&ubound(cmds)+1&") are done.") : flg = array() : for each cmd in cmds : call push(flg, cmd.exitcode) : next : th_done = flg : end function

'# xml #
'*xml(string) :: valid_arguments, cerr \(dom_string) dom_string is such as "<root><child/></root>"\
function xml(s) : dim a : set a = axml() : call valid_arguments("xml",array(s),array("string")) : if a.loadxml(s) then : set xml = a : else : cerr("(xml) '"&s&"' is invalid xml.") : end if : end function
'*fxml(string/file) :: valid_arguments, isfile, e, cerr, ERR_FUNCTION_FXML \\
function fxml(fn) : dim a,f : set a = axml() : call valid_arguments("fxml",array(fn),array("string/file")) : if isfile(fn) then : f = fn.path : else : f = fn : end if : if not e(f) then : cerr("(fxml) not exists file '"&f&"'") : err.raise ERR_FUNCTION_FXML, "not exists file '"&f&"'","ERR_FUNCTION_FXML"  : end if : if a.load(f) then : set fxml = a : else : cerr("(fxml) '"&f&"' is not xml document.") : err.raise ERR_FUNCTION_FXML, "'"&f&"' is not xml document.","ERR_FUNCTION_FXML"  : end if : end function : 

'# class #
'wm for wmi
class wm
private w
'wm_class_initialize() :: adic, dic, wm_set_computer, iecho
private sub class_initialize : set w = adic() : call dic(w,"islocalusewmi",isusewmi()) : if w("islocalusewmi") then : set_computer(anet.computername) : else : iecho("(wm.class_initialize) => this computer cannot use wmi.") : end if : end sub
'wm_class_terminate() :: iecho, CLASS_WM_TERMINATE_WAITTIME
private sub class_terminate : set w = nothing : iecho("(wm.class_terminate) => terminating wm...") : wscript.sleep CLASS_WM_TERMINATE_WAITTIME : end sub
'wm_set_computer() :: dic, wm_isvalidcomputer, wm_isvalidclass, ed
private sub set_computer(t) : call dic(w,"computer",t) : call dic(w,"isvalidcomputer",isvalidcomputer()) : if ed(w,"class") then : call dic(w,"isvalidclass",isvalidclass()) : end if : end sub
'wm_computer() :: isstring, wm_set_computer, iecho
public property let computer(t) : if isstring(t) then : set_computer(t) : else : iecho("(wm.computer) => wants (string)") : end if : end property
'wm_get_computer() ::  
public property get computer : computer = w("computer") : end property
'?wm_isvalidcomputer() :: dic, isping, 
private function isvalidcomputer() : call dic(w,"isping",isping(w("computer"))) : if w("isping") then : on error resume next : call dic(w,"srvex",getobject("winmgmts:\\"&w("computer")&"\root\cimv2")) : isvalidcomputer = not (err.number <> 0) : err.clear : else : isvalidcomputer = false : end if : if not isvalidcomputer then : set w("srvex") = nothing : end if : end function
'wm_set_class() :: dic, wm_isvalidclass
private sub set_class(c) : call dic(w,"class",c) : call dic(w,"isvalidclass",isvalidclass()) : end sub
'wm_let_class() :: isstring, wm_set_class, iecho, dic, wm_isvalidclass
public property let [class](c) : if isstring(c) then : set_class(c) : else : iecho("(wm.class) => wants (string)") : end if : call dic(w,"isvalidclass",isvalidclass()) : end property
'?wm_isvalidclass() :: dic, 
private function isvalidclass() : if w("isping") then : on error resume next : call dic(w,"objex",getobject("winmgmts:\\"&w("computer")&"\root\cimv2:"&w("class"))) : call dic(w,"objset",getobject("winmgmts:\\"&w("computer")&"\root\cimv2").instancesof(w("class"))) : isvalidclass = not (err.number <> 0) : err.clear : else : isvalidclass = false : end if : if not isvalidclass then : set w("objectex") = nothing : set w("objectset") = nothing : end if : end function
'*wm_execquery() :: iecho
public function execquery() : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : set execquery = w("srvex").execquery("select * from "&w("class")) : else : iecho("(wm.execquery) => unfilled condition. check computer/class name or pinging to host") : end if : end function
'*wm_execquery2d() :: adic, dic, iecho
public function execquery2d() : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : dim d,a,b,c,count : count = 0 : set d = adic() : for each a in w("srvex").execquery("select * from "&w("class")) : set c = adic() : for each b in a.properties_ : call dic(c, b.name, b.value) : next : call dic(d,count,c) : count = count + 1 : next : set execquery2d = d : else : iecho("(wm.execquery2d) => unfilled condition. check computer/class name or pinging to host") : end if : if not isobject(execquery2d) then : set execquery2d = adic() : end if : end function
'*wm_q() :: wm_execquery
public function q() : set q = execquery() : end function
'*wm_q2d() :: wm_execquery2d
public function q2d() : set q2d = execquery2d() : end function
'*wm_filteredquery(string) :: isstring, wm_hasproperty, eecho, iecho
public function filteredquery(f) : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : if isstring(f) then : dim q : set q = w("srvex").execquery("select "&f&" from "&w("class")) : if not hasproperty(f) then : eechon("(wm.filteredquery) => return_object has no such property('"&f&"') on class('"&w("class")&"')") : set filteredquery = nothing : else : set filteredquery = q : end if : else : iecho("(wm.filteredquery) => wants (string)") : end if : else : iecho("(wm.filteredquery) => unfilled condition. check computer/class name or pinging to host") : end if : end function
'*wm_filteredquery2d(string) :: isstring, adic, wm_hasproperty
public function filteredquery2d(f) : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : if isstring(f) then : dim d,a,b,c,count,q : count = 0 : set d = adic() : set q = w("srvex").execquery("select "&f&" from "&w("class")) : if not hasproperty(f) then : eechon("(wm.filteredquery2d) => return_object has no such property('"&f&"') on class('"&w("class")&"')") : set filteredquery2d = nothing : else : for each a in q : set c = adic() : for each b in a.properties_ : call dic(c, b.name, b.value) : next : call dic(d,count,c) : count = count + 1 : next : set filteredquery2d = d : end if : else : iecho("(wm.filteredquery2d) => wants (string)") : end if : else : iecho("(wm.filteredquery2d) => unfilled condition. check computer/class name or pinging to host") : end if : if not isobject(filteredquery2d) then : set filteredquery2d = adic() : end if : end function
'*wm_fq(string) :: wm_filteredquery
public function fq(f) : set fq = filteredquery(f) : end function
'*wm_fq2d(string) :: wm_filteredquery2d
public function fq2d(f) : set fq2d = filteredquery2d(f) : end function
'?wm_hasproperty(string) :: isstring, rmatchi, iecho
private function hasproperty(f) : hasproperty = false : if isstring(f) then : dim a,b : for each a in q() : for each b in a.properties_ : if rmatchi(b.name,f) then : hasproperty = true : exit for : end if : next : exit for : next : else : iecho("(wm.hasproperty) => wants (string)") : end if : end function : 
'wm_g(string) :: \\
public function g(s) : set g = w("srvex").get(s) : end function
'wm_dumper() :: \\
public function dump() : dumper(w) : end function
end class

'rb for ring buffer
class rb
private sz,buf,ind,flg,mflg
'rb_class_initialize() :: rb_let_size \\
private sub class_initialize() : buf = array() : mflg = array() : size = 1 : flg = false : end sub
'rb_class_terminate() :: \\
private sub class_terminate() : end sub
'+rb_get_size() :: \\
public property get size : size = sz : end property
'+rb_get_buffer() :: \\
public property get buffer : buffer = buf : end property
'?rb_get_flag() :: \\
public property get flag : flag = flg : end property
'+rb_get_mflag() :: \\
public property get mflag : mflag = mflg : end property
'+rb_get_value() :: \\
public property get value : value = buf(ind) : end property
'+rb_get_pos() :: \\
public property get pos : pos = ind : end property

'+rb_get_values() :: \\
public property get values : values = buf : end property

'rb_let_size(integer/long) :: valid_arguments, cerr \\
public property let size(n) : call valid_arguments("rb_let_size",array(n),array("integer/long")) : if n<1 then : cerr("(rb_let_size) invalid size") : exit property : end if : sz = n-1 : redim buf(sz) : redim mflg(sz) : ind = 0 : flg = false : end property
'rb_let_value(*) :: valid_arguments, bind, \\
public property let value(n) : call valid_arguments("rb_let_value",array(n),array("*")) : call bind(buf(ind), n) : mflg(ind) = timer : if ind+1>sz then : ind = 0 : else : ind = ind+1 : end if : flg = true : end property

'rb_dump() :: cout, iif, \\
public function dump() : dim i : for i=0 to sz : cout(iif(ind=i,"->","")&"buffer("&i&") ["&mflg(i)&"] "&typename(buf(i))&"("&iif(isobject(buf(i)),"*",buf(i))&")") : next : end function
'rb_resize(integer/long) :: cerr, \\
public function resize(n) : call valid_arguments("rb_resize",array(n),array("integer/long")) : if n<1 then : cerr("(rb_resize) invalid value") : exit function : end if : sz = n-1 : redim preserve buf(sz) : redim preserve mflg(sz) : if flg and ind>=ubound(buf)+1 then : ind=0 : end if : end function
'rb_movepos2empty() :: \\
public function movepos2empty() : dim i : for i=0 to sz : if isempty(mflg(i)) then : ind = i : exit for : end if : next : end function
'rb_movepos(integer/long) :: \\
public function movepos(n) : if not n=0 then : n = (n mod (sz+1)) : if ((ind+n) mod (sz+1))<0 then : ind = sz+1+ind+n : else : ind = ind+n : end if : end if : end function
'rb_flush()
public function flush() : redim buf(sz) : end function
end class

'<!-- this line works as delimitre -->
'script starts here

'dim conf : set conf = skelconfig()
'dumper(conf)


]]>
</script>
</job>


<!-- version of skel.wsf -->
<!-- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -->
<job id="version" error="true" debug="false">
<runtime>
<description>skel.wsf  skelv() </description>
<example>cscript skel.wsf //job:version</example>
</runtime>
<script language="VBScript">
<![CDATA[
option explicit

wscript.echo replace(replace(replace(createobject("Scripting.FileSystemObject").getfile(wscript.scriptfullname).datelastmodified," ",""),"/",""),":","")

]]>
</script>
</job>


<!-- extract skel.vbs from skel.wsf -->
<!-- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -->
<job id="extract" error="true" debug="false">
<runtime>
<description>skel.wsf  skel.vbs 
project 
</description>
<named name="project" helpstring=" '^([\w]+\\*)+?$' " type="string" retuired="false" />
<named name="overwrite" helpstring="" type="string" retuired="false" />
<example>cscript skel.wsf //job:extract [/project:PROJECT_NAME [/overwrite]]</example>
<!--
	projectname\
	+- bin\
	+- conf\
	+- log\
	+- lib\
		+- skel.vbs
//-->
</runtime>
<script language="VBScript">
<![CDATA[
option explicit

'--script starts here--
const DELIMITER = "^'<!-- this line works as delimitre -->$"
const PROJECTNAME_PATTERN = "^([\w]+\\*)+?$"
const DIRECTORY_LIST = "bin conf lib log"
dim afso : set afso = createobject("Scripting.FileSystemObject")
dim f : set f = afso.opentextfile(wscript.scriptfullname)
dim rgp : set rgp = new regexp
dim flg : flg = false
dim fwrite 'file pointer
dim buffer 'buffer
dim vbs_filename, wsf_filename 'filename
dim projectname 'projectname if set by /project

'project or else?
if wscript.arguments.named.exists("project") then
	projectname = wscript.arguments.named("project")
	if not len(projectname)>0 then
		wscript.echo "[ERR] project name is empty."
		wscript.quit(1)
	end if
	rgp.pattern = PROJECTNAME_PATTERN
	if not rgp.test(projectname) then
		wscript.echo "[ERR] project name has not allowed character, use only '([\w_]\\*)+?'"
		wscript.quit(1)
	end if
end if

'build path
if not isempty(projectname) then
	if instr(projectname,"\")>0 then
		wsf_filename = left(projectname, instr(projectname,"\")-1)&".wsf"
	else
		wsf_filename = projectname&".wsf"
	end if
	wsf_filename = afso.buildpath(projectname, wsf_filename)
	vbs_filename = afso.buildpath(projectname, "lib\"&afso.getbasename(wscript.scriptname)&".vbs")
	if afso.folderexists(afso.getparentfoldername(vbs_filename)) then
		if not wscript.arguments.named.exists("overwrite") then
			wscript.echo "[ERR] '"&projectname&"' project is already exist."
			wscript.quit(2)
		end if
	end if
	call mkdir(afso.getparentfoldername(vbs_filename))
	for each buffer in split(DIRECTORY_LIST)
		if not afso.folderexists(afso.buildpath(projectname, buffer)) then
			call mkdir(afso.buildpath(projectname, buffer))
		end if
	next
else
	vbs_filename = afso.getbasename(wscript.scriptname)&".vbs"
end if

'set pointer to write for `vbs_filename`
set fwrite = afso.opentextfile(vbs_filename, 2, true)

'write out to `vbs_filename`
''skelv
fwrite.writeline("const skelv = """&replace(replace(replace(afso.getfile(wscript.scriptfullname).datelastmodified," ",""),"/",""),":","")&"""")
''functions
rgp.pattern = DELIMITER
do until f.atendofstream
	buffer = f.readline
	if rgp.test(buffer) then
		flg = not flg
	end if 
	if flg then
		'wscript.echo buffer
		fwrite.writeline(buffer)
	end if
loop

'write out to `wsf_filename`
if not isempty(wsf_filename) then
	set fwrite = afso.opentextfile(wsf_filename, 2, true)
	fwrite.writeline("<?xml version=""1.0"" encoding=""Shift_JIS"" standalone=""yes"" ?>")
	fwrite.writeline("<package><job error=""true"" debug=""false""><runtime>")
	fwrite.writeline("<description>  </description>")
	fwrite.writeline("<!-- skel.vbs  //-->")
	fwrite.writeline("<named name=""logbase"" helpstring="""" type=""string"" required=""false"" />")
	fwrite.writeline("<named name=""noconfigure"" helpstring=""(sensored)"" type=""string"" required=""false"" />")
	fwrite.writeline("<named name=""notypecast"" helpstring=""(sensored)"" type=""string"" required=""false"" />")
	fwrite.writeline("<named name=""configure"" helpstring=""(sensored)"" type=""string"" required=""false"" />")
	fwrite.writeline("<!-- ---- //-->")
	fwrite.writeline("</runtime>")
	fwrite.writeline("<script language=""VBScript"" src=""lib\skel.vbs""></script>")
	fwrite.writeline("<script language=""VBScript"">")
	fwrite.writeline("<![CDATA[")
	fwrite.writeline("option explicit")
	fwrite.writeline("'write logs to console as default. if you need to write to file, to set TYPENAME to flog(1|2|3|4|5|6)")
	fwrite.writeline("'FUNCTION_FLOG_TYPENAME = ""flog6"""&vbnewline)
	fwrite.writeline("'--script starts here--"&vbnewline)
	fwrite.writeline("'==functions are here=="&vbnewline)
	fwrite.write("]") : fwrite.writeline("]>")
	fwrite.write("</") : fwrite.writeline("script>")
	fwrite.write("</") : fwrite.writeline("job>")
	fwrite.write("</") : fwrite.writeline("package>")
end if

wscript.quit(0)
'==functions are here==
'recursive mkdir
function mkdir(n)
	if (instr(n,"\")>0) then
		call mkdir(afso.getparentfoldername(n))
	end if
	if not afso.folderexists(n) then
		call afso.createfolder(n)
		mkdir = true
	else
		mkdir = false
	end if
end function

]]>
</script>
</job>

<!-- shows dependence of functions and extact utility -->
<!-- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -->
<job id="deptree" error="true" debug="false">
<runtime>
<description>skel.wsf 
extract  vbs </description>
<unnamed name="FUNCTION_NAME" helpstring="" type="string" retuired="true" />
<named name="extract" helpstring=" vbs " type="string" retuired="false" />
<named name="list" helpstring="" type="string" retuired="false" />
<example>cscript skel.wsf //job:deptree {FUNCTION_NAME [/extract] | /list}</example>
</runtime>
<script language="VBScript" src="lib\dumper.vbs"></script>
<script language="VBScript" src="lib\push.vbs"></script>
<script language="VBScript">
<![CDATA[
option explicit

const DELIMITER = "^'<!-- this line works as delimitre -->$"
const DESCRIPTION = "^'(\?|\+|\*|-)*([a-zA-Z_\d]*)\((.*)\)\s*::\s*([a-zA-Z\d, _]*)(\\(.*)\\)*\s*$"
const TRIMPATTERN = ",\s*$"
dim src, fwrite
dim buffer, bufmatch, bufdic, buf
dim deps : set deps = createobject("scripting.dictionary")
dim called : set called = createobject("scripting.dictionary")
dim funcs : set funcs = createobject("scripting.dictionary")
dim rgp : set rgp = new regexp
dim flg : flg = false
dim afso : set afso = createobject("scripting.filesystemobject")
set src = afso.getfile(wscript.scriptfullname).openastextstream(1)

'read own
do until src.atendofstream
	buffer = src.readline
	rgp.pattern = DELIMITER
	if rgp.test(buffer) then
		flg = not flg
	end if
	if flg then
		rgp.pattern = DESCRIPTION
		if rgp.test(buffer) then
			set bufmatch = rgp.execute(buffer)
			set bufdic = createobject("scripting.dictionary")
			call bufdic.add("raw", buffer)
			call bufdic.add("type", bufmatch(0).submatches(0))
			call bufdic.add("name", bufmatch(0).submatches(1))
			rgp.pattern = TRIMPATTERN
			call bufdic.add("args", split(replace(rgp.replace(bufmatch(0).submatches(2),"")," ",""),","))
			call bufdic.add("deps", split(replace(rgp.replace(bufmatch(0).submatches(3),"")," ",""),","))
			call bufdic.add("description", bufmatch(0).submatches(5))
			call funcs.add(bufmatch(0).submatches(1), src.readline)
			call deps.add(bufmatch(0).submatches(1), bufdic)
		end if
	end if
loop

dim a : a = array()
if wscript.arguments.named.exists("list") then
	for each buffer in deps
		call push(a,buffer)
	next
	call qsort(a,0,ubound(a))
	for each buffer in a
		cstdw buffer&", "
	next
	wscript.quit(0)
end if

if wscript.arguments.unnamed.count < 1 then
	cerr "missing arguments"
	wscript.arguments.showusage
	wscript.quit(1)
end if

if not deps.exists(wscript.arguments.unnamed(0)) then
	cstd wscript.arguments.unnamed(0)&"() is not defined."
	wscript.quit(0)
end if

'show dependence
cstd(wscript.arguments.unnamed(0)&"() depend on:")
call tree(0, wscript.arguments.unnamed(0), deps(wscript.arguments.unnamed(0))("deps"))

'show applied to 
cstd("")
cstd(wscript.arguments.unnamed(0)&"() applied to:")
for each buffer in deps
	for each buf in deps(buffer)("deps")
		if buf = wscript.arguments.unnamed(0) then
			cstd " "&buffer&"()"
		end if
	next
next

if wscript.arguments.named.exists("extract") then
	set fwrite = afso.opentextfile(wscript.arguments.unnamed(0)&".vbs", 2, true)
	for each buffer in called
		if funcs.exists(buffer) then
			fwrite.writeline(deps(buffer)("raw"))
			fwrite.writeline(funcs(buffer))
		else
			cstd "'missing "&buffer&"()"
			fwrite.writeline("'missing "&buffer&"()")
		end if
	next
	cstd("")
	cstd("write out '"&wscript.arguments.unnamed(0)&"' function and dependencies to "&wscript.arguments.unnamed(0)&".vbs")
end if




wscript.quit(0)
'==functions are here==
function cstd(s) : wscript.stdout.writeline(s) : end function
function cstdw(s) : wscript.stdout.write(s) : end function
function cerr(s) : wscript.stderr.writeline("[ERR ] "&s) : end function
function tree(i, fn, dp)
	dim f
	if not called.exists(fn) then
		call called.add(fn, fn)
	end if
	cstd string(i," ")&fn&"()"
	for each f in dp
		if not called.exists(f) then
			if deps.exists(f) then
				call tree(i+1, f, deps(f)("deps"))
			else
				rgp.pattern = "[A-Z_][A-Z_0-9]*"
				if rgp.test(f) then
					cstd string(i+1," ")&f&" [CONST]"
				else
					cstd string(i+1," ")&f&"() [UNDEFINED]"
					cstd "[ERR] undefined function. "&f&"()"
				end if
			end if
		else
			cstd string(i+1," ")&f&"() ..."
		end if
	next
end function
]]>
</script>
</job>
</package>
