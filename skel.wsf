<?xml version="1.0" encoding="Shift_JIS" standalone="yes" ?>
<package>
<job error="true" debug="false">
<script language="VBScript">
<![CDATA[
option explicit
'<!-- this line works as delimitre -->

'/*
' error message:
' if occur error of function, messages display to console by 'cerr()'
' (FUNCTIONNAME): MESSAGE ([PROPERTIES])*
'
' function description:
' arguments type are empty, null, integer, long, single, double, currency, date, string, object, error, boolean, variant, dataObject, byte, array,
'  object_TYPE, 
'*/

'= global definitions
'==========================================================
CONST CLASS_WM_TERMINATE_WAITTIME            = 1000
CONST FUNCTION_ACTSEND_DELAY_COUNT           = 50
CONST FUNCTION_ACTSEND_WAIT_TIME             = 100
CONST FUNCTION_NEWCMD_TITLE_STRING           = "INFRA___"
CONST FUNCTION_SEND_MAIL_ALWAYS_SEND         = false 'if false function returns object, for send a mail -> call method send_mail(param,...).send()
CONST FUNCTION_SEND_MAIL_CONFIGURE_STRINGS   = "http://schemas.microsoft.com/cdo/configuration"
CONST FUNCTION_PMAILER_SCHEMA_STRING         = "http://schemas.microsoft.com/cdo/configuration"
CONST FUNCTION_DICTIONARY_FORMAT             = "^(.+?)\s*=>\s*(.*)$" 'for string, -> "^{(.+?)\s*=>*\s*(.*)(,(.+)\s*=>*\s*(.*))*}$"
CONST FUNCTION_RNDSTRN_STRING                = ">N5`=/9&gQIS%K;?R#lD$4anwqXWr(+^F-\ETV}{\7bC:m]~O1kz!JP[sY8xd0AM<Z3U Gf.v*_6L@'juHBoteih)y2,pc"
CONST FUNCTION_EXEC_RETURNS_STRINGS          = false
CONST FUNCTION_PECHO_TIMEOUT_TIME            = 10
CONST FUNCTION_CONFIGURE_SET_EMPTY           = false
CONST FUNCTION_TH_LIMITCHECK_WAIT_TIME       = 500
CONST FUNCTION_TH_LIMITCHECK_WAIT            = true
CONST FUNCTION_TH_DO_TIME_PER_LAUNCH         = 100
CONST FUNCTION_DB_QUERY2_CMD                 = "sqlcmd.exe " 'fix me!
CONST FUNCTION_DB_QUERY2_CMD_OPTION          = " -E -l 1 -t 1 -w 10000 -s , -W -u -r1" 'fix me!
CONST FUNCTION_ISPING_WAIT_TIME              = 100
CONST FUNCTION_S2A_PADDING                   = false
CONST FUNCTION_S2A_PADDING_CHAR              = " " 'a character
CONST FUNCTION_UNIXTIME_OFFSET               = -9 'JST 
CONST FUNCTION_UNIXTIME_BASIS                = "1970/01/01 00:00:00"

'= global variables
'==========================================================

'-- flog
'----------------------------------------------------------
dim FUNCTION_FLOG_TYPENAME                   'flog0 -> logged to console (and echo(), echon() function will be set to disable)
                                             'flog1 -> logged to `FUNCTION_FLOG_FILENAME`.log (no log-rotate)
                                             'flog2 -> logged to "./yyyymmdd.log"
                                             'flog3 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated at each execution
                                             'flog4 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated at each day
                                             'flog5 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated at each size
                                             'flog6 -> logged to `FUNCTION_FLOG_FILENAME`.log, rotated pattern by FUNCTION_FLOG_ROTATEPATTERN
                                             'if set /logbase option, adopt aan("logbase").log for log-filename on flog[1345]
    FUNCTION_FLOG_TYPENAME                   = "flog0"
dim FUNCTOIN_FLOG_LOGDIR                     'default log directory is created on same path of script.
    FUNCTOIN_FLOG_LOGDIR                     = buildpath(parentfolder(wscript.scriptfullname), "log")
dim FUNCTION_FLOG_FILENAME                   'default log filename is `FUNCTOIN_FLOG_LOGDIR`\`scriptname`.log set by flogname() function
    FUNCTION_FLOG_FILENAME                   = empty
dim FUNCTION_FLOG_EPID                       'emulated pid
dim FUNCTION_FLOG_ROTATE_COUNT               'rotate count for "flog3","flog4","flog5" (default 5)
    FUNCTION_FLOG_ROTATE_COUNT               = 5
dim FUNCTION_FLOG_ROTATE_FILESIZE            'rotate size for "flog5" (default 10MB)
    FUNCTION_FLOG_ROTATE_FILESIZE            = 1048576
dim FUNCTION_FLOG_PERSISTNAME                'Also has changed the name of the log file during execution, 
                                             'then the new file will not write until the end of the run.
    FUNCTION_FLOG_PERSISTNAME                = true
dim FUNCTION_FLOG_ROTATEPATTERN              'log rotate pattern for flog6(), pattern allowed ^yyyy((((mm)*dd)*hh)*nn)*$
    FUNCTION_FLOG_ROTATEPATTERN              = "yyyymmddhhnn"

'-- datetime
'----------------------------------------------------------
dim FUNCTION_DATETIME_TYPENAME               'datetime0 -> 100114165801
                                             'datetime1 -> 2010/11/41 16:58:01.12
                                             'datetime2 -> 2010/11/41 16:58:01
                                             'datetime3 -> 20101141165801
    FUNCTION_DATETIME_TYPENAME               = "datetime1"

'= functions
'==========================================================

'RETURN_TYPE FUNCTION_NAME(ARG_TYPE, ...) :: depend_FUNCTION_NAME, ... \COMMENT,...\
'RETURN_TYPE :=
' ? : boolean
' + : string | value
' * : object
'   : void
'ARG_TYPE :=
' string : string
' (specified_)*object : specified-object
' object : object
' array : array
' value : !array and !object
' void : void
' variable : hensuu

'-- #evaluation
'----------------------------------------------------------
'?e(variant) :: afso, checktype \full or relative path name\
function e(n) : if not checktype(n, array(vbArray)) then : e = afso.fileexists(n) : else : e = false : end if : end function
'?ef(variant) :: afso, checktype \\
function ef(n) : if not checktype(n, array(vbArray))  then : ef = afso.folderexists(n) : else : ef = false : end if : end function
'?ea(variant) :: aarg, checktype \check existence of named arugment (like '/opt')\
function ea(a) : if not checktype(a, array(vbArray)) then : ea = aarg.named.exists(a) : else : ea = false : end if : end function
'?eau(variant) :: ea, aan \check existence of named and usable arugment (like '/opt:value')\
function eau(a) : eau = (ea(a) and len(aan(a))>0) : end function
'?ed(dictionary_object,string) :: isdictionary \ed() == dictionary_object.exist(key_string)\
function ed(d,k) : if isdictionary(d) then : ed = d.exists(k) : else : ed = false : end if : end function
'?ecmd(string) :: env, e, absolutepath, buildpath \serach command\
function ecmd(c) : dim a,b : for each b in split(env("%path%"),";") : for each a in array("",".com",".exe",".bat",".cmd",".vbs",".js",".jar",".wsf") : if(e(buildpath(b, c&a))) then : ecmd = true : exit function : end if : next : next : ecmd = false : end function
'?iscscript() :: filename \launch by cscript?\
function iscscript() : iscscript = (instr(filename(wscript.fullname),"cscript.exe")>0) : end function
'+iif(boolean, variant, variant) :: bind \\
function iif(c,t,f) : if(c) then : call bind(iif,t) : else : call bind(iif,f) : end if : end function
'?isinteger(void) :: \\
function isinteger(v) : isinteger = cbool(vartype(v) and vbInteger) : end function
'?islong(void) :: \\
function islong(v) : islong = cbool(vartype(v) and vbLong) : end function
'?issingle(void) :: \\
function issingle(v) : issingle = cbool(vartype(v) and vbSingle) : end function
'?isdouble(void) :: \\
function isdouble(v) : isdouble = cbool(vartype(v) and vbDouble) : end function
'?iscurrency(void) :: \\
function iscurrency(v) : iscurrency = cbool(vartype(v) and vbCurrency) : end function
'?isstring(void) :: \\
function isstring(v) : isstring = cbool(vartype(v) = vbString) : end function
'?iserror(void) :: \\
function iserror(v) : iserror = cbool(vartype(v) and vbError) : end function
'?isboolean(void) :: \\
function isboolean(v) : isboolean = cbool(vartype(v) and vbBoolean) : end function
'?isvariant(void) :: \\
function isvariant(v) : isvariant = cbool(vartype(v) and vbVariant) : end function
'?isdataobject(void) :: \\
function isdataobject(v) : isdataobject = cbool(vartype(v) and vbDataObject) : end function
'?isbyte(void) :: \\
function isbyte(v) : isbyte = cbool(vartype(v) and vbByte) : end function
'?isvalue(value) :: \\
function isvalue(v) : isvalue = not (isarray(v) or isobject(v)) : end function
'?isdictionary(void) :: strcmp, adic \\
function isdictionary(v) : isdictionary = strcmp(typename(v),typename(adic())) : end function
'?ismatch(void) :: strcmp, getmatch \\
function ismatch(v) : ismatch = strcmp(typename(v),typename(getmatch("",""))) : end function
'?isnothing(void) :: strcmp \\
function isnothing(n) : isnothing = strcmp(typename(n),typename(nothing)) : end function
'?isprintable(value) :: isvalue, isnothing \\
function isprintable(o) : isprintable = isvalue(o) and not (isnull(o) or isnothing(o)) : end function
'?iswshexec(void) :: strcmp, ashell \\
function iswshexec(c) : iswshexec = strcmp(typename(c),typename(ashell.exec("cmd.exe /C"))) : end function
'?iswshexec_array(void) :: iswshexec \for th_* functions\
function iswshexec_array(c) : dim a : iswshexec_array = true : if isarray(c) then : for each a in c : if not iswshexec(a) then : iswshexec_array = false : exit for : end if : next : else : iswshexec_array = iswshexec(a) : end if : end function
'?isdb(void) :: strcmp, adb \\
function isdb(c) : isdb = strcmp(typename(c),typename(adb())) : end function
'?isroot(void) :: strcmp, afso, isvalue, ef, cerr, typedesc \\
function isroot(n) : isroot = false : if strcmp(typename(n),typename(afso.getfolder(env("%SYSTEMROOT%")))) then : isroot = n.isrootfolder : else : if isvalue(n) then : if ef(n) then : isroot = afso.getfolder(n).isrootfolder : else : cerr "(isroot): not exist directory. ["&n&"]" : isroot = false : end if : else : cerr "(isroot): invalid dictionary. ["&typedesc(n)&"]" : end if : end if : end function
'?isping(string) :: checktype, texec, iif, typedesc \\
function isping(n) : if not checktype(n, array(vbArray)) then : isping = iif(texec("ping.exe -w 1 -n 1 -f "&n).exitcode = 0, true, false) : else : cerr("(isping): wants 'string' ["&typedesc(n)&"]") : isping = false : end if : end function
'?isdirectory(void) :: ef \alias of ef()\
function isdirectory(o) : isdirectory = ef(o) : end function
'?isrgp(void) :: strcmp \\
function isrgp(o) : isrgp = strcmp(typename(o),typename(rgp(""))) : end function
'?issubmatch(void) :: strcmp, getmatch \\
function issubmatch(o) : issubmatch = strcmp(typename(o),typename(getmatch("t","(t)")(0).submatches)) : end function
'?isfile(void) :: afso, strcmp \\
function isfile(o) : isfile = strcmp(typename(o),typename(afso.getfile(wscript.scriptfullname))) : end function
'?isfolder() :: afso, strcmp \\
function isfolder(o): isfolder = strcmp(typename(o),typename(afso.getfolder(afso.getparentfoldername(wscript.scriptfullname)))) : end function
'?isinarray(array, string) :: foreach_typematch \alias of foreach_typematch()\
function isinarray(a,t) : isinarray = foreach_rmatch(a, t) : end function
'?inarray(array, value) :: foreach_strcmp \alias of foreach_strcmp()\
function inarray(a,v) : inarray = foreach_strcmp(a,v) : end function

'?isindictionary(dictionary_object, string) :: isdictionary, rmatch, iecho \\
function isindictionary(d,t)
dim b
if isdictionary(d) then
for each b in d
if rmatch(typename(d(b)),t) then
isindictionary = true
exit function
end if
next
else
iecho("(isindictionary) => wants (dictionary, regexp_string)")
end if
isindictionary = false
end function

'?indictionary(dictionary, value) :: isdictionary, iecho 
function indictionary(d,v) : dim b : if isdictionary(d) then : for each b in d : if (d(b)=v) then : indictionary = true : exit function : end if : next : else : iecho("(indictionary) => wants (dictionary, value)") : end if : indictionary = false : end function
'?isusewmi() :: 
function isusewmi() : on error resume next : call getobject("winmgmts:\\.\root\cimv2") : if err.number <> 0 then : isusewmi = false : err.clear : else : isusewmi = true : end if : end function
'?istextstream(void) :: strcmp, frs
function istextstream(v) : istextstream = strcmp(typename(v),typename(frs(wscript.scriptfullname))) : end function
'?isstream(void) :: strcmp, fsread
function isstream(v) : isstream = strcmp(typename(v),typename(fsread(wscript.scriptfullname))) : end function
'?isxml(object) :: strcmp, axml
function isxml(o) : isxml = strcmp(typename(o),typename(axml())) : end function
'?isxmlchild(object) :: strcmp
function isxmlchild(o) : isxmlchild = strcmp(typename(o),"IXMLDOMNodeList") : end function


'-- #bind
'----------------------------------------------------------
'bind(variable,void) :: 
function bind(byref k,byval v) : if(isobject(v)) then : set k = v : else k = v : end if : end function
'caller(function) :: bind \caller function\
function caller(fnc) : call bind(caller, fnc) : end function

'-- #regexpression
'----------------------------------------------------------
'*rgo(string, string) :: \(pattern_string, option [igo])\
function rgo(p,o) : set rgo = new regexp : rgo.pattern = p : rgo.ignorecase = (instr(o,"i")>0) : rgo.global = (instr(o,"g")>0) : rgo.multiline = (instr(o,"o")>0) : end function
'*rgp(string) :: \(pattern_string)\
function rgp(p) : set rgp = new regexp : rgp.pattern = p : end function
'?rmatch(string, string) :: rgp \(target_string, pattern_string)\
function rmatch(s,p) : rmatch = rgp(p).test(s) : end function
'?rmatchi(string, string) :: rgo \(target_string, pattern_string)\
function rmatchi(s,p) : rmatchi = rgo(p,"i").test(s) : end function
'*getmatch(string, string) :: rgo \(target_string, pattern_string)\
function getmatch(s,p) : set getmatch = rgo(p,"g").execute(s) : end function
'*getsubmatch(string, string) :: getmatch, \(target_string, pattern_string), pattern must inlcude ()\
function getsubmatch(s,p) : dim i,g : set g = getmatch(s,p) : if (g.count>0) then : for i=0 to g.count-1 : if (g(i).submatches.count>0) then : set getsubmatch = g(i).submatches : end if : next : end if : end function
'+rreplace(string, string, string) :: rgo \(target_string, pattern_string, replacement_string)\
function rreplace(s,p,r) : rreplace = rgo(p,"g").replace(s,r) : end function
'+rremove(string, string) :: rreplace \(target_string, pattern_string)\
function rremove(s,p) : rremove = rreplace(s,p,"") : end function

'-- #strings
'----------------------------------------------------------
'?strcmp(string, string) :: isstring, iecho \strcmp returns loose match result, strcmp("Test","test") == true\
function strcmp(s,t) : if isstring(s) and isstring(t) then : strcmp = ((instr(lcase(s),lcase(t))>0) and len(s) = len(t)) else : iecho("(strcmp) => wants (string, string), gave ("&typename(s)&", "&typename(t)&")") : strcmp = false : end if : end function
'rstrcmp(string, string) :: isstring, iecho \rstrcmp returns strict match result, rstrcmp("Test","test") == false\
function rstrcmp(s,t) : if isstring(s) and isstring(t) then : rstrcmp = (s=t) : else : iecho("(rstrcmp) => wants (string, string), gave ("&typename(s)&", "&typename(t)&")") : rstrcmp = false : end if : end function
'+dleft(string, integer) :: isstring, isinteger \delete left\
function dleft(s,n) : if isstring(s) and isinteger(n) then : if (len(s)>=n) then : dleft = right(s,len(s)-n) : else : dleft = "" : end if : end if : end function
'+eft(string, integer) :: dleft 
function eft(s,n) : eft = dleft(s,n) : end function
'+dright(string, integer) :: isstring, isinteger 
function dright(s,n) : if isstring(s) and isinteger(n) then : if (len(s)>=n) then : dright = left(s,len(s)-n) : else : dright = "" : end if : end if : end function
'+righ(string, integer) :: dright
function righ(s,n) : righ = dright(s,n) : end function
'+replicate(string, integer) :: isstring, isinteger
function replicate(s,a) : if isstring(s) and isinteger(a) then : replicate = string(a,s) : end if : end function
'+padding(value, string, integer) :: isvalue, isstring, isinteger, iecho
function padding(s,p,n) : if isvalue(s) and isstring(p) and isinteger(n) then : if(len(s)>=n) then : padding = s : else : if (len(p)>0 and n>len(s)) then : padding = string(n-len(s),p)&s : else : eechon("(padding) => invalid padding string.") : end if : end if : else : iecho("(padding) => wants (value, string, integer)") : end if : end function
'+epadding(value, string, integer) :: isvalue, isstring, isinteger, iecho
function epadding(s,p,n) : if isvalue(s) and isstring(p) and isinteger(n) then : if(len(s)>=n) then : epadding = s : else : if (len(p)>0 and n>len(s)) then : epadding = s&string(n-len(s),p) : else : eechon("(epadding) => invalid padding string.") : end if : end if : else : iecho("(epadding) => wants (value, string, integer)") : end if : end function
'+revstr(string) :: isstring, iecho
function revstr(s) : if isstring(s) then : dim c,n,i : for i=len(s) to 1 step -1 : c = mid(s,i,1) : n = n&c : next : revstr = n : else : iecho("(revstr) => wants (string)") : end if : end function
'+reverse(string) :: revstr
function reverse(s) : reverse = revstr(s) : end function

'-- #transform
'----------------------------------------------------------
'e.g. s2a("test, test1, test2",",")
'e.g. s2a("test, test1, test2",3)
'+s2a(string, value) :: isstring, isinteger, push, dleft, FUNCTION_S2A_PADDING, FUNCTION_S2A_PADDING_CHAR \\
function s2a(s,d) : if(isstring(d)) then : s2a = split(s,d) : else : if(isinteger(d)) then : dim a : a = array() : do until (len(s)<=0) : call push(a,left(s,d)) : s = dleft(s,d) : loop : if FUNCTION_S2A_PADDING then : if (len(a(ubound(a)))<d) then : a(ubound(a)) = a(ubound(a))&string(d-len(a(ubound(a))),FUNCTION_S2A_PADDING_CHAR) : end if : end if : s2a = a : else : s2a = array() : end if : end if : end function
'+f2a(string) :: e, fread, push, iecho \(filename)\
function f2a(n) : if e(n) then : dim f,o : o = array() : set f = fread(n) : do until f.atendofstream : call push(o,f.readline) : loop : f2a = o : else : iecho("(f2a) => file is missing ("&n&")") : f2a = array() : end if : end function
'+f2v(string) :: e, fcat, iecho \(filename)\
function f2v(n) : if e(n) then : f2v = fcat(n) : else : iecho("(f2v) => file is missing ("&n&")") : f2v = "" : end if : end function
'+au2a() :: aarg \skel.wsf a b c / /: /:1 => array("a","b","c")\
function au2a() : dim i,a : redim a(aarg.unnamed.count-1) : for i=0 to aarg.unnamed.count-1 : a(i) = aarg.unnamed(i) : next : au2a = a : end function
'+an2a() :: aarg, aan \skel.wsf a b c / /a /a: /a:1 => array("",empty,"a",empty,"a","","a","1") (opt_name, opt_value, ...)\
function an2a() : dim n,b,a() : redim a(0) : b = 0 : for each n in aarg.named : redim preserve a((b+1)*2-1) : a(2*b) = n : a(2*b+1) = aan(n) : b = b + 1 : next : an2a = a : end function
'*f2drs(string, string, integer, integer) :: f2d \(filename, array(regexp_pattern, keyno, value_no))\
function f2drs(n,format, keyno, valno) : set f2drs = f2d(n,array(format, keyno, valno)) : end function
'*f2dr(string, string, string) :: f2d \(filename, array(regexp_pattern, delim_string))\
function f2dr(n, format, delim) : set f2dr = f2d(n,array(format, delim)) : end function
'e.g. f2d("test.txt", ",")
'e.g. f2d("test.txt", array("^.*=.*$","="))
'e.g. f2d("test.txt", array("^(.*)=(.*)$",0,1))
'*f2d(string, array) :: adic, e, frs, rmatch, iif, getmatch, ed, eecho, max \f2d has 3 pattern to transform. (str,str), (str,arr(str,str)) or (str,arr(str,int,int))\
function f2d(n,arr) : dim d : set d = adic() : if e(n) then : dim f,b : set f = frs(n) : if isarray(arr) then : if (ubound(arr)=2) then : if rmatch(arr(1),"^\d\d*$") and rmatch(arr(2),"^\d\d*$") then : dim m : m = max(arr(1),arr(2)) + 1 : do until f.atendofstream : b = f.readline : if rmatch(b,arr(0)) then : set b = getmatch(b,arr(0)) : if (b(0).submatches.count>=m) then : if ed(d, trim(b(0).submatches(arr(1)))) then : d(trim(b(0).submatches(arr(1)))) = b(0).submatches(arr(2)) : else : d.add trim(b(0).submatches(arr(1))), b(0).submatches(arr(2)) : end if : else : eechon("(f2d) => illegal submatches("&b(0).submatches.count&":"&arr(1)&","&arr(2)&")") : exit do : end if : end if : loop : end if : else : do until f.atendofstream : b = f.readline : if rmatch(b,arr(0)) then : b = split(b,arr(1)) : if ed(d,trim(b(0))) then : d(trim(b(0))) = b(1) : else : d.add trim(b(0)), b(1) : end if : end if : loop : end if : else : do until f.atendofstream : b = f.readline : if(instr(b,arr)) then : b = split(b,arr) : if ed(d,trim(b(0))) then : d(trim(b(0))) = b(1) : else : d.add trim(b(0)), b(1) : end if : end if : loop : end if : end if : set f2d = d : end function
'+a2s(array, string) :: isstring 
function a2s(a,s) : if isarray(a) and isstring(s) then : dim v : for v = 0 to ubound(a)-1 : a2s = a2s&a(v)&s : next : a2s = a2s&a(v) : else : a2s = empty : end if : end function
'*a2d(array) :: dictionary, iecho,FUNCTION_DICTIONARY_FORMAT
function a2d(a) : if isarray(a) then : dim f,v : f = true : for each v in a : if not (instr(v,"=>")>0) then : f = false : end if : next : if f then : set a2d = dictionary(a) : else : iecho("(a2d) => wants (array) have '"&FUNCTION_DICTIONARY_FORMAT&"' pattern.") : set a2d = adic() : end if : : else : iecho("(a2d) => wants (array)") : end if end function
'*s2d(string) :: dictionary, rmatch, iecho, adic, FUNCTION_DICTIONARY_FORMAT
function s2d(s) : if isstring(s) then : if rmatch(s,"^{.*}$") then : set s2d = dictionary(s) : else : iecho("(s2d) => wants (string) have'"&replace(replace(FUNCTION_DICTIONARY_FORMAT,"^","^{"),"$","}$")&"' pattern.") : set s2d = adic() : end if : else : iecho("(s2d) => wants (string)") : end if: end function
'+d2a(dictionary) :: isdictionary, isstring, iif, strcmp, iecho \\
function d2a(d) : if isdictionary(d) then : dim b : d2a = "{" : for each b in d : d2a = d2a&b&" => " : if isstring(d(b)) then : d2a = d2a&iif(strcmp(d(b),","),""""&replace(d(b),",","chr(44)")&"""",""""&d(b)&"""")&"," : else : d2a = d2a&iif(isdate(d(b)),"#"&d(b)&"#",d(b))&", " : end if : next : d2a = d2a&"}" : else : iecho("(d2a) => wants (dictionary)") : d2a = array() : end if : end function
'+cast(value, string) :: strcmp
function cast(v,t) : on error resume next : if strcmp(t,"int") or strcmp(t,"integer") then : cast = cint(v) : end if : if strcmp(t,"str") or strcmp(t,"string") then : cast = cstr(v) : end if : if strcmp(t,"date") or strcmp(t,"time") or strcmp(t,"datetime") then : cast = cdate(v) : end if : if strcmp(t,"lng") or strcmp(t,"long") then : cast = clng(v) : end if : if strcmp(t,"sng") or strcmp(t,"single") then : cast = csng(v) : end if : if strcmp(t,"dbl") or strcmp(t,"double") then : cast = cdbl(v) : end if : if strcmp(t,"bool") or strcmp(t,"boolean") then : cast = cbool(v) : end if : if strcmp(t,"byte") then : cast = cbyte(v) : end if : if strcmp(t,"cur") or strcmp(t,"currency") or strcmp(t,"money") then : cast = ccur(v) : end if : if err.number <> 0 then : iecho("(cast) => cannot cast '"&v&"' as '"&t&"', cast returns empty.") : cast = empty : end if : end function

'-- #calculation
'----------------------------------------------------------
'+floor(numeric) :: iif
function floor(v) : if isnumeric(v) then : floor = iif(v>0,fix(v),fix(v-0.9999999)) : else : iecho("(floor) => wants (numeric)") : end if : end function
'+ceil(numeric) :: iif
function ceil(v) : if isnumeric(v) then : ceil = iif(v>0,fix(v+0.9999999),fix(v)) : else : iecho("(ceil) => wants (numeric)") : end if : end function
'+hstep(numeric) :: ustep, iecho
function hstep(v) : if isnumeric(v) then : if (v=0) then : hstep = 0.5 : else : hstep = ustep(v) : end if : else : iecho("(hstep) => wants (numeric)") : end if : end function
'+ustep(numeric) :: iif, iecho
function ustep(v) : if isnumeric(v) then : ustep = iif(v>=0,1,0) : else : iecho("(ustep) => wants (numeric)") : end if : end function
'+tarai(numeric, numeric, numeric) :: \taraimawashi-function\
function tarai(x,y,z) : if (x<=y) then : tarai = y : else : tarai = tarai(tarai(x-1,y,z),tarai(y-1,z,x),tarai(z-1,x,y)) : end if : end function
'+tak(numeric, numeric, numeric) :: 
function tak(x,y,z) : if (x<=y) then : tak = z : else : tak = tak(tak(x-1,y,z),tak(y-1,z,x),tak(z-1,x,y)) : end if : end function
'+max(value, value) :: iif, isvalue
function max(v,r) : if isvalue(v) and isvalue(r) then : max = iif(v>r,v,r) : end if : end function
'+min(value, value) :: iif, isvalue
function min(v,r) : if isvalue(v) and isvalue(r) then : min = iif(v<r,v,r) : end if : end function

'-- #bit calculation
'----------------------------------------------------------
'+sl(numeric, integer) :: isinteger, iecho, eecho,
function sl(x,n) : if not(isinteger(n) and isnumeric(x)) then : iecho("(sl) => wants (numeric, integer)") : else : if n<0 or n>32 then : eechon("(sl) => invalid number("&n&")") : exit function : end if : if n=0 then : sl = x : else : dim k,d,c : k = clng(2^(32-n-1)) : d = x and (k-1) : c = d*clng(2^n) : if x and k then : c = c or &H80000000 : end if : sl = c : end if : end if : end function
'+sr(numeric, integer) :: isinteger, iecho, eecho
function sr(x,n) : if not(isinteger(n) and isnumeric(x)) then : iecho("(sr) => wants (numeric, integer)") : else : if n<0 or n>32 then : eechon("(sl) => invalid number("&n&")") : exit function : end if : if n=0 then : sl = x : else : dim y,z : y = x and &H7FFFFFFF : if n = 32-1 then : z = 0 : else : z = y \ clng(2^n) : end if : if y<>x then : z = z or clng(2^(32-n-1)) : end if : sr = z : end if : end if : end function
'+add(numeric, numeric) :: iecho
function add(a,b) : if isnumeric(a) and isnumeric(b) then : dim c : c = ccur(a) + ccur(b) : if c > &H7FFFFFFF then : c = c-ccur(2^32) : else : if c < &H80000000 then : c = c+ccur(2^32) : end if : end if : add = clng(c) : else : iecho("(add) => wants (numeric, numeric)") : end if : end function

'-- #md5 transform
'----------------------------------------------------------
'+md5_ba(string) :: s2a, push, iecho /("test") => (array(116,101,115,116))/
function md5_ba(s) : if isstring(s) then : dim c,r : r = array() : for each c in s2a(s,1) : call push(r,asc(c)) : next : md5_ba = r : else : iecho("(md5_ba) => wants (string)") : end if : end function
'+md5_fx(long, long, long) ::
function md5_fx(x,y,z) : md5_fx = (x and y) or ((not x) and z) : end function
'+md5_gx(long, long, long) ::
function md5_gx(x,y,z) : md5_gx = (x and z) or (y and (not z)) : end function
'+md5_hx(long, long, long) ::
function md5_hx(x,y,z) : md5_hx = x xor y xor z : end function
'+md5_ix(long, long, long) ::
function md5_ix(x,y,z) : md5_ix = y xor (x or (not z)) : end function
'+md5_rotate_left(numeric, integer) :: sl, sr
function md5_rotate_left(x,n) : md5_rotate_left = sl(x, n) or sr(x, 32 - n) : end function
'md5_ff(long,long,long,long,numeric,numeric,numeric) :: md5_fx, add,md5_rotate_left
function md5_ff(byref a,b,c,d,x,s,ac) : a = add(add(add(a, md5_fx(b, c, d)), x), ac) : a = md5_rotate_left(a, s) : a = add(a, b) : end function
'md5_gg(long,long,long,long,numeric,numeric,numeric) :: md5_fx, add,md5_rotate_left
function md5_gg(byref a,b,c,d,x,s,ac) : a = add(add(add(a, md5_gx(b, c, d)), x), ac) : a = md5_rotate_left(a, s) : a = add(a, b) : End function
'md5_hh(long,long,long,long,numeric,numeric,numeric) :: md5_fx, add,md5_rotate_left
function md5_hh(byref a,b,c,d,x,s,ac) : a = add(add(add(a,md5_hx(b, c, d)), x), ac) : a = md5_rotate_left(a, s) : a = add(a, b) : End function
'md5_ii(long,long,long,long,numeric,numeric,numeric) :: md5_fx, add,md5_rotate_left
function md5_ii(byref a,b,c,d,x,s,ac) : a = add(add(add(a, md5_ix(b, c, d)), x), ac) : a = md5_rotate_left(a, s) : a = add(a, b) : End function
'md5_init(long,long,long) :: 
function md5_init(byref state, byref count, byref buffer) : count(0) = 0 : count(1) = 0 : state(0) = &H67452301 : state(1) = &HEFCDAB89 : state(2) = &H98BADCFE : state(3) = &H10325476 : End function
'md5_update(long,long,long,long,long) :: add,sl,sr,md5_memcpy, md5_transform
function md5_update(byref state, byref count, byref buffer, byref inputx, inputlen) : dim i,index,partlen : index = sr(count(0), 3) and &h3f : count(0) = add(count(0), sl(inputlen, 3)) : if count(0) < sl(inputlen, 3) then : count(1) = add(count(1), 1) : end if : count(1) = add(count(1), sr(inputlen, 29)) : partlen = 64 - index : if inputlen >= partlen then : call md5_memcpy(buffer, index, inputx, 0, partlen) : call md5_transform(state, buffer, 0) : for i = partlen to inputlen - 63 - 1 step 64 : call md5_transform(state, inputx, i) : next : index = 0 : else : i = 0 : end if : call md5_memcpy(buffer, index, inputx, i, inputlen - i) : end function
'md5_final() :: md5_encode, md5_update,
function md5_final(byref digest, byref state, byref count, byref buffer) : dim bits(7),index,padlen : call md5_encode(bits, count, 8) : index = sr(count(0), 3) and &h3f : if index < 56 then : padlen = 56 - index : else : padlen = 120 - index : end if : dim pad : pad = array(&h80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0) : call md5_update(state, count, buffer, pad, padlen) : call md5_update(state, count, buffer, bits, 8) : call md5_encode(digest, state, 16) : dim i : for i = 0 to ubound(state) : state(i) = 0 : next : for i = 0 to ubound(count) : count(i) = 0 : next : for i = 0 to ubound(buffer) : buffer(i) = 0 : next : end function : 
'md5_transform() :: md5_decode, md5_ff, md5_gg, md5_hh, md5_ii,
function md5_transform(ByRef state, ByRef block, ByVal offset) : Dim i,a,b,c,d,x(15) : a = state(0) : b = state(1) : c = state(2) : d = state(3) : call md5_decode(x, block, offset, 64) : call md5_ff(a, b, c, d, x( 0), 7, &HD76AA478) : call md5_ff(d, a, b, c, x( 1), 12, &HE8C7B756) : call md5_ff(c, d, a, b, x( 2), 17, &H242070DB) : call md5_ff(b, c, d, a, x( 3), 22, &HC1BDCEEE) : call md5_ff(a, b, c, d, x( 4), 7, &HF57C0FAF) : call md5_ff(d, a, b, c, x( 5), 12, &H4787C62A) : call md5_ff(c, d, a, b, x( 6), 17, &HA8304613) : call md5_ff(b, c, d, a, x( 7), 22, &HFD469501) : call md5_ff(a, b, c, d, x( 8), 7, &H698098D8) : call md5_ff(d, a, b, c, x( 9), 12, &H8B44F7AF) : call md5_ff(c, d, a, b, x(10), 17, &HFFFF5BB1) : call md5_ff(b, c, d, a, x(11), 22, &H895CD7BE) : call md5_ff(a, b, c, d, x(12), 7, &H6B901122) : call md5_ff(d, a, b, c, x(13), 12, &HFD987193) : call md5_ff(c, d, a, b, x(14), 17, &HA679438E) : call md5_ff(b, c, d, a, x(15), 22, &H49B40821) : call md5_gg(a, b, c, d, x( 1), 5, &HF61E2562) : call md5_gg(d, a, b, c, x( 6), 9, &HC040B340) : call md5_gg(c, d, a, b, x(11), 14, &H265E5A51) : call md5_gg(b, c, d, a, x( 0), 20, &HE9B6C7AA) : call md5_gg(a, b, c, d, x( 5), 5, &HD62F105D) : call md5_gg(d, a, b, c, x(10), 9, &H2441453) : call md5_gg(c, d, a, b, x(15), 14, &HD8A1E681) : call md5_gg(b, c, d, a, x( 4), 20, &HE7D3FBC8) : call md5_gg(a, b, c, d, x( 9), 5, &H21E1CDE6) : call md5_gg(d, a, b, c, x(14), 9, &HC33707D6) : call md5_gg(c, d, a, b, x( 3), 14, &HF4D50D87) : call md5_gg(b, c, d, a, x( 8), 20, &H455A14ED) : call md5_gg(a, b, c, d, x(13), 5, &HA9E3E905) : call md5_gg(d, a, b, c, x( 2), 9, &HFCEFA3F8) : call md5_gg(c, d, a, b, x( 7), 14, &H676F02D9) : call md5_gg(b, c, d, a, x(12), 20, &H8D2A4C8A) : call md5_hh(a, b, c, d, x( 5), 4, &HFFFA3942) : call md5_hh(d, a, b, c, x( 8), 11, &H8771F681) : call md5_hh(c, d, a, b, x(11), 16, &H6D9D6122) : call md5_hh(b, c, d, a, x(14), 23, &HFDE5380C) : call md5_hh(a, b, c, d, x( 1), 4, &HA4BEEA44) : call md5_hh(d, a, b, c, x( 4), 11, &H4BDECFA9) : call md5_hh(c, d, a, b, x( 7), 16, &HF6BB4B60) : call md5_hh(b, c, d, a, x(10), 23, &HBEBFBC70) : call md5_hh(a, b, c, d, x(13), 4, &H289B7EC6) : call md5_hh(d, a, b, c, x( 0), 11, &HEAA127FA) : call md5_hh(c, d, a, b, x( 3), 16, &HD4EF3085) : call md5_hh(b, c, d, a, x( 6), 23, &H4881D05) : call md5_hh(a, b, c, d, x( 9), 4, &HD9D4D039) : call md5_hh(d, a, b, c, x(12), 11, &HE6DB99E5) : call md5_hh(c, d, a, b, x(15), 16, &H1FA27CF8) : call md5_hh(b, c, d, a, x( 2), 23, &HC4AC5665) : call md5_ii(a, b, c, d, x( 0), 6, &HF4292244) : call md5_ii(d, a, b, c, x( 7), 10, &H432AFF97) : call md5_ii(c, d, a, b, x(14), 15, &HAB9423A7) : call md5_ii(b, c, d, a, x( 5), 21, &HFC93A039) : call md5_ii(a, b, c, d, x(12), 6, &H655B59C3) : call md5_ii(d, a, b, c, x( 3), 10, &H8F0CCC92) : call md5_ii(c, d, a, b, x(10), 15, &HFFEFF47D) : call md5_ii(b, c, d, a, x( 1), 21, &H85845DD1) : call md5_ii(a, b, c, d, x( 8), 6, &H6FA87E4F) : call md5_ii(d, a, b, c, x(15), 10, &HFE2CE6E0) : call md5_ii(c, d, a, b, x( 6), 15, &HA3014314) : call md5_ii(b, c, d, a, x(13), 21, &H4E0811A1) : call md5_ii(a, b, c, d, x( 4), 6, &HF7537E82) : call md5_ii(d, a, b, c, x(11), 10, &HBD3AF235) : call md5_ii(c, d, a, b, x( 2), 15, &H2AD7D2BB) : call md5_ii(b, c, d, a, x( 9), 21, &HEB86D391) : state(0) = add(state(0), a) : state(1) = add(state(1), b) : state(2) = add(state(2), c) : state(3) = add(state(3), d) : for i = 0 to ubound(x) : x(i) = 0 : next : end function
'md5_encode() :: sr
function md5_encode(ByRef output, ByRef inputx, ByVal lenx) : Dim i,j : i = 0 : j = 0 : do while j < lenx : output(j) = inputx(i) and &HFF : output(j + 1) = sr(inputx(i), 8) and &HFF : output(j + 2) = sr(inputx(i), 16) and &HFF : output(j + 3) = sr(inputx(i), 24) and &HFF : i = i + 1 : j = j + 4 : Loop : End function
'md5_decode() :: sl
function md5_decode(byref output, byref inputx, byval inputxoffset, byval lenx) : dim i,j,k : i = 0 : j = 0 : do while j < lenx : k = j + inputxoffset : output(i) = inputx(k) or sl(inputx(k + 1), 8) or sl(inputx(k + 2), 16) or sl(inputx(k + 3), 24) : i = i + 1 : j = j + 4 : loop : end function
'md5_memcpy() :: 
function md5_memcpy(byref output, byval outputoffset, byref inputx, byval inputxoffset, byval lenx) : dim i : for i = 0 to lenx - 1 : output(i + outputoffset) = inputx(i + inputxoffset) : next : end function
'md5_string(string) :: md5_init, md5_update, md5_final, md5_print
function md5_string(byval stringx) : dim state(3),count(1),buffer(63),digest(15),lenx : lenx = len(stringx) : call md5_init(state, count, buffer) : call md5_update(state, count, buffer, md5_ba(stringx), lenx) : call md5_final(digest, state, count, buffer) : md5_string = md5_print(digest) : end function
'md5_print() :: 
function md5_print(digest) : dim s,i : s = "" : for i = 0 to 16 - 1 : s = s & right("00" & lcase(hex(digest(i))), 2) : next : md5_print = s : end function

'-- #utilities
'----------------------------------------------------------
'--- #system
'----------------------------------------------------------
'halt() :: log 
function halt() : log("(halt) => script halt("&err.description&")") : wscript.quit(err.number) : end function
'level_integer :=
'0  SUCCESS
'1  ERROR
'2  WARNING
'4  INFORMATION
'8  AUDIT_SUCCESS
'16 AUDIT_FAILURE
'+evt(integer, string) :: isinteger, isstring, ashell, flog, 
function evt(l,s) : if isinteger(l) and isstring(s) then : ashell.logevent l, s : evt = flog("(evt) => "&l&", "&s) : else : call evt(4, "(evt) => wants (integer, string), gave ("&typename(l)&", "&typename(s)&")") : end if : end function
'raiseerror(string) :: isstring, eecho, evt
function raiseerror(s) : if isstring(s) then : eechon(s) : raiseerror = evt(1,s) : end if : end function
'raisewarn(string) :: isstring, eecho, evt
function raisewarn(s) : if isstring(s) then : wecho(s) : raisewarn = evt(2,s) : end if : end function
'raiseinfo(string) :: isstring, eecho, evt
function raiseinfo(s) : if isstring(s) then : iecho(s) : raiseinfo = evt(4,s) : end if : end function

'--- #path
'----------------------------------------------------------
'mkdir(value) :: isvalue, ef, parentfolder, absolutepath, iecho 
function mkdir(p) : if isvalue(p) then : if not ef(parentfolder(absolutepath(p))) then : call mkdir(parentfolder(absolutepath(p))) : end if : if not ef(absolutepath(p)) then : afso.createfolder(absolutepath(p)) : end if : else : iecho("(mkdir) => wants (value)") : end if : end function
'+gp(array) :: rreplace, iecho \generate path-string array("folder\","\test","a\aa") -> "folder\test\a\aa" \
function gp(a) : if isarray(a) then : gp = rreplace(join(a,"\"),"\\\\*","\") : else : iecho("(gp) => wants (array)") : end if : end function
'basename(value) :: isfolder, isfile, afso, iecho, isvalue
function basename(p) : if isfolder(p) or isvalue(p) or isfile(p) then : basename = afso.getbasename(p) : else : iecho("(basename) => wants (folder_object/file_object/value)") : end if : end function
'filename(value) :: isfolder, isfile, afso, iecho, isvalue
function filename(p) : if isfolder(p) or isvalue(p) or isfile(p) then : filename = afso.getfilename(p) : else : iecho("(filename) => wants (folder_object/file_object/value)") : end if : end function
'absolutepath(value) :: isfolder, isfile, afso, iecho, isvalue
function absolutepath(p) : if isfolder(p) or isvalue(p) or isfile(p) then : absolutepath = afso.getabsolutepathname(p) : else : iecho("(absolutepath) => wants (folder_object/file_object/value)") : end if : end function
'extension(value) :: isfolder, isfile, afso, iecho, isvalue
function extension(p) : if (isfolder(p) or isvalue(p) or isfile(p)) and (isfolder(d) or isvalue(d) or isfile(d)) then : extension = afso.getextensionname(p) : else : iecho("(extension) => wants (folder_object/file_object/value)") : end if : end function
'parentfolder(value) :: isfolder, isfile, afso, iecho, isvalue
function parentfolder(p) : if isfolder(p) or isvalue(p) or isfile(p) then : parentfolder = afso.getparentfoldername(p) : else : iecho("(parentfolder) => wants (folder_object/file_object/value)") : end if : end function
'drivename(value) :: isfolder, isfile, afso, iecho, isvalue
function drivename(p) : if isfolder(p) or isvalue(p) or isfile(p) then : drivename = afso.getdrivename(p) : else : iecho("(drivename) => wants (folder_object/file_object/value)") : end if : end function
'buildpath(value, value) :: isfolder, isfile, isvalue, afso, iecho
function buildpath(s,d) : if (isfolder(s) or isvalue(s) or isfile(s)) and (isfolder(d) or isvalue(d) or isfile(d)) then : buildpath = afso.buildpath(s,d) : else : iecho("(buildpath) => wants (folder_object/file_object/value)") : end if : end function

'--- #random
'----------------------------------------------------------
'+rndstr(value) :: isvalue, isstring, rand, eecho \returns [a-zA-Z0-9]{,length}\
function rndstr(l) : if isnumeric(l) then : if (l>=1) then : randomize(timer) : do until (int(l) <= len(rndstr)) : select case rand(1,3) : case 1 : rndstr = rndstr&chr(rand(48,56)) : case 2 : rndstr = rndstr&chr(rand(65,90)) : case else : rndstr = rndstr&chr(rand(97,122)) : end select : loop : else : eechon("(rndstr) => wants more length.") : end if : else : eechon("(rndstr) => wants (numeric), gave ("&typename(l)&")") : end if : end function
'+rndstrn(value) :: isvalue, s2a, rand, eecho, FUNCTION_RNDSTRN_STRING \returns FUNCTION_RNDSTRN_STRING\
function rndstrn(l) : if isnumeric(l) then : if (l>=1) then : dim a : a = s2a(FUNCTION_RNDSTRN_STRING,1) : randomize(timer) : do until l <= len(rndstrn) : rndstrn = rndstrn&a(rand(0,cint(ubound(a)))) : loop : else : eechon("(rndstrn) => wants more length") : end if : else : eechon("(rndstrn) => wants (numeric), gave ("&typename(l)&")") : end if : end function
'+rand(integer,integer) :: isinteger, eecho 
function rand(n,m) : if isinteger(n) and isinteger(m) then : randomize(timer) : rand = int((m-n+1)*rnd()+n) : else : eechon("(rand) => wants (integer)") : end if : end function

'--- #skelmisc
'----------------------------------------------------------
'+typecast(string) :: rmatch, rremove, dictionary
function typecast(s) : if(rmatch(s,"^([Tt][Rr][Uu][Ee]|[Ff][Aa][Ll][Ss][Ee])$")) then : typecast = cbool(s) : else : if(rmatch(s,"^"".*""$")) then : s = rremove(s,"(^"")|(""$)") : if rmatch(s,"^%dic%\{.*\}$") then : set typecast = dictionary(rremove(s,"^%dic%")) : else : if rmatch(s,"^%arr%\(.*\)$") then : typecast = split(rremove(s,"^%arr%\(|\)$"),",") : else : typecast = s : end if : end if : else : if(rmatch(s,"^#.*#$")) then : typecast = cdate(rremove(s,"(^#)|(#$)")) : else : if(isnumeric(s)) then : typecast = eval(s) : else : typecast = s : end if : end if : end if : end if : end function
'*configure() :: get_configure, fn_conf \old configure() wrapper\
function configure() : set configure = get_configure(fn_conf()) : end function
'+fn_conf() :: iif, eau, aan, basename, e, ef, buildpath \return default configure filename\
function fn_conf() : dim fn : fn = iif(eau("configure"), aan("configure"), basename(wscript.scriptname)&".configure") : if not e(fn) and ef("conf") then : fn = buildpath("conf", fn) : end if : fn_conf = fn : end function
'*get_configure(string) :: adic, ea, iecho, e, fcleanup, rmatch, getmatch, rremove, dic, typecast, isvalue, isnothing, FUNCTION_CONFIGURE_SET_EMPTY, eecho 
function get_configure(fn) : dim d,b,flg,z : set d = adic() : if ea("noconfigure") then : iecho("noconfigure") : else : if e(fn) then : for each b in fcleanup(fn) : if(rmatch(b,"(^\s*<(/)*conf(igure)*>$)")) then : flg = flg + 1 : end if : if((flg=1) and not rmatch(b,"^\s*(\/\/|'|--|\#).*$")) then : set b = getmatch(rremove(b,"^\s*(\/\/|'|--|\#).*$"),"^\s*([a-zA-Z""][a-zA-Z0-9_]*)\s*=\s*(.*)\s*$") : if(b.count > 0) then : z = b(0).submatches(1) : if not (rmatch(z,""".*""")) then : z = trim(rremove(z,"\s*(//|--|').*$|\s*$|\/\*.*\*\/")) : else : z = getmatch(z,"("".*"")")(0).submatches(0) : end if : if rmatch(z,"("".*"")|(#.*#)") then : call dic(d,b(0).submatches(0),iif(ea("notypecast"),z,typecast(z))) : else : call dic(d,b(0).submatches(0),iif(ea("notypecast"),trim(rremove(z,"#.*$")),typecast(trim(rremove(z,"#.*$"))))) : end if : end if : end if : next : for each z in d : if not isvalue(d(z)) then : if isnothing(d(z)) then : if FUNCTION_CONFIGURE_SET_EMPTY then : set d(z) = nothing : else : d.remove z : end if : end if : else : if(len(d(z))=0) then : if FUNCTION_CONFIGURE_SET_EMPTY then : d(z) = empty : else : d.remove z : end if : end if : end if : next : else : eecho("missing configure file("&fn&"), abort") : wscript.quit() : end if : end if : call dic(d,"_skelverion",skelversion()) : call dic(d,"_configure",fn) : call dic(d,"_startdate",datetime1()) : call dic(d,"_logname",flogname()) : call dic(d,"_logtype",FUNCTION_FLOG_TYPENAME) : call dic(d,"_datetimetype",FUNCTION_DATETIME_TYPENAME) : set get_configure = d : end function
'makeconfig(string) :: e, rreplace, fwrite, iecho \work with configure()\
function makeconfig(fn) : fn = iif(strcmp(extension(fn),"configure"),fn,fn&".configure") : if not e(fn) then : on error resume next : do : err.clear : call fwrite(fn).writeline("<configure>"&vbnewline&vbnewline&"</configure>") : loop until (err.number=0) : iecho("(makeconfig) => create .configure file:"&fn) : else : iecho("(makeconfig) => already exists ("&fn&")") : end if : wscript.quit : end function
'+skelversion() :: 
function skelversion() : on error resume next : skelversion = skelv : if err.number <> 0 then : skelversion = "undefined" : err.clear : end if : end function
'+getepid() :: rndstr, FUNCTION_FLOG_EPID \\
function getepid() : if isempty(FUNCTION_FLOG_EPID) then : FUNCTION_FLOG_EPID = rndstr(5): end if : getepid = FUNCTION_FLOG_EPID : end function
'+configure_xml() :: adic, iif, eau, aan, basename, e, ef, buildpath, xml, iecho, eecho, FUNCTION_CONFIGURE_SET_EMPTY, rmatch, dic, cast, push, skelversion, datetime1, flogname, FUNCTION_FLOG_TYPENAME, FUNCTION_DATETIME_TYPENAME
function configure_xml() : dim d, fn,oxml,param,i,a,name, elem, num : num = 0 : set d = adic() : fn = iif(eau("configure"),aan("configure"),basename(wscript.scriptname)&".configure.xml") : if not e(fn) and ef("conf") then : fn = iif(e(buildpath("conf",basename(wscript.scriptname)&".configure.xml")),buildpath("conf",basename(wscript.scriptname)&".configure.xml"),fn) : end if : set oxml = xml(fn) : iecho("(configure_xml) => detect "&oxml.documentElement.getElementsByTagName("param").length&" parameters.") : for each param in oxml.documentElement.selectNodes("/configure/param") : set name = param.getElementsByTagName("name") : set elem = param.getElementsByTagName("element") : if name.length<1 then : iecho("(configure_xml) => invalid 'param' ("&num&": undefined 'name'), skipped.") : else : if elem.length<1 then : iecho("(configure_xml) => invalid 'param' ("&num&": undefined 'element'), skipped.") : else : if not elem(0).haschildnodes then : if isnull(elem(0).getattribute("type")) then : if FUNCTION_CONFIGURE_SET_EMPTY then : call dic(d, name(0).text, empty) : else : iecho("(configure_xml) => detect empty 'element' ("&num&": has no 'value'), skipped.") : end if : else : if FUNCTION_CONFIGURE_SET_EMPTY then : if rmatch(elem(0).getattribute("type"),"(dic|dictionary)") then : call dic(d, name(0).text, adic()) : end if : if rmatch(elem(0).getattribute("type"),"(arr|array)") then : call dic(d, name(0).text, array()) : end if : else : iecho("(configure_xml) => detect empty 'element' ("&num&": has no 'value'), skipped.") : end if : end if : else : if isnull(elem(0).getattribute("type")) then : if elem(0).childnodes.length>1 then : iecho("(configure_xml) => invalid 'value' ("&num&": has multiple 'value', only allowed in 'type': array/dictionary), skipped.") : else : call dic(d, name(0).text, cast(elem(0).childnodes(0).text, elem(0).childnodes(0).getattribute("type"))) : end if : else : if rmatch(elem(0).getattribute("type"),"(arr|array)") then : a = array() : for i=0 to elem(0).childnodes.length-1 : if rmatch(elem(0).childnodes(i).getattribute("type"),"(arr|array|dic|dictionary)") then : iecho("(configure_xml) => invalid 'value,type' ("&num&","&i&": not allowed '"&elem(0).childnodes(i).getattribute("type")&"' yet), skipped.") : else : call push(a, cast(elem(0).childnodes(i).text, elem(0).childnodes(i).getattribute("type"))) : end if : next : call dic(d, name(0).text, a) : end if : if rmatch(elem(0).getattribute("type"),"(dic|dictionary)") then : set a = adic() : for i=0 to elem(0).childnodes.length-1 : if rmatch(elem(0).childnodes(i).getattribute("type"),"(arr|array|dic|dictionary)") then : iecho("(configure_xml) => invalid 'value,type' ("&num&","&i&": not allowed '"&elem(0).childnodes(i).getattribute("type")&"' yet), skipped.") : else : if isnull(elem(0).childnodes(i).getattribute("key")) then : iecho("(configure_xml) => invalid value ("&num&","&i&": not allowed null 'key'), skipped.") : else : call dic(a, elem(0).childnodes(i).getattribute("key"), cast(elem(0).childnodes(i).text, elem(0).childnodes(i).getattribute("type"))) : end if : end if : next : call dic(d, name(0).text, a) : end if : if not rmatch(elem(0).getattribute("type"),"(dic|dictionary|arr|array)") then : iecho("(configure_xml) => not support '"&elem(0).getattribute("type")&"' has multiple 'value', skipped.") : end if : end if : end if : end if : end if : num = num+1 : next : call dic(d,"_skelverion",skelversion()) : call dic(d,"_configure",fn) : call dic(d,"_startdate",datetime1()) : call dic(d,"_logname",flogname()) : call dic(d,"_logtype",FUNCTION_FLOG_TYPENAME) : call dic(d,"_datetimetype",FUNCTION_DATETIME_TYPENAME) : set configure_xml = d : end function : 

'--- #miscfunctions
'----------------------------------------------------------
'e.g. send_mail("from@mail.addr", "to@mail.addr", "cc@mail.addr", "subject", "mail body", attachment-filename_obejct, "smtpserver", 25, 1000)
'e.g. send_mail("from@mail.addr", "to@mail.addr", "cc@mail.addr", "subject", "mail body", attachment-filename_string, "smtpserver", 25, 1000)
'e.g. send_mail("from@mail.addr", "to@mail.addr", "cc@mail.addr", "subject", "mail body", null, "smtpserver", 25, 1000)
'*send_mail(string, string, string, string, string, file_object, string, integer, integer) :: eecho, isfile, isstring, e, afso, wecho, iecho, FUNCTION_SEND_MAIL_CONFIGURE_STRINGS, FUNCTION_SEND_MAIL_ALWAYS_SEND \attachment accepts string, file_object, null\
function send_mail(from, toa, cc, subject, textbody, attachment, smtpserver, nport, timeout) : if not (isstring(from) and isstring(toa) and isstring(smtpserver) and isinteger(nport) and isinteger(timeout)) then : eechon("(send_mail) => wants (string, string, string, string, string, file_object, string, integer, integer), gave ("&typename(from)&", "&typename(toa)&", "&typename(cc)&", "&typename(subject)&", "&typename(textbody)&", "&typename(attachment)&", "&typename(smtpserver)&", "&typename(nport)&", "&typename(timeout)&")") : exit function : end if : dim mail : set mail = createobject("cdo.message") : mail.from = from : mail.to = toa : mail.cc = cc : mail.subject = subject : mail.textbody = textbody : if isfile(attachment) then : mail.addattachment(attachment) : else : if not isnull(attachment) then : if isstring(attachment) then : if e(attachment) then : mail.addattachment(afso.getfile(attachment)) : else : if not len(attachment)=0 then : wecho("(send_mail) => attachment-file is missing.") : end if : end if : else : iecho("(send_mail) => invalid attachment type, gave ("&typename(attachment)&")") : end if : end if : end if : mail.configuration.fields.item(FUNCTION_SEND_MAIL_CONFIGURE_STRINGS&"/sendusing") = 2 : mail.configuration.fields.item(FUNCTION_SEND_MAIL_CONFIGURE_STRINGS&"/smtpserver") = smtpserver : mail.configuration.fields.item(FUNCTION_SEND_MAIL_CONFIGURE_STRINGS&"/smtpserverport") = nport : mail.configuration.fields.item(FUNCTION_SEND_MAIL_CONFIGURE_STRINGS&"/smtpconnectiontimeout") = timeout : mail.configuration.fields.update() : if FUNCTION_SEND_MAIL_ALWAYS_SEND then : send_mail = mail.send() : set send_mail = nothing : else : set send_mail = mail : end if : end function
'e.g. config_dictionay = { "from" => "from@mail.addr", "to" => array("to1@mail.addr", "to2@mail.addr"),  }
'e.g. from, array(to), array(cc), array(bcc), subject, htmlbody, textbody, bodypart.charset, array(attachment)
'*mkmail(dictionary) :: eechon, iif, ed, isarray, anet, e, afso
function mkmail(ca) : dim a : set mkmail = createobject("cdo.message") : if err.number then : eechon("(mkmail) => cannot create cdo.message object") : exit function : end if : mkmail.from = iif(ed(ca,"from"),ca("from"),"") : if ed(ca,"to") then : if isarray(ca("to")) then : mkmail.to = join(ca("to"),",") : else : mkmail.to = ca("to") : end if : end if : if ed(ca,"cc") then : if isarray(ca("cc")) then : mkmail.to = join(ca("cc"),",") : else : mkmail.to = ca("cc") : end if : end if : if ed(ca,"bcc") then : if isarray(ca("bcc")) then : mkmail.to = join(ca("bcc"),",") : else : mkmail.to = ca("bcc") : end if : end if : mkmail.subject = iif(ed(ca,"subject"),ca("subject"),"send from "&anet.computername&" <"&wscript.scriptfullname&">") : if ed(ca,"htmlbody") then : mkmail.htmlbody = ca("htmlbody") : end if : if ed(ca,"textbody") then : mkmail.textbody = ca("textbody") : end if : if ed(ca,"bodypart.charset") then : mkmail.textbody = ca("bodypart.charset") : end if : if ed(ca,"attachment") then : if not isarray(ca("attachment")) then : ca("attachment") = array(ca("attachment")) : end if : for each a in ca("attachment") : if e(afso.getabsolutepathname(a)) then : mkmail.addattachment(afso.getabsolutepathname(a)) : else : eechon("(mkmail) => missing file("&a&")") : set mkmail = nothing : exit function : end if : next : end if : if err.number <> 0 then : eechon("(mkmail) => config error") : end if : end function
'?ismail(imessage_object) :: strcmp
function ismail(m) : ismail = strcmp(typename(m), typename(createobject("cdo.message"))) : end function
'*mailer(imessage_object, string, string) :: pmailer
function mailer(mail, svr, prt) : if ismail(mail) then : set mailer = pmailer(mail, 2, svr, prt, 1000, false, 1, "", "") : else : eechon("(mailer) => mail object required") :end if : end function
'primitive mailer
'*pmailer(imessage_object, string, string, string, string, string, string, string, string) :: FUNCTION_PMAILER_SCHEMA_STRING, eechon
function pmailer(mail, su, svr, prt, tmout, ssl, auth, name, pswd) : dim schema : schema = FUNCTION_PMAILER_SCHEMA_STRING : mail.configuration.fields.item(schema&"/sendusing") = su : mail.configuration.fields.item(schema&"/smtpserver") = svr : mail.configuration.fields.item(schema&"/smtpserverport") = prt : mail.configuration.fields.item(schema&"/smtpconnectiontimeout") = tmout : mail.configuration.fields.item(schema&"/smtpusessl") = ssl : mail.configuration.fields.item(schema&"/smtpauthenticate") = auth : mail.configuration.fields.item(schema&"/sendusername") = name : mail.configuration.fields.item(schema&"/sendpassword") = pswd : mail.configuration.fields.update() : if err.number <> 0 then : eechon("(pmailer) => config error") : end if : set pmailer = mail : end function

'--- #foreach
'foreachrreplace



'+newcmd() :: ashell, rndstr, flog, FUNCTION_NEWCMD_TITLE_STRING \newcmd() returns window-title for handling with actsendkeys()\
function newcmd() : dim t : t = FUNCTION_NEWCMD_TITLE_STRING&rndstr(5) : ashell.run "cmd /C start """&t&"""", 2, false : flog("(newcmd) => create window:"&t) : newcmd = t : end function
'+actsendkeys(string, string) :: actsend \(windowtitle, command)\
function actsendkeys(t,s) : actsendkeys = actsend(t,s,1) : end function 
'+actsend(string, string, integer) :: flog, ashell, FUNCTION_ACTSEND_WAIT_TIME, FUNCTION_ACTSEND_DELAY_COUNT \implement function for actsendkeys()\
function actsend(t,s,n) : wscript.sleep 5 : if(n>FUNCTION_ACTSEND_DELAY_COUNT) then : wscript.sleep FUNCTION_ACTSEND_WAIT_TIME : call actsendkeys(t,s) : else : if(ashell.appactivate(t)) then : ashell.sendkeys(s) : else : call actsend(t,s,n+1) : end if : end if : actsend = flog("(actsend) => "&t&": "&s) : end function
'*twitter(user,pswd) :: axmlhttp, 
function twitter(u,p) : dim tw : set tw = axmlhttp : tw.open "POST", "http://twitter.com/statuses/update.json", false, u, p : tw.setrequestheader "Content-Type", "application/x-www-form-urlencoded" : tw.setrequestheader "X-Twitter-Client", "tw.vbs" : tw.setrequestheader "X-Twitter-Client-Version", "1.0" : set twitter = tw : end function
'tweet(user, pswd, comment) :: twitter
function tweet(u,p,c) : twitter(u,p).send("status="&c) : end function
'selectfolder() :: aapp, ef, eechon, 
function selectfolder() : dim d : set d = aapp().browseforfolder(0,"Select a folder", 0) : on error resume next : if err.number=0 then : if not ef(d.items.item.path) then : eechon ("(selectfolder) => not exist folder("&d.items.item.path&"), flushed.") : selectfolder = "" : else : selectfolder = d.items.item.path : end if : else : eechon("(selectfolder) => error occured.") : selectfolder = "" : end if : end function
'+tee(string, string) :: isstring, fwrite, echon, iecho
function tee(f,s) : if isstring(f) and isstring(s) then : if len(f)>0 then : fwrite(f).writeline(s) : tee = echon(s) : else : iecho("(tee) => invalid filename. ") : end if : else : iecho("(tee) => wants (string, string), gave ("&typename(f)&","&typename(s)&")") : end if : end function : 

'-- #datetime
'----------------------------------------------------------
'+datetime() :: FUNCTION_DATETIME_TYPENAME \speed rank = datetime2 >> datetime1 > datetime0\
function datetime() :: datetime = getref(FUNCTION_DATETIME_TYPENAME) : end function
'+datetime0() :: datetime
function datetime0() : datetime0 = right(replace(date,"/","") & right(replace("0"&time,":",""),6),12) : end function
'+datetime1() :: datetime
function datetime1() : datetime1 = now()&"."&left((timer*100 mod 100)&"0",2) : end function
'+datetime2() :: datetime
function datetime2() : datetime2 = now() : end function
'+datetime3() :: datetime
function datetime3() : datetime3 = yndHMSnow("yyyynnddHHMMSS") : end function
'ts2date(numeric) :: FUNCTION_UNIXTIME_BASIS
function ts2date(s) : if isnumeric(s) then : ts2date = dateadd("s", s, FUNCTION_UNIXTIME_BASIS) : end if : end function
'udate(date) :: FUNCTION_UNIXTIME_BASIS
function udate(s) : if isdate(s) then : udate = clng(datediff("s",FUNCTION_UNIXTIME_BASIS,s)) : end if : end function
'udatenow() :: FUNCTION_UNIXTIME_BASIS
function udatenow() : udatenow = clng(datediff("s",FUNCTION_UNIXTIME_BASIS,now())) : end function
'+unixtime() :: FUNCTION_UNIXTIME_BASIS, FUNCTION_UNIXTIME_OFFSET \make consideration for Local Time\
function unixtime() : unixtime = datediff("s",FUNCTION_UNIXTIME_BASIS,dateadd("h",FUNCTION_UNIXTIME_OFFSET,now())) : end function
'+unix2date(numeric) :: iecho, FUNCTION_UNIXTIME_BASIS, FUNCTION_UNIXTIME_OFFSET \make consideration for Local Time\
function unix2date(s) : if isnumeric(s) then : unix2date = dateadd("h",-1*FUNCTION_UNIXTIME_OFFSET,dateadd("s",s,FUNCTION_UNIXTIME_BASIS)) : else : iecho("(unix2date) => wants (numeric)") : end if : end function
'e.g. date_separate("10 days after") = macthes_object()
'*date_separate(string) :: rmatch, getmatch, adic, eecho
function date_separate(s) : if isstring(s) then : if rmatch(s,"^(-\d\d*|\d*)\s*([ymdHMS]|years*|months*|days*|hours*|min|minutes*|sec|seconds*)(\s*(after|before))*$") then : set date_separate = getmatch(s,"^(-\d\d*|\d*)\s*([ymdHMS]|years*|months*|days*|hours*|mins*|minutes*|secs*|seconds*)(\s*(after|before))*$") : else : eechon("(date_separate) => invalid argument("&s&")") : set date_separate = adic() : end if : else : iecho("(date_separate) => wants (string)") : end if : end function
'e.g. date_element("10 days after") = dictionary_object()
'e.g. date_element(date_separate("10 days after")) = dictionary_object()
'*date_element(string) :: ismatch, date_unit, strcmp, dictionary, date_separate
function date_element(s) : if ismatch(s) then : if s(0).submatches.count=4 then : dim b : b = "{unit => "&date_unit(s(0).submatches(1))&", number => "&s(0).submatches(0)&", flag => " : if isempty(s(0).submatches(2)) then : b = b&"-1" : else : if strcmp(s(0).submatches(3),"after") then : b = b&"1" : else : b = b&"-1" : end if : end if : end if : b = b&"}" : set date_element = dictionary(b) : else : set date_element = date_element(date_separate(s)) : end if : end function
'+date_unit(string) :: dictionary
function date_unit(s) : dim u : set u = dictionary("{y => yyyy, m => m, d => d, H => h, M => n, S => s, year => yyyy, years => yyyy, month => m, months => m, day => d, days => d, hour => h, hours => h, min => n, minute => n, mins => n, minutes => n, sec => s, second => s, secs => s, seconds => s}") : date_unit = u(s) : end function
'e.g. date_subnow(date_separate("10 days after")) = date()
'e.g. date_subnow("10 days before") = date()
'+date_subnow(string) :: isdictionary, ed, iecho, isstring, date_element
function date_subnow(s) : date_subnow = date_sub(s,now()) : end function
'e.g. date_sub(date_separate("10 days after"),now()) = date()
'e.g. date_sub("10 days before","2010/08/08 08:08:08") = date()
'+date_sub(string, date) :: isdictionary, ed, iecho, isstring, date_element
function date_sub(s,p) : if isdictionary(s) and isdate(p) then : if ed(s,"unit") and ed(s,"number") and ed(s,"flag") then : date_sub = dateadd(s("unit"), s("flag") * s("number"), p) : else : iecho("(date_sub) => wants (dictionary, date)") : end if : else : if isstring(s) and isdate(p) then : date_sub = date_sub(date_element(s), p) : else : iecho("(date_sub) => wants (string, date)") : end if : end if : end function
'e.g. date_expand("10 days before", now()) = array(1days before, 2 days before, ..., 10 days before)
'+date_expand(string, date) :: isdictionary, ed, 
function date_expand(s,p) : dim i,r: r = array() : if isdictionary(s) and isdate(p) then : if ed(s,"unit") and ed(s,"number") and ed(s,"flag") then : for i=1*s("flag") to s("number")*s("flag") step 1*s("flag") : call push(r,dateadd(s("unit"),i,p)) : next : date_expand = r : else : iecho("(date_expand) => wants (dictionary/string, date)") : end if : else : date_expand = date_expand(date_element(s),p) : end if : end function
'+date_expandnow(string) :: date_expand
function date_expandnow(s) : date_expandnow = date_expand(s,now()) : end function : 
'+yyyy(date) :: 
function yyyy(d) : if isdate(d) then : yyyy = year(d) : end if : end function
'+yy(date) :: 
function yy(d) : if isdate(d) then : yy = right(year(d),2) : end if : end function
'+nn(date) ::
function nn(d) : if isdate(d) then : nn = right("0"&month(d),2) : end if : end function
'+dd(date) ::
function dd(d) : if isdate(d) then : dd = right("0"&day(d),2) : end if : end function
'+HH(date) ::
function HH(d) : if isdate(d) then : HH = right("0"&hour(d),2) : end if : end function
'+MM(date) ::
function MM(d) : if isdate(d) then : MM = right("0"&minute(d),2) : end if : end function
'+SS(date) ::
function SS(d) : if isdate(d) then : SS = right("0"&second(d),2) : end if : end function
'+tyyyy(string, date) :: yyyy
function tyyyy(s,d) : if(instr(s,"yyyy")>0) then : tyyyy = replace(s,"yyyy",yyyy(d)) : else : tyyyy = s : end if : end function
'+tyy(string, date) :: yy
function tyy(s,d) : if(instr(s,"yy")>0) then : tyy = replace(s,"yy",yy(d)) : else : tyy = s : end if : end function
'+tnn(string, date) :: nn
function tnn(s,d) : if(instr(s,"nn")>0) then : tnn = replace(s,"nn",nn(d)) : else : tnn = s : end if : end function
'+tdd(string, date) :: dd
function tdd(s,d) : if(instr(s,"dd")>0) then : tdd = replace(s,"dd",dd(d)) : else : tdd = s : end if : end function
'+tHH(string, date) :: HH
function tHH(s,d) : if(instr(s,"HH")>0) then : tHH = replace(s,"HH",HH(d)) : else : tHH = s : end if : end function
'+tMM(string, date) :: MM
function tMM(s,d) : if(instr(s,"MM")>0) then : tMM = replace(s,"MM",MM(d)) : else : tMM = s : end if : end function
'+tSS(string, date) :: SS
function tSS(s,d) : if(instr(s,"SS")>0) then : tSS = replace(s,"SS",SS(d)) : else : tSS = s : end if : end function
'+yndnow(string) :: ynd
function yndnow(s) : yndnow = ynd(s,now()) : end function
'+ynd(string,date) :: tdd, tnn, tyyyy
function ynd(s,d) : ynd = tdd(tnn(tyyyy(s,d),d),d) : end function
'+yndHMSnow(string) :: yndHMS
function yndHMSnow(s) : yndHMSnow = yndHMS(s,now()) : end function 
'+yndHMS(string, date) :: tSS,tMM,tHH,tdd,tnn,tyyyy
function yndHMS(s,d) : yndHMS = tSS(tMM(tHH(tdd(tnn(tyyyy(s,d),d),d),d),d),d) : end function
'+pattern_replace(string, dictionary) :: isdictionary, isstring, dictionary, dicmerge, rreplace, iecho \default pattern include yyyy(),yy(),nn(),dd(),HH(),MM(),SS()\
function pattern_replace(s,d) : if (isdictionary(d) and isstring(s)) then : dim n : n = now() : dim p,c : set c = dictionary("{yyyy => """&yyyy(n)&""", yy => """&yy(n)&""", nn => """&nn(n)&""",dd => """&dd(n)&""",HH => """&HH(n)&""",MM => """&MM(n)&""",SS => """&SS(n)&"""}") : if (d.count>0) then : set c = dicmerge(c,d) : else : iecho("(pattern_replace) => additional dictionary has no keys. use ynd() or yndHMS().") : end if : pattern_replace = s : for each p in c : pattern_replace = rreplace(pattern_replace,p,c(p)) : next : else : iecho("(pattern_replace) => wants (string, dictionary), gave ("&typename(s)&", "&typename(d)&")") : end if : end function

'-- #dictionary
'----------------------------------------------------------
'dic(dictionary_object,value,value) :: isdictionary, isstring, ed \(dictionary_object , keyname, value) value of dic() allowed a object or not.\
function dic(d,n,byval v) : if isdictionary(d) and isvalue(n) then : if(ed(d,n)) then : if(isobject(v)) then : set d(n) = v : else d(n) = v : end if : else : d.add n, v : end if : else : iecho("(dic) => wants (dictionary, value, value)") : end if : end function
'e.g. dicmerge(dictionary, dictionary)
'e.g. dicmerge(dictionary, array(dictionary, false)) for impliment dicmerge
'*dicmerge(dictionary, dictionary) :: eecho, isdictionary, ed, dic, iecho \dicmerge() effect original variable and always override value that same key with merged dictionary\
function dicmerge(d,r) : if isarray(r) then : if (ubound(r)=2) then : eechon("(dicmerge) => invalid argument.") : exit function : end if : dim a,b,o : o = r(1) : set a = r(0) : if isdictionary(d) and isdictionary(a) then : for each b in a : if (not ed(d,b) or o) then : if isdictionary(d(b)) and isdictionary(a(b)) then : call dicmerge(d(b),a(b)) : else : call dic(d,b,a(b)) : end if : set dicmerge = d : else : iecho("(dicmerge) => not overwrited(key:"&b&", value:"&a(b)&")") : end if : next : else : eechon("(dicmerge) => wants (dictionary, dictionary)") : end if : else : set dicmerge = dicmerge(d,array(r,true)) : end if : end function
'*dicunite(dictionary_object, dictionary_object) :: isdictionary, dicmerge, iecho \\
function dicunite(d,r) : if isdictionary(d) and isdictionary(r) then : set dicunite = dicmerge(d,array(r,false)) : else : iecho("(dicunite) => wants (dictionary, dictionary)") : end if : end function
'e.g. dictionary("{a => test, b => false, c => 1}")
'e.g. dictionary(array("a => test","b = false","c => 1")) 
'*dictionary(array) :: adic, rmatch, rremove, getmatch, dic, typecast, FUNCTION_DICTIONARY_FORMAT, rreplace 
function dictionary(a) : dim v : set dictionary = adic() : if isarray(a) then : for each v in a : if rmatch(v,FUNCTION_DICTIONARY_FORMAT) then : set v = getmatch(v,FUNCTION_DICTIONARY_FORMAT) : call dic(dictionary,trim(v(0).submatches(0)),typecast(rreplace(v(0).submatches(1),"chr\(44\)",","))) : end if : next : else : if rmatch(a,"^{.*}$") then : set dictionary = dictionary(split(rremove(a,"^{|}$"),",")) : end if : end if : end function

'-- #array
'----------------------------------------------------------
'+pop(array) :: bind \(1,2,3) -> (1,2), 3\
function pop(a) : if isarray(a) then : if (ubound(a)>-1) then : call bind(pop,a(ubound(a))) : redim preserve a(ubound(a)-1) : else : pop = empty : a = array() : end if : end if : end function
'+shift(array) :: bind,pop,push \(1,2,3) -> 1, (2,3)\
function shift(a) : if isarray(a) then : if (ubound(a)>-1) then : dim i,b,c : c = array() : redim b(ubound(a)-1) : call bind(shift,a(0)) : for i=0 to ubound(a)-1 : call bind(b(i),a(i+1)) : next : a = array() : do until (ubound(b)=-1) : call push(c,pop(b)) : loop : do until (ubound(c)=-1) : call push(a,pop(c)) : loop : else : shift = empty : a = array() : end if : end if : end function
'+push(array, value) :: bind \(1,2,3),4 -> (1,2,3,4)\
function push(a,v) : if isarray(a) then : redim preserve a(ubound(a)+1) : call bind(a(ubound(a)),v) : push = a : end if : end function
'+unshift(array, value) :: bind \(1,2,3),4 -> (4,1,2,3)\
function unshift(a,v) : dim i : if isarray(a) then : redim preserve a(ubound(a)+1) : for i=ubound(a) to 1 step -1 : call bind(a(i),a(i-1)) : next : call bind(a(0),v) : unshift = a : end if : end function
'swap(variable,variable) :: bind 
function swap(a,b) : dim t : call bind(t,b) : call bind(b,a) : call bind(a,t) : end function
'+qsort(array) :: swap, isinarray, iecho
function qsort(a) : if not isinarray(a,"[Oo]bject|[Nn]othing|[Vv]ariant") then : dim i,j,n : n = ubound(a) : j = 0 : do until (j = n) : for i=0 to ubound(a)-1 : if(a(i) > a(i+1)) then : call swap(a(i),a(i+1)) : end if : next : j = j + 1 : loop : qsort = a : else : iecho("(qsort) => wants (array) that not included (object/nothing/array)") : end if : end function
'+rsort(array) :: swap, isinarray, iecho
function rsort(a) : if not isinarray(a,"[Oo]bject|[Nn]othing|[Vv]ariant") then : dim i,j,n : n = ubound(a) : j = 0 : do until (j = n) : for i=0 to ubound(a)-1 : if(a(i) < a(i+1)) then : call swap(a(i),a(i+1)) : end if : next : j = j + 1 : loop : rsort = a : else : iecho("(rsort) => wants (array) that not included (object/nothing/array)") : end if : end function
'+arrmerge(array, array) :: bind, iecho 
function arrmerge(a,b) : if isarray(a) and isarray(b) then : dim i,c : c = a : redim preserve c(ubound(a)+ubound(b)+1) : for i=ubound(a)+1 to ubound(c) : call bind(c(i),b(i-ubound(a)-1)) : next : arrmerge = c : else : iecho("(arrmerge) => wants (array,array)") : end if : end function
'yarra(array) :: bind, 
function yarra(a) : if isarray(a) then : dim i,b() : redim b(ubound(a)) : for i=0 to ubound(a) : call bind(b(ubound(a)-i),a(i)) : next : yarra = b : end if : end function
'+popn(array, integer) :: iif, bind, pop, push
function popn(a,n) : dim i,v,b : v = array() : i = iif(n>-1,n,0) : do until (i=0) : call bind(b,pop(a)) : call push(v,b) : i = i - 1 : loop : popn = v : end function
'shiftn(array, integer) :: iif, bind, shift, push
function shiftn(a,n) : dim i,v,b : v = array() : i = iif(n>-1,n,0) : do until (i=0) : call bind(b,shift(a)) : call push(v,b) : i = i - 1 : loop : shiftn = v : end function
'pull(array, integer) :: popn, push, pop
function pull(a,n) : dim b : if isarray(a) then : if (ubound(a)>=n) then : b = popn(a,ubound(a)-n) : pull = a(ubound(a)) : redim preserve a(ubound(a)-1) : do until ubound(b)=-1 : call push(a,pop(b)) : loop : end if : end if : end function
'+array_chop(array) :: \(1,2) => (1)\
function array_chop(a) : redim preserve a(ubound(a)-1) : array_chop = a : end function
'+array_chomp(array) :: \(1,2,"") => (1,2)\
function array_chomp(a) : if a(ubound(a)) = "" then : redim preserve a(ubound(a)-1) : end if : array_chomp = a : end function

'=-- #environment
'----------------------------------------------------------
'+getcd() :: afso
function getcd() : getcd = afso.getfolder(".") : end function
'+getenv(env_string) :: ashell
function getenv(s) : getenv = ashell.expandenvironmentstrings(s) : end function
'+pwd() :: absolutepath 
function pwd() : pwd = absolutepath(".") : end function
'+env() :: ashell
function env(s) :: env = ashell.expandenvironmentstrings(s) : end function

'-- #processes
'----------------------------------------------------------
'getpid() :: isusewmi, getpid_wmi, getpid_tasklist
function getpid() : if isusewmi() then : getpid = getpid_wmi() : else : getpid = getpid_tasklist() : end if : end function
'getpid_wmi() :: rndstr, aconn \getpid use wmi\
function getpid_wmi() : dim a,r,t,b : a = rndstr(5) : ashell.run "cmd.exe /K title="&a,2,false : set t = aconn.execquery("select * from win32_process where commandline like '%"&a&"'") : for each r in t : b = r.parentprocessid : r.terminate : next : set t = aconn.execquery("select * from win32_process where processid = "&b) : for each r in t : getpid_wmi = r.parentprocessid : next : end function
'+getpid_tasklist() :: rndstr, exec, getsubmatch \getpid use tasklist\
function getpid_tasklist() : dim a,r : a = rndstr(5) : set r = exec("cmd.exe /K title="&a) : getpid_tasklist = clng(getsubmatch(replace(exec("tasklist /FI ""IMAGENAME eq cmd.exe"" /FI ""WINDOWTITLE eq "&a&"""").stdout.readall,vbnewline,""),"cmd.exe\s*(\d*)")(0)) : r.terminate : end function
'+texec(string) :: echon, ashell, echon, waitr
function texec(p) : if isstring(p) then : set texec = ashell.exec(p) : flog("(texec) => pid:"&texec.processid&" status:"&texec.status&" cmd:"&p&" time:"&waitr(texec)&" sec") : else : iecho("(texec) => wants (string)") : end if : end function
'+waitr(wshexec_object) :: iswshexec, echon, eecho, 
function waitr(p) : if iswshexec(p) then : dim s : s = timer : do while (true) : flog("(waitr) => "&p.stdout.readline) : if (p.status <> 0 and p.stdout.atendofstream = true) then : exit do : end if : if (p.status = 2) then : eechon(p.stderr.readall) : exit do : end if : loop : waitr = timer - s : else : iecho("(waitr) => wants (wsh_object)") : end if : end function
'+exec(cmdstr) :: ashell, echon, FUNCTION_EXEC_RETURNS_STRINGS
function exec(cmd) : if isstring(cmd) then : set exec = ashell.exec(cmd) : flog("(exec) => pid:"&exec.processid&" status:"&exec.status&" cmd:"&cmd) : if(FUNCTION_EXEC_RETURNS_STRINGS) then : exec = "(exec) => done" : end if : else : iecho("(exec) => wants (string)") : end if : end function

'-- #echo
'----------------------------------------------------------
'+echo(string) :: iscscript, isprintable, flog,FUNCTION_FLOG_TYPENAME,iecho \cbool(right(FUNCTION_FLOG_TYPENAME,1)) means "...TYPENAME != 0 then" \
function echo(s) : if iscscript() and isprintable(s) then : if(cbool(right(FUNCTION_FLOG_TYPENAME,1))) then : wscript.stdout.write(s) : end if : echo = flog(s) : else : echo = iecho("(echo) => wants (string), gave ("&typename(s)&")") : end if : end function
'+echon(string) :: iscscript, isprintable, flog,FUNCTION_FLOG_TYPENAME,iecho
function echon(s) : if iscscript() and isprintable(s) then : if(cbool(right(FUNCTION_FLOG_TYPENAME,1))) then : wscript.stdout.writeline(s) : end if : echon = flog(s) : else : echon = iecho("(iecho) => wants (string), gave ("&typename(s)&")") : end if : end function
'+pecho(string) :: isstring, ashell, flog, FUNCTION_PECHO_TIMEOUT_TIME
function pecho(s) : if isstring(s) or isempty(s) then : pecho = flog("(pecho) => "&ashell.popup(s,FUNCTION_PECHO_TIMEOUT_TIME)&" "&s) : end if : end function
'+eecho(string) :: iscscript, isprintable, flog,FUNCTION_FLOG_TYPENAME, iecho
function eecho(s) : if iscscript() and isprintable(s) then : if(cbool(right(FUNCTION_FLOG_TYPENAME,1))) then : wscript.stderr.write("[ERR ] "&s) : end if : eecho = flog("[ERR ] "&s) : else : eecho = iecho("(eecho) => wants (string), gave ("&typename(s)&")") : end if : end function
'+eechon(string) :: iscscript, isprintable, flog,FUNCTION_FLOG_TYPENAME, iecho
function eechon(s) : if iscscript() and isprintable(s) then : if(cbool(right(FUNCTION_FLOG_TYPENAME,1))) then : wscript.stderr.writeline("[ERR ] "&s) : end if : eechon = flog("[ERR ] "&s) : else : eechon = iecho("(eechon) => wants (string), gave ("&typename(s)&")") : end if : end function
'+iecho(string) :: echon
function iecho(s) : iecho = echon("[INFO] "&s) : end function
'wecho(string) :: echon
function wecho(s) : wecho = echon("[WARN] "&s) : end function
'aecho(array) :: echon, iif, isprintable, iecho
function aecho(a) : if(isarray(a)) then : dim i : for i=lbound(a) to ubound(a) : if(isarray(a(i))) then : echon("("&i&")(") : aecho(a(i)) : echon(")") : else : echon("("&i&") = "&typename(a(i))&"("&iif(isprintable(a(i)), a(i), "*")&")") : end if : next : else : iecho("(aecho) => wants (array)") : end if : end function
'xecho(xml_object) :: isxml, isxmlchild, 
function xecho(o) : dim i : if isxml(o) then : xecho(o.childnodes) : end if : if isxmlchild(o) then : for each i in o : echo i.nodename&" -> "&i.nodevalue : if i.haschildnodes then : xecho(i.childnodes) : end if : next : end if : end function
'decho(dictionary) :: isdictionary, echon, iecho, iif, isprintable
function decho(d) : if(isdictionary(d)) then : dim p : for each p in d : if(isdictionary(d(p))) then : echon("("""&p&""")(") : decho(d(p)) : echon(")") : else : echon("("""&p&""") = "&typename(d(p))&"("&iif(isprintable(d(p)),d(p),"*")&")") : end if : next : else : iecho("(decho) => wants (dictionary)") : end if : end function 
'recho(match_collection) :: ismatch, echon, iecho
function recho(o) : if(ismatch(o)) then : dim i,j : i = 0 : if o.count > 0 then : do until i >= o.count : j = 0 : echon("("&i&") = "&o(i)) : if(o(i).submatches.count>0) then : do until (j >= o(i).submatches.count) : echon("("&i&").("&j&") = "&o(i).submatches(j)) : j = j + 1 : loop : end if : i = i + 1 : loop : else : iecho("(recho) => object have no matches") : end if : else : iecho("(recho) => wants (matches_object)") : end if : end function
'dumper(variable) :: var_dump \embedded function for dumper()\
function dumper(o) : call var_dump(o,0,"") : end function
'var_dump(variable, integer, string) :: replicate, isstring, isboolean, echon, isdictionary, ismatch, isxml, isxmlchild, ismail, issubmatch, 
function var_dump(v,n,s) : on error resume next : dim t,a,r,k,i,j,z,f : f = false : t = "(dumper) " : a = replicate(vbtab,n) : r = "=> " : if isxml(v) then : echon(t&a&r&s&typename(v)) : call var_dump(v.childnodes,n+1,"") : f = true : end if : if isxmlchild(v) then : for each z in v : echon(t&a&r&s&z.nodename&" -> "&z.nodevalue) : if z.haschildnodes then : call var_dump(z.childnodes, n+1, "") : end if : next : f = true : end if : if isstring(v) or isnumeric(v) or isempty(v) or isboolean(v) or isdate(v) then : echon(t&a&r&s&typename(v)&"("&v&")") : f = true : end if : if isnull(v) or isnothing(v) then : echon(t&a&r&s&typename(v)&"("&ucase(typename(v))&")") : f = true : end if : if isdictionary(v) then : echon(t&a&r&s&typename(v)&"("&v.count&") {") : for each k in v : call var_dump(v(k),n+1,"("""&k&""") -> ") : next : echon(t&a&r&"}") : f = true : end if : if isarray(v) then : echon(t&a&r&s&"Array("&ubound(v)&") (") : for k=lbound(v) to ubound(v) : call var_dump(v(k), n+1, "["&k&"] -> ") : next : echon(t&a&r&")") : f = true : end if : if ismatch(v) then : echon(t&a&r&s&"Match("&v.count&") (") : for i=0 to v.count-1 : echon(t&replicate(vbtab,n+1)&r&"Matches("&i&") -> v:"""&v(i).value&""" i:"&v(i).firstindex&" l:"&v(i).length) : if (v(i).submatches.count > 0) then : for j=0 to v(i).submatches.count-1 : echon(t&replicate(vbtab,n+2)&r&".SubMatches("&j&") -> """&v(i).submatches(j)&"""") : next : end if : next : echon(t&a&r&")") : f = true : end if : if issubmatch(v) then : echon(t&a&r&s&"SubMatch("&v.count&") (") : if (v.count > 0) then : for j=0 to v.count-1 : echon(t&replicate(vbtab,n+2)&r&"("&j&") -> """&v(j)&"""") : next : end if : echon(t&a&r&")") : f = true : end if : if ismail(v) then : echon(t&a&r&s&"IMessage(") : echon(t&replicate(vbtab,n+1)&r&s&".from -> "&"("&v.from&")") : echon(t&replicate(vbtab,n+1)&r&s&".to -> "&"("&v.to&")") : echon(t&replicate(vbtab,n+1)&r&s&".cc -> "&"("&v.cc&")") : echon(t&replicate(vbtab,n+1)&r&s&".bcc -> "&"("&v.bcc&")") : echon(t&replicate(vbtab,n+1)&r&s&".subject -> "&"("&v.subject&")") : echon(t&replicate(vbtab,n+1)&r&s&".htmlbody -> "&"("&v.htmlbody&")") : echon(t&replicate(vbtab,n+1)&r&s&".textbody -> "&"("&v.textbody&")") : echon(t&replicate(vbtab,n+1)&r&s&".bodypart.charset -> "&"("&v.bodypart.charset &")") : echon(t&replicate(vbtab,n+1)&r&s&".attachments("&v.attachments.count&") => {") : for each j in v.attachments : echon(t&replicate(vbtab,n+2)&r&s&"filename: ("&j.filename&")") : next : echon(t&replicate(vbtab,n+1)&r&s&"}") : echon(t&a&r&s&")") : f = true : end if : if not f then : echon(t&a&r&s&typename(v)&"(*)") : end if : if err.number <> 0 then : eechon("(dumper) => (n:"&err.number&" s:"&err.source&" d:"&err.description&")") : err.clear : end if : end function
'+cout(string) :: iscscript
function cout(s) : if(iscscript()) then : cout = len(s) : wscript.stdout.writeline(s) : end if : end function
'+cerr(string) :: iscscript
function cerr(s) : if(iscscript()) then : cerr = len(s) : wscript.stderr.writeline(s) : end if : end function

'-- #abbreviations
'----------------------------------------------------------
'*afso() :: 
function afso() : set afso = wscript.createobject("scripting.filesystemobject") : end function
'*ashell() ::
function ashell() : set ashell = wscript.createobject("wscript.shell") : end function
'*adic() :: 
function adic() : set adic = wscript.createobject("scripting.dictionary") : end function
'*aapp() ::
function aapp() : set aapp = wscript.createobject("shell.application") : end function
'*anet() ::
function anet() : set anet = wscript.createobject("wscript.network") : end function
'*aarg() :: 
function aarg() : set aarg = wscript.arguments : end function
'*axmlhttp() :: 
function axmlhttp() : set axmlhttp = createobject("msxml2.xmlhttp") : end function
'*alocator() ::
function alocator() : set alocator = wscript.createobject("WbemScripting.SWbemLocator") : end function
'*aconn() :: alocator
function aconn() : set aconn = alocator.connectserver : end function
'*aconnsrv(string,string,string,string) :: alocator \(computer,namespace,username,password)\
function aconnsrv(c,n,u,p) : set aconnsrv = alocator.connectserver(c,n,u,p) : end function
'+aan(string) :: iif, ea, aarg 
function aan(n) : if isstring(n) then : aan = iif(ea(n),aarg.named(n),empty) : else : iecho("(aan) => wants (string)") : aan = empty : end if : end function
'+aau(integer) :: aarg,iecho,
function aau(n) : if isnumeric(n) then : if(aarg.unnamed.count>n) then : aau = aarg.unnamed(n) : else : iecho("(aau) => not found "&n&"th argument.") : aau = empty : end if : else : iecho("(aau) => wants (numeric)") : end if: end function
'*adb() :: 
function adb() : set adb = createobject("adodb.connection") : end function
'*astream() :: 
function astream() : set astream = createobject("adodb.stream") : end function
'*axml() :: 
function axml() : set axml = createobject("msxml2.domdocument") : end function

'-- #filehandler
'----------------------------------------------------------
'*frwc(string, integer, boolean, integer) :: afso \(filename, mode, create_flg, charcode)\
function frwc(n,m,f,c) : if isstring(n) and isinteger(m) and isinteger(c) and isboolean(f) then : set frwc = afso.opentextfile(n,m,f,c) : else : iecho("(frwc) => wants (string, integer, boolean, integer)") : end if : end function
'*frw(filename, mode, create_flg) :: frwc 
function frw(n,m,f) : set frw = frwc(n,m,f,0) : end function
'*furw(string, integer, boolean) :: frwc \unicode := -1 means UTF-16LE BOM-added\
function furw(n,m,f) : set furw = frwc(n,m,f,-1) : end function
'*fuwrite(string) :: furw \f* function not to check exist file.\
function fuwrite(n) : set fuwrite = furw(n,8,true) : end function
'*furead(string) :: furw \f* function not to check exist file.\
function furead(n) : set furead = furw(n,1,false) : end function
'*fwrite(filename) :: frw \f* function not to check exist file.\
function fwrite(n) : set fwrite = frw(n,8,true) : end function
'*fowrite(filename) :: frw \overwrite file.\
function fowrite(n) : set fowrite = frw(n,2,true) : end function
'*fread(filename) :: frw \f* function not to check exist file.\
function fread(n) : set fread = frw(n,1,false) : end function
'*fsrw(string, integer, integer,integer) :: astream,isstring, isinteger, iecho \(charcode, type, separator, mode)\
function fsrw(c,t,l,m) : if isstring(c) and isinteger(t) and isinteger(l) then : dim f : set f = astream() : f.charset = c : f.type = t : f.lineseparator = l : f.mode = m : f.open() : set fsrw = f : else : iecho("(fsrw) => wants (string, integer, integer)") : end if : end function
'*fstream(string, integer) :: fsrw
function fstream(c,m) : set fstream = fsrw(c,2,-1,m) : end function
'fsread function returns stream_object, use property/method .eof/.readtext() to read file 
'*fsread(string) :: fsreadm
function fsread(n) : set fsread = fsreadm(n,"utf-8") : end function
'*fsreadm(string, string) :: isstring, e, eecho, iecho, fstream
function fsreadm(n,c) : if isstring(n) then : dim f : set f = fstream(c,16) : if e(n) then : f.loadfromfile(n) : else : eechon("file is missing ("&n&")") : end if : set fsreadm = f : else : iecho("(fsreadm) => wants (string)") : end if : end function
'fswrite function returns stream_object, use method .writetext() and .savetofile() to write file 
'*fswrite(string) :: fswritem
function fswrite(n) : set fswrite = fswritem(n,"utf-8") : end function
'*fswritem(string, string) :: isstring, e, iecho, fstream
function fswritem(n,c) : if isstring(n) then : dim f : set f = fstream(c,3) : if e(n) then : f.loadfromfile(n) : f.position = f.size : else : call f.savetofile(n,2) : end if : set fswritem = f : else : iecho("(fswritem) => wants (string)") : end if : end function
'+fswriten(string, string) :: fswritenm \fswriten(filename, string) write "string" to "file" by line\
function fswriten(n,s) : fswriten = fswritenm(n,s,"utf-8") : end function
'+fswritenm(string, string, string) :: isstring, fswrite, 
function fswritenm(n,s,c) : if isstring(n) and isstring(s) then : dim f : set f = fswritem(n,c) : f.writetext(s&vbnewline) : call f.savetofile(n,2) : fswritenm = len(s) : else : iecho("(fswritenm) => wants (string,string)") : end if : end function
'*frs(file) :: afso
function frs(f) : set frs = afso.getfile(f).openastextstream(1) : end function
'*fws(file) :: afso
function fws(f) : set fws = afso.getfile(f).openastextstream(2) : end function
'*fas(file) :: afso
function fas(f) : set fas = afso.getfile(f).openastextstream(8) : end function

'-- #log
'----------------------------------------------------------
'+flog(string) :: FUNCTION_FLOG_TYPENANE, 
function flog(s) : flog = getref(FUNCTION_FLOG_TYPENAME)(s) : end function
'+flog0(string) :: datetime, flog
function flog0(s) : wscript.stdout.writeline(datetime()&vbtab&s) : flog0 = len(s) : end function
'+flog1(string) :: flog,fwrite, datetime, flogname
function flog1(s) : fwrite(flogname()).writeline(datetime()&vbtab&s) : flog1 = len(s) : end function
'+flog2(string) :: flog,fwrite, datetime0
function flog2(s) : fwrite(flogname()).writeline(datetime()&vbtab&s) : flog2 = len(s) : end function
'+flog3(string) :: FUNCTION_FLOG_EPID, getpid, e, flogname, FUNCTION_FLOG_ROTATE_COUNT, afso, filename, fwrite
function flog3(s) : if isempty(FUNCTION_FLOG_EPID) then : getepid() : dim i : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_COUNT) then : call afso.deletefile(flogname()&"."&FUNCTION_FLOG_ROTATE_COUNT) : end if : for i=FUNCTION_FLOG_ROTATE_COUNT-1 to 1 step -1 : if(e(flogname()&"."&i)) then : afso.getfile(flogname()&"."&i).name = filename(flogname()&"."&i+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : end if : end if : on error resume next : do : err.clear : fwrite(flogname()).writeline(datetime()&vbtab&s) : loop until (err.number=0) : flog3 = len(s) : end function
'+flog4(string) :: FUNCTION_FLOG_EPID, getpid, e, flogname, fread, rmatch, iif, FUNCTION_FLOG_ROTATE_COUNT, afso, filename, fwrite, 
function flog4(s) : if isempty(FUNCTION_FLOG_EPID) then : getepid() : if e(flogname()) then : dim f,b : b = fread(flogname()).readline : if rmatch(b,"^\d\d\d\d\d\d\d\d\d\d\d\d$") then : b = "20"&left(b,2)&"/"&mid(b,3,2)&"/"&mid(b,5,2)&" "&mid(b,7,2)&":"&mid(b,9,2)&":"&right(b,2) : end if : if rmatch(b,"^\d\d\d\d/\d\d*/\d\d* \d\d*:\d\d*:\d\d*(\.\d\d*)*$") then : f = iif((datediff("d",cdate(b),now())=0), false, true) : else : f = true : end if : if f then : dim i : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_COUNT) then : call afso.deletefile(flogname()&"."&FUNCTION_FLOG_ROTATE_COUNT) : end if : for i=FUNCTION_FLOG_ROTATE_COUNT-1 to 1 step -1 : if(e(flogname()&"."&i)) then : afso.getfile(flogname()&"."&i).name = filename(flogname()&"."&i+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : on error resume next : do : err.clear : fwrite(flogname()).writeline(now()) : loop until (err.number=0) : end if : end if : else : on error resume next : do : err.clear : fwrite(flogname()).writeline(now()) : loop until (err.number=0) : end if : end if : on error resume next : do : err.clear : fwrite(flogname()).writeline(datetime()&vbtab&s) : loop until (err.number=0): flog4 = len(s) : end function
'+flog5(string) :: e, flogname, afso, FUNCTION_FLOG_ROTATE_FILESIZE, FUNCTION_FLOG_ROTATE_COUNT, filename, fwrite, 
function flog5(s) : if e(flogname()) then : if (afso.getfile(flogname()).size >= FUNCTION_FLOG_ROTATE_FILESIZE) then : dim i : if e(flogname()&"."&FUNCTION_FLOG_ROTATE_COUNT) then : call afso.deletefile(flogname()&"."&FUNCTION_FLOG_ROTATE_COUNT) : end if : for i=FUNCTION_FLOG_ROTATE_COUNT-1 to 1 step -1 : if(e(flogname()&"."&i)) then : afso.getfile(flogname()&"."&i).name = filename(flogname()&"."&i+1) : end if : next : if e(flogname()) then : afso.getfile(flogname()).name = filename(flogname()&".1") : on error resume next : do : err.clear : fwrite(flogname()).writeline(now()) : loop until (err.number=0) : end if : end if : else : on error resume next : do : err.clear : fwrite(flogname()).writeline(now()) : loop until (err.number=0) : end if : on error resume next : do : err.clear : fwrite(flogname()).writeline(datetime()&vbtab&s) : loop until (err.number=0) : flog5 = len(s) : end function
'+flogname() :: FUNCTION_FLOG_FILENAME, FUNCTION_FLOG_TYPENAME, buildpath, iif, eau, aan, datetime3, basename, createlogdir, 
function flogname() : if isempty(FUNCTION_FLOG_FILENAME) then : select case FUNCTION_FLOG_TYPENAME : case "flog2" : FUNCTION_FLOG_FILENAME = buildpath(FUNCTOIN_FLOG_LOGDIR, iif(eau("logbase"),aan("logbase"),"")&left(datetime3,8)&".log") : case else : FUNCTION_FLOG_FILENAME = buildpath(FUNCTOIN_FLOG_LOGDIR, iif(eau("logbase"),aan("logbase"),"")&basename(wscript.scriptname)&".log") : end select : end if : call createlogdir(parentfolder(FUNCTION_FLOG_FILENAME)) : flogname = FUNCTION_FLOG_FILENAME : end function
'+flog6(string) :: FUNCTION_FLOG_EPID, FUNCTION_FLOG_ROTATEPATTERN, cout, FUNCTION_FLOG_EPID, getrotateid, cerr, FUNCTION_FLOG_ROTATE_COUNT, FUNCTION_FLOG_FILENAME, afso, e, filename, fwrite, rmatch, fhead
function flog6(s) : dim i : if isempty(FUNCTION_FLOG_EPID) then : if not rmatch(FUNCTION_FLOG_ROTATEPATTERN, "^yyyy((((mm)*dd)*hh)*nn)*$") then : cout("(flog6) => fallback rotate type to 'yyyymmdd'.") : end if : if e(flogname())  then : if afso.getfile(flogname()).size > 0 then : FUNCTION_FLOG_EPID = getrotateid(FUNCTION_FLOG_ROTATEPATTERN, fhead(flogname())(0)) : end if : end if : if isempty(FUNCTION_FLOG_EPID) then : FUNCTION_FLOG_EPID = getrotateid(FUNCTION_FLOG_ROTATEPATTERN, now) : end if : end if : if not(FUNCTION_FLOG_EPID = getrotateid(FUNCTION_FLOG_ROTATEPATTERN, now)) then : for i = FUNCTION_FLOG_ROTATE_COUNT to 0 step -1 : select case i : case 0 : afso.getfile(flogname()).name = filename(flogname())&"."&(i+1) : case FUNCTION_FLOG_ROTATE_COUNT : if e(flogname()&"."&i) then : afso.deletefile flogname()&"."&i : end if : case else : if e(flogname()&"."&i) then : afso.getfile(flogname()&"."&i).name = filename(flogname())&"."&(i+1) : end if : end select : next : FUNCTION_FLOG_EPID = getrotateid(FUNCTION_FLOG_ROTATEPATTERN, now) : end if : fwrite(flogname()).writeline(datetime()&vbtab&s) : flog6 = len(s) : end function : 
'+getrotateid(string, string) :: \(pattern as "^yyyy((((mm)*dd)*hh)*nn)*$", timestr such as "yyyy/mm/dd hh:nn:ss")\
function getrotateid(p, t) : select case p : case "yyyy" : getrotateid = left(t,4) : case "yyyymm" : getrotateid = left(t,7) : case "yyyymmdd" : getrotateid = left(t,10) : case "yyyymmddhh" : getrotateid = left(t,13) : case "yyyymmddhhnn" : getrotateid = left(t,16) : case "yyyymmddhhnnss" : getrotateid = t : case else : getrotateid = left(t,10) : end select : end function : 
'createlogdir(string) :: ef, mkdir, cerr, \string means directory\
function createlogdir(p) : if not ef(p) then  : call mkdir(p) : if not ef(p) then : cerr("(createlogdir) => cannot create logging directory. '"&p&"', check authority or path.") : end if : end if : end function


'+log(string) :: flog
function log(s) : log = flog("(log) => "&s) : end function

'-- #file utils
'----------------------------------------------------------
'+fheadn(string, integer) :: isstring, isinteger, e, frs, push, iecho
function fheadn(f,n) : if isstring(f) and isinteger(n) then : if e(f) then : if (n>0) then : dim a,b : set a = frs(f) : b = array() : do until (a.line = n+1 or a.atendofstream) : call push(b,a.readline) : loop : fheadn = b : else : fheadn = array() : end if : else : iecho("(fheadn) => file is missing ("&f&")") : end if : else : iecho("(fheadn) => wants (string, integer)") : end if : end function
'+ftailn(string, integer) :: isstring, isinteger, e, fas, frs, push, iecho
function ftailn(f,n) : if isstring(f) and isinteger(n) then : if e(f) then : if (n>0) then : dim a,b,c,d : set a = frs(f) : c = fas(f).line : b = array() : do until a.line = c-n+1 : a.skipline : loop : do until a.atendofstream : d = a.line : call push(b,a.readline) : loop : if not(c = d) then : call push(b,"") : end if : ftailn = b : else : ftailn = array() : end if : else : iecho("(ftailn) => file is missing ("&f&")") : end if : else : iecho("(ftailn) => wants (string, integer)") : end if : end function
'+fhead(string) :: fheadn
function fhead(f) : fhead = fheadn(f,1) : end function
'+ftail(string) :: ftailn
function ftail(f) : ftail = ftailn(f,1) : end function
'+fcat(string) :: frs
function fcat(f) :: fcat = frs(f).readall :: end function
'fcut(string, integer, integer) :: isstring, isinteger, iecho, e, fas, frs, push 
function fcut(f,s,n) : dim l : if isstring(f) and isinteger(s) and isinteger(n) then : if s>n then : iecho("(fcut) => invalid start-end line.") : else : if e(f) then : l = fas(f).line : if n>l or 0>=s then : iecho("(fcut) => over end line/0 line selected") : else : dim a,b : set a = frs(f) : b = array() : echon a.line : do until (a.line=s) : a.skipline : loop : do until a.atendofline or a.line=n+1 : call push(b,a.readline) : loop : fcut = b : end if : else : iecho("(fcut) => file is missing ("&f&")") : end if : end if : end if : end function
'+farray(string) :: f2a
function farray(f) : farray = f2a(f) : end function
'+ftouch(string) :: afso,e 
function ftouch(f) : if not e(f) then : call afso.createtextfile(f) : ftouch = f : end if : end function
'+fcleanup(string) :: fcleanupn
function fcleanup(f) : fcleanup = fcleanupn(f,"/\*(.|\n)+?\*/","^\s*(#|'|//|--).*$") : end function
'fcleanupn wants (filename, section_regexp_for_remove, line_regexp_for_remove)
'+fcleanupn(string, string, string) :: e, isstring, rremove, f2v, push, iecho
function fcleanupn(f,s1,s2) : dim b,a : a = array() : if e(f) and isstring(s1) and isstring(s2) then : for each b in split(rremove(f2v(f),s1),vbnewline) : b = rremove(rremove(b,s2),"^\s*$") : if len(b)>0 then : call push(a,b) : end if : next : fcleanupn = a : else : iecho("(fcleanupn) => wants (string, string, string)") : end if : end function
'fftail(string) :: isstring, e, iecho, frs, echon, 
function fftail(fn) : dim f : if isstring(fn) then : if e(fn) then : iecho("(fftail) => if exist """&absolutepath(fn)&".end"" then, exit fftail()") : set f = frs(fn) : do while true : if not f.atendofstream then : echon fn&" : "&f.readline : end if : if e(absolutepath(fn)&".end") then : exit do : end if : loop : else : iecho("(fftail) => file is missing ("&fn&")") : end if : else : iecho("(fftail) => wants (string)") : end if : end function : 
'+fendline(string) :: e,fas, ftailn, iecho \return last readable line\
function fendline(f) : dim s : s = "" : if e(f) then : dim l,i : i = 1 : l = fas(f).line : do until (len(s)>0 or i>l) : s = ftailn(f,i)(0) : i = i+1 : loop : else : iecho("(fendline) => file is missing("&f&")") : end if : fendline = s : end function
'+fgrep(string, string) :: e, isstring, frs, rmatch, push, iecho \file grep\
function fgrep(f,s) : dim c : c = array() : if e(f) then : if isstring(f) and isstring(s) then : dim a,b : set a = frs(f) : do until a.atendofstream : b = a.readline : if rmatch(b,s) then : call push(c,b) : end if : loop : else : iecho("(fgrep) => wants (string, string)") : end if : else : iecho("(fgrep) => file is missing.("&f&")") : end if : fgrep = c : end function

'-- #threads
'----------------------------------------------------------
'th_limitcheck(array,integer) :: iecho, isinteger, iswshexec_array, FUNCTION_TH_LIMITCHECK_WAIT, FUNCTION_TH_LIMITCHECK_WAIT_TIME, echon,
function th_limitcheck(c,n) : if not isinteger(n) then : iecho("(th_limitcheck) => invalid limit parameter("&typename(n)&"), fallback n=1.") : n = 1 : end if : if not (isarray(c)) then : iecho("(th_limitcheck) => invalid command_array, no operation.") : iecho("(th_limitcheck) => wants (array, integer)") : exit function : end if : dim p,a,w : w = true : if iswshexec_array(c) then : do : p = 0 : for each a in c : if (a.status <> 0) then : p = p+1 : end if : next : if (FUNCTION_TH_LIMITCHECK_WAIT) then : wscript.sleep(FUNCTION_TH_LIMITCHECK_WAIT_TIME) : end if : if w and (ubound(c)+1-p>=n) then : iecho("(th_limitcheck) => encountered thread limit("&n&")") : w = false : end if : loop until (ubound(c)+1-p<n) : end if : end function
'th_done(array) :: iswshexec_array, echon, iif,
function th_done(c) : dim a,f : if iswshexec_array(c) then : iecho("(th_done) => wait for all threads to terminate.") : do : f = 0 : for each a in c : f = f + iif(a.status<>0, 1, 0) : next : loop until (f=ubound(c)+1) : end if : iecho("(th_done) => done.") : end function
'+th_do(integer, array) :: eechon, isinteger, iecho, rmatch, env, th_limitcheck, push, exec, th_done, FUNCTION_TH_DO_TIME_PER_LAUNCH
function th_do(limit,cmdlist) : if not isarray(cmdlist) then : eechon("(th_do) => wants (integer, array)") : exit function : end if : if not isinteger(limit) then : iecho("(th_do) => invalid limit value type("&typename(limit)&"), fallback limit=1.") : limit = 1 : end if : if cint(limit)<0 then : iecho("(th_do) => invalid limit value("&limit&"), fallback limit=1.") : limit = 1 : end if : if cint(limit)=0 then : iecho("(th_do) => autorange limit value, set limit="&env("%NUMBER_OF_PROCESSORS%")&".") : if rmatch(env("%NUMBER_OF_PROCESSORS%"),"[1-9][0-9]*") then : limit = cint(env("%NUMBER_OF_PROCESSORS%")) : else : iecho("(th_do) => invalid enviroment(%NUMBER_OF_PROCESSORS%), fallback limit=1.") : limit = 1 : end if : end if : dim c,cmd : cmd = array() : for each c in cmdlist : call th_limitcheck(cmd,limit) : call push(cmd,exec(c)) : wscript.sleep FUNCTION_TH_DO_TIME_PER_LAUNCH : next : th_do = th_done(cmd) : end function

'-- #database
'----------------------------------------------------------
'returns dictionary_object {"_field" => array, "0" => dic,..., "_row" => integer}
'*db_query(string,string) :: adb, adic, push, dic, 
function db_query(s,q) : dim c,d,r,field,fields,i,ret,con : set con = adb() : fields = array() : set d = adic() : c = 0 : con.open(s) : set ret = con.execute(q) : for i=0 to ret.fields.count-1 : call push(fields,ret(i).name) : next : call dic(d,"_field",fields) : do until (ret.eof) : set r = adic() : for each field in fields : if (ret(field).type = 128 or ret(field).type = 204 or ret(field).type = 205) then : call dic(r,field,"_BINARY") : else : call dic(r,field,ret(field).value) : end if : next : call dic(d,c,r) : c = c+1 : ret.movenext : loop : call dic(d,"_row",c) : con.close() : set db_query = d : end function
'*db_q2d(string,query) :: db_query
function db_q2d(s,q) : set db_q2d = db_query(s,q) : end function
'+db_q2a(string, query) :: db_q2d, \string wants connection_string like "Provider=SQLOLEDB;server=InstanceName;Integrated Security=SSPI;"\
function db_q2a(s,q) : dim a(),i,j,d : set d = db_q2d(s,q) : redim a(ubound(d("_field")),d("_row")-1) : for j=1 to d("_row") : for i=0 to ubound(d("_field")) : a(i,j-1) = d(j-1)(d("_field")(i)) : next : next : db_q2a = a : end function
'?db_isdb(object) :: isdictionary, isinteger
function db_isdb(o) : db_isdb = isarray(o("_field")) and isdictionary(o) and isinteger(o("_row")) : end function
'+db_view(object) :: db_isdb, righ, eecho
function db_view(o) : dim i,f,r,a : if db_isdb(o) then : for i=0 to ubound(o("_field")) : r = r&o("_field")(i)&"," : next : a = vbnewline&righ(r,1)&vbnewline : for i=0 to o("_row")-1 : r = "" : for each f in o("_field") : r = r&o(i)(f)&"," : next : a = a&righ(r,1)&vbnewline : next : else : eechon("(db_view) => not db_results object.") : end if : db_view = a : end function : 
'*db_query2(string, string) :: isping, rremove, exec, adic, push, pull, dic, rmatch, 
function db_query2(i, q) : if isping(rremove(i,"\\.*$")) then : dim d,r,b,a,f,j,g,k : set b = exec(FUNCTION_DB_QUERY2_CMD&" -S "&i&" -Q """&q&""""&FUNCTION_DB_QUERY2_CMD_OPTION) : r = array() : f = array() : set d = adic() : k=0 : do until b.stdout.atendofstream : call push(r,b.stdout.readline) : loop : for each a in split(pull(r,0),",") : call push(f,a) : next : call dic(d,"_field",f) : for each b in r : set g = adic() : if not (rmatch(b,"^[,-]*$")) then : j=0 : for each a in split(b,",") : call dic(g,f(j),a) : j = j+1 : next : call dic(d,k,g) : k=K+1 : end if : next : call dic(d,"_row",k) : set db_query2 = d : else : set db_query2 = adic() : end if : end function

'-- #xml
'*xml(string) :: axml, e, iecho, 
function xml(s) : set xml = axml() : if e(s) then : if not xml.load(s) then : iecho("(xml) => invalid xml format source.") : end if : else : iecho("(xml) => source file is missing.("&s&")") : end if : end function

'-- #WMI class
'class wm for WMI. functions have wm_ prefix is virtual function for //job:deptree.
class wm
'variables ------------------------------------------------
private w
'functions - embedded -------------------------------------
'wm_class_initialize() :: adic, dic, wm_set_computer, iecho
''class_initialize() :: adic, dic, set_computer, iecho
private sub class_initialize : set w = adic() : call dic(w,"islocalusewmi",isusewmi()) : if w("islocalusewmi") then : set_computer(anet.computername) : else : iecho("(wm.class_initialize) => this computer cannot use wmi.") : end if : end sub
'wm_class_terminate() :: iecho, CLASS_WM_TERMINATE_WAITTIME
''class_terminate() :: iecho, CLASS_WM_TERMINATE_WAITTIME
private sub class_terminate : set w = nothing : iecho("(wm.class_terminate) => terminating wm...") : wscript.sleep CLASS_WM_TERMINATE_WAITTIME : end sub
'functions - computer --------------------------------------
'wm_set_computer() :: dic, wm_isvalidcomputer, wm_isvalidclass, ed
''set_computer() :: dic, isvalidcomputer, isvalidclass, ed
private sub set_computer(t) : call dic(w,"computer",t) : call dic(w,"isvalidcomputer",isvalidcomputer()) : if ed(w,"class") then : call dic(w,"isvalidclass",isvalidclass()) : end if : end sub
'wm_computer() :: isstring, wm_set_computer, iecho
''computer() :: isstring, set_computer, iecho
public property let computer(t) : if isstring(t) then : set_computer(t) : else : iecho("(wm.computer) => wants (string)") : end if : end property
'?wm_isvalidcomputer() :: dic, isping, 
''?isvalidcomputer() :: dic, isping, 
private function isvalidcomputer() : call dic(w,"isping",isping(w("computer"))) : if w("isping") then : on error resume next : call dic(w,"srvex",getobject("winmgmts:\\"&w("computer")&"\root\cimv2")) : isvalidcomputer = not (err.number <> 0) : err.clear : else : isvalidcomputer = false : end if : if not isvalidcomputer then : set w("srvex") = nothing : end if : end function
'functions - class -----------------------------------------
'wm_set_class() :: dic, wm_isvalidclass
''set_class() :: dic, isvalidclass
private sub set_class(c) : call dic(w,"class",c) : call dic(w,"isvalidclass",isvalidclass()) : end sub
'wm_class() :: isstring, wm_set_class, iecho, dic, wm_isvalidclass
''class() :: isstring, set_class, iecho, dic, isvalidclass
public property let [class](c) : if isstring(c) then : set_class(c) : else : iecho("(wm.class) => wants (string)") : end if : call dic(w,"isvalidclass",isvalidclass()) : end property
'?wm_isvalidclass() :: dic, 
''?isvalidclass() :: dic, 
private function isvalidclass() : if w("isping") then : on error resume next : call dic(w,"objex",getobject("winmgmts:\\"&w("computer")&"\root\cimv2:"&w("class"))) : call dic(w,"objset",getobject("winmgmts:\\"&w("computer")&"\root\cimv2").instancesof(w("class"))) : isvalidclass = not (err.number <> 0) : err.clear : else : isvalidclass = false : end if : if not isvalidclass then : set w("objectex") = nothing : set w("objectset") = nothing : end if : end function
'functions - execquery -------------------------------------
'*wm_execquery() :: iecho
''*execquery() :: iecho
public function execquery() : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : set execquery = w("srvex").execquery("select * from "&w("class")) : else : iecho("(wm.execquery) => unfilled condition. check computer/class name or pinging to host") : end if : end function
'*wm_execquery2d() :: adic, dic, iecho
''*execquery2d() :: adic, dic, iecho
public function execquery2d() : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : dim d,a,b,c,count : count = 0 : set d = adic() : for each a in w("srvex").execquery("select * from "&w("class")) : set c = adic() : for each b in a.properties_ : call dic(c, b.name, b.value) : next : call dic(d,count,c) : count = count + 1 : next : set execquery2d = d : else : iecho("(wm.execquery2d) => unfilled condition. check computer/class name or pinging to host") : end if : if not isobject(execquery2d) then : set execquery2d = adic() : end if : end function
'*wm_q() :: wm_execquery
''*q() :: execquery
public function q() : set q = execquery() : end function
'*wm_q2d() :: wm_execquery2d
''*q2d() :: execquery2d
public function q2d() : set q2d = execquery2d() : end function
'*wm_filteredquery(string) :: isstring, wm_hasproperty, eecho, iecho
''*filteredquery(string) :: isstring, hasproperty, eecho, iecho
public function filteredquery(f) : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : if isstring(f) then : dim q : set q = w("srvex").execquery("select "&f&" from "&w("class")) : if not hasproperty(f) then : eechon("(wm.filteredquery) => return_object has no such property('"&f&"') on class('"&w("class")&"')") : set filteredquery = nothing : else : set filteredquery = q : end if : else : iecho("(wm.filteredquery) => wants (string)") : end if : else : iecho("(wm.filteredquery) => unfilled condition. check computer/class name or pinging to host") : end if : end function
'*wm_filteredquery2d(string) :: isstring, adic, wm_hasproperty
''*filteredquery2d(string) :: isstring, adic, hasproperty
public function filteredquery2d(f) : if w("islocalusewmi") and w("isvalidcomputer") and w("isvalidclass") and w("isping") then : if isstring(f) then : dim d,a,b,c,count,q : count = 0 : set d = adic() : set q = w("srvex").execquery("select "&f&" from "&w("class")) : if not hasproperty(f) then : eechon("(wm.filteredquery2d) => return_object has no such property('"&f&"') on class('"&w("class")&"')") : set filteredquery2d = nothing : else : for each a in q : set c = adic() : for each b in a.properties_ : call dic(c, b.name, b.value) : next : call dic(d,count,c) : count = count + 1 : next : set filteredquery2d = d : end if : else : iecho("(wm.filteredquery2d) => wants (string)") : end if : else : iecho("(wm.filteredquery2d) => unfilled condition. check computer/class name or pinging to host") : end if : if not isobject(filteredquery2d) then : set filteredquery2d = adic() : end if : end function
'*wm_fq(string) :: wm_filteredquery
''*fq(string) :: filteredquery
public function fq(f) : set fq = filteredquery(f) : end function
'*wm_fq2d(string) :: wm_filteredquery2d
''*fq2d(string) :: filteredquery2d
public function fq2d(f) : set fq2d = filteredquery2d(f) : end function
'functions - check class -----------------------------------
'?wm_hasproperty(string) :: isstring, rmatchi, iecho
''?hasproperty(string) :: isstring, rmatchi, iecho
private function hasproperty(f) : hasproperty = false : if isstring(f) then : dim a,b : for each a in q() : for each b in a.properties_ : if rmatchi(b.name,f) then : hasproperty = true : exit for : end if : next : exit for : next : else : iecho("(wm.hasproperty) => wants (string)") : end if : end function : 
'functions - debug -----------------------------------------
'wm_dump() :: dumper
''dump() :: dumper
public function dump() : dumper(w) : end function
'----------------------------------------------------------
end class
'<!-- this line works as delimitre -->
'script starts here

'vbEmpty	0	Empty  ()
'vbNull	1	Null  ()
'vbInteger	2	
'vbLong	3	 (Long)
'vbSingle	4	 (Single)
'vbDouble	5	 (Double)
'vbCurrency	6	 (Currency)
'vbDate	7	 (Date)
'vbString	8	
'vbObject	9	 
'vbError	10	
'vbBoolean	11	 (Boolean)
'vbVariant	12	 (Variant) ()
'vbDataObject	13	 
'vbByte	17	
'vbArray	8192	 (Array)

dim FUNCTION_CHECKTYPE_TYPES
    FUNCTION_CHECKTYPE_TYPES = array(vbEmpty, vbNull, vbInteger, vbLong, vbSingle, vbDouble, vbCurrency, vbDate, vbString, vbObject, vbError, vbBoolean, vbVariant, vbDataObject, vbByte, vbArray)

dumper( foreach_typematch(array(2,afso), "integer" ))

'+typedesc(value|array) :: \message generator for variable type (for cerr)\
function typedesc(n) : dim b, buf : buf = " " : if isarray(n) then : for each b in n : buf = buf&typename(b)&"("&vartype(b)&"), " : next : buf = left(buf, len(buf)-2) : else : buf = typename(n)&"("&vartype(n)&")" : end if : typedesc = trim(buf) : end function

'?foreach_rmatch(array, string) :: isstring, rmatch, cerr, typedesc \if regular expression match string in array, return true\
function foreach_rmatch(a,t) : if isarray(a) and isstring(t) then : dim b : for each b in a : if rmatch(b, t) then : foreach_rmatch = true : exit function : end if : next : else : cerr("(foreach_rmatch): wants ('array','string') ["&typedesc(array(a,t))&"]") : end if : foreach_rmatch = false : end function

'?foreach_strcmp(array, string) :: isstring, strcmp, cerr, typedesc \if match string in array, return true\
function foreach_strcmp(a,t) : if isarray(a) and isstring(t) then : dim b : for each b in a : if strcmp(b, t) then : foreach_strcmp = true : exit function : end if : next : else : cerr("(foreach_strcmp): wants ('array','string') ["&typedesc(array(a,t))&"]") : end if : foreach_strcmp = false : end function

'?foreach_typematch(array, string) :: isstring, rmatchi, cerr, typedesc \if match typename in array, return true. 'string' allowed regular expression.\
function foreach_typematch(a,t) : if isarray(a) and isstring(t) then : dim b : for each b in a : if rmatchi(typename(b), t) then : foreach_typematch = true : exit function : end if : next : else : cerr("(foreach_typematch): wants ('array','string') ["&typedesc(array(a,t))&"]") : end if : foreach_typematch = false : end function

'

'
function foreachr_replace(a,p,q)
end function

'?checktype(variant, array) :: \\
function checktype(t, checks)
	dim b
	for each b in checks
		if cbool(vartype(t) and b) then
			checktype = true
			exit function
		end if
	next
	checktype = false
end function


]]>
</script>
</job>

<!-- version of skel.wsf -->
<!-- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -->
<job id="version" error="true" debug="false">
<runtime>
<description>skel.wsf  skelv() </description>
<example>cscript skel.wsf //job:version</example>
</runtime>
<script language="VBScript">
<![CDATA[
option explicit

wscript.echo replace(replace(replace(createobject("Scripting.FileSystemObject").getfile(wscript.scriptfullname).datelastmodified," ",""),"/",""),":","")

]]>
</script>
</job>


<!-- extract skel.vbs from skel.wsf -->
<!-- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -->
<job id="extract" error="true" debug="false">
<runtime>
<description>skel.wsf  skel.vbs 
project 
</description>
<named name="project" helpstring=" '^([\w]+\\*)+?$' " type="string" retuired="false" />
<named name="overwrite" helpstring="" type="string" retuired="false" />
<example>cscript skel.wsf //job:extract [/project:PROJECT_NAME [/overwrite]]</example>
<!--
	projectname\
	+- bin\
	+- conf\
	+- log\
	+- lib\
		+- skel.vbs
//-->
</runtime>
<script language="VBScript">
<![CDATA[
option explicit

'--script starts here--
const DELIMITER = "^'<!-- this line works as delimitre -->$"
const PROJECTNAME_PATTERN = "^([\w]+\\*)+?$"
const DIRECTORY_LIST = "bin conf lib log"
dim afso : set afso = createobject("Scripting.FileSystemObject")
dim f : set f = afso.opentextfile(wscript.scriptfullname)
dim rgp : set rgp = new regexp
dim flg : flg = false
dim fwrite 'file pointer
dim buffer 'buffer
dim vbs_filename, wsf_filename 'filename
dim projectname 'projectname if set by /project

'project or else?
if wscript.arguments.named.exists("project") then
	projectname = wscript.arguments.named("project")
	if not len(projectname)>0 then
		wscript.echo "[ERR] project name is empty."
		wscript.quit(1)
	end if
	rgp.pattern = PROJECTNAME_PATTERN
	if not rgp.test(projectname) then
		wscript.echo "[ERR] project name has not allowed character, use only '([\w_]\\*)+?'"
		wscript.quit(1)
	end if
end if

'build path
if not isempty(projectname) then
	if instr(projectname,"\")>0 then
		wsf_filename = left(projectname, instr(projectname,"\")-1)&".wsf"
	else
		wsf_filename = projectname&".wsf"
	end if
	wsf_filename = afso.buildpath(projectname, wsf_filename)
	vbs_filename = afso.buildpath(projectname, "lib\"&afso.getbasename(wscript.scriptname)&".vbs")
	if afso.folderexists(afso.getparentfoldername(vbs_filename)) then
		if not wscript.arguments.named.exists("overwrite") then
			wscript.echo "[ERR] '"&projectname&"' project is already exist."
			wscript.quit(2)
		end if
	end if
	call mkdir(afso.getparentfoldername(vbs_filename))
	for each buffer in split(DIRECTORY_LIST)
		if not afso.folderexists(afso.buildpath(projectname, buffer)) then
			call mkdir(afso.buildpath(projectname, buffer))
		end if
	next
else
	vbs_filename = afso.getbasename(wscript.scriptname)&".vbs"
end if

'set pointer to write for `vbs_filename`
set fwrite = afso.opentextfile(vbs_filename, 2, true)

'write out to `vbs_filename`
''skelv
fwrite.writeline("const skelv = """&replace(replace(replace(afso.getfile(wscript.scriptfullname).datelastmodified," ",""),"/",""),":","")&"""")
''functions
rgp.pattern = DELIMITER
do until f.atendofstream
	buffer = f.readline
	if rgp.test(buffer) then
		flg = not flg
	end if 
	if flg then
		'wscript.echo buffer
		fwrite.writeline(buffer)
	end if
loop

'write out to `wsf_filename`
if not isempty(wsf_filename) then
	set fwrite = afso.opentextfile(wsf_filename, 2, true)
	fwrite.writeline("<?xml version=""1.0"" encoding=""Shift_JIS"" standalone=""yes"" ?>")
	fwrite.writeline("<package><job error=""true"" debug=""false""><runtime>")
	fwrite.writeline("<description>  </description>")
	fwrite.writeline("<!-- skel.vbs  //-->")
	fwrite.writeline("<named name=""logbase"" helpstring="""" type=""string"" required=""false"" />")
	fwrite.writeline("<named name=""noconfigure"" helpstring=""(sensored)"" type=""string"" required=""false"" />")
	fwrite.writeline("<named name=""notypecast"" helpstring=""(sensored)"" type=""string"" required=""false"" />")
	fwrite.writeline("<named name=""configure"" helpstring=""(sensored)"" type=""string"" required=""false"" />")
	fwrite.writeline("<!-- ---- //-->")
	fwrite.writeline("</runtime>")
	fwrite.writeline("<script language=""VBScript"" src=""lib\skel.vbs""></script>")
	fwrite.writeline("<script language=""VBScript"">")
	fwrite.writeline("<![CDATA[")
	fwrite.writeline("option explicit")
	fwrite.writeline("'write logs to console as default. if you need to write to file, to set TYPENAME to flog(1|2|3|4|5|6)")
	fwrite.writeline("'FUNCTION_FLOG_TYPENAME = ""flog6"""&vbnewline)
	fwrite.writeline("'--script starts here--"&vbnewline)
	fwrite.writeline("'==functions are here=="&vbnewline)
	fwrite.write("]") : fwrite.writeline("]>")
	fwrite.write("</") : fwrite.writeline("script>")
	fwrite.write("</") : fwrite.writeline("job>")
	fwrite.write("</") : fwrite.writeline("package>")
end if

wscript.quit(0)
'==functions are here==
'recursive mkdir
function mkdir(n)
	if (instr(n,"\")>0) then
		call mkdir(afso.getparentfoldername(n))
	end if
	if not afso.folderexists(n) then
		call afso.createfolder(n)
		mkdir = true
	else
		mkdir = false
	end if
end function

]]>
</script>
</job>

<!-- shows dependence of functions and extact utility -->
<!-- ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- -->
<job id="deptree" error="true" debug="false">
<runtime>
<description>skel.wsf 
extract  vbs </description>
<unnamed name="FUNCTION_NAME" helpstring="" type="string" retuired="true" />
<named name="extract" helpstring=" vbs " type="string" retuired="false" />
<named name="list" helpstring="" type="string" retuired="false" />
<example>cscript skel.wsf //job:deptree {FUNCTION_NAME [/extract] | /list}</example>
</runtime>
<script language="VBScript" src="lib\dumper.vbs"></script>
<script language="VBScript">
<![CDATA[
option explicit

const DELIMITER = "^'<!-- this line works as delimitre -->$"
const DESCRIPTION = "^'(\?|\+|\*)*([a-zA-Z_\d]*)\((.*)\)\s*::\s*([a-zA-Z\d, _]*)(\\(.*)\\)*\s*$"
const TRIMPATTERN = ",\s*$"
dim src, fwrite
dim buffer, bufmatch, bufdic, buf
dim deps : set deps = createobject("scripting.dictionary")
dim called : set called = createobject("scripting.dictionary")
dim funcs : set funcs = createobject("scripting.dictionary")
dim rgp : set rgp = new regexp
dim flg : flg = false
dim afso : set afso = createobject("scripting.filesystemobject")
set src = afso.getfile(wscript.scriptfullname).openastextstream(1)

'read own
do until src.atendofstream
	buffer = src.readline
	rgp.pattern = DELIMITER
	if rgp.test(buffer) then
		flg = not flg
	end if
	if flg then
		rgp.pattern = DESCRIPTION
		if rgp.test(buffer) then
			set bufmatch = rgp.execute(buffer)
			set bufdic = createobject("scripting.dictionary")
			call bufdic.add("raw", buffer)
			call bufdic.add("type", bufmatch(0).submatches(0))
			call bufdic.add("name", bufmatch(0).submatches(1))
			rgp.pattern = TRIMPATTERN
			call bufdic.add("args", split(replace(rgp.replace(bufmatch(0).submatches(2),"")," ",""),","))
			call bufdic.add("deps", split(replace(rgp.replace(bufmatch(0).submatches(3),"")," ",""),","))
			call bufdic.add("description", bufmatch(0).submatches(5))
			rgp.pattern = "^wm_.*" 'ignore 'wm_' functions
			if not rgp.test(bufmatch(0).submatches(1)) then
				call funcs.add(bufmatch(0).submatches(1), src.readline)
			end if
			call deps.add(bufmatch(0).submatches(1), bufdic)
		end if
	end if
loop

if wscript.arguments.named.exists("list") then
	for each buffer in deps
		cstdw buffer&", "
	next
	wscript.quit(0)
end if

if wscript.arguments.unnamed.count < 1 then
	cerr "missing arguments"
	wscript.arguments.showusage
	wscript.quit(1)
end if

if not deps.exists(wscript.arguments.unnamed(0)) then
	cstd wscript.arguments.unnamed(0)&"() is not defined."
	wscript.quit(0)
end if

'show dependence
cstd(wscript.arguments.unnamed(0)&"() depend on:")
call tree(0, wscript.arguments.unnamed(0), deps(wscript.arguments.unnamed(0))("deps"))

if wscript.arguments.named.exists("extract") then
	set fwrite = afso.opentextfile(wscript.arguments.unnamed(0)&".vbs", 2, true)
	for each buffer in called
		if funcs.exists(buffer) then
			fwrite.writeline(deps(buffer)("raw"))
			fwrite.writeline(funcs(buffer))
		else
			cstd "'missing "&buffer&"()"
			fwrite.writeline("'missing "&buffer&"()")
		end if
	next
end if

'show applied to 
cstd("")
cstd(wscript.arguments.unnamed(0)&"() applied to:")
for each buffer in deps
	for each buf in deps(buffer)("deps")
		if buf = wscript.arguments.unnamed(0) then
			cstd " "&buffer&"()"
		end if
	next
next


wscript.quit(0)
'==functions are here==
function cstd(s) : wscript.stdout.writeline(s) : end function
function cstdw(s) : wscript.stdout.write(s) : end function
function cerr(s) : wscript.stderr.writeline("[ERR ] "&s) : end function
function tree(i, fn, dp)
	dim f
	if not called.exists(fn) then
		call called.add(fn, fn)
	end if
	cstd string(i," ")&fn&"()"
	for each f in dp
		if not called.exists(f) then
			if deps.exists(f) then
				call tree(i+1, f, deps(f)("deps"))
			else
				rgp.pattern = "[A-Z_][A-Z_0-9]*"
				if rgp.test(f) then
					cstd string(i+1," ")&f&" [CONST]"
				else
					cstd string(i+1," ")&f&"() [UNDEFINED]"
					cstd "[ERR] undefined function. "&f&"()"
				end if
			end if
		else
			cstd string(i+1," ")&f&"() ..."
		end if
	next
end function
]]>
</script>
</job>
</package>
